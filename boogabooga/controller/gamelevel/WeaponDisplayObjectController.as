/** WeaponDisplayObjectController  *	---------------------------------------------------------------------------- *  *	@desc:  *		Thils class controls all the weapons that are currently on the board  *		active or non active.  *	  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */	package com.boogabooga.controller.gamelevel	{		import flash.display.MovieClip;		import flash.events.*;		import flash.errors.*;		import flash.geom.Point;		import flash.utils.getDefinitionByName;		import flash.utils.getQualifiedClassName;		import flash.utils.getTimer;		import flash.utils.Timer;				import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.cache.HashTable;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.sound.SoundEffectPlayer;		import org.osflash.signals.Signal;				import com.boogabooga.controller.gamelevel.DisplayObjectController;		import com.boogabooga.data.SettingsIndex;		import com.boogabooga.data.SoundsIndex;		import com.boogabooga.data.gamelevel.Projectile;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.Gameboard;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.weapons.*;		import com.boogabooga.ui.gamelevel.GameLevelDisplayLayerItem;		import com.boogabooga.utils.GameLevelUtil;				public class WeaponDisplayObjectController extends DisplayObjectController		{			protected var _gameboardController:GameboardController;			protected var _enemyDisplayObjectController:EnemyDisplayObjectController;			//protected var _weaponDisplayObjects:Array;			protected var _weaponDisplayObjects:Vector.<WeaponDisplayObject>;			protected var _weaponDisplayObjectsLength:uint;			//protected var _blockingWeaponDisplayObjects:Array;			//protected var _occupiedTiles:Array;			protected var _currentWeaponRolledOver:WeaponDisplayObject;						public var onWeaponRolledOver:Signal;			public var onWeaponRolledOut:Signal;			public var onWeaponDied:Signal;			public var onWeaponAttackTimerFired:Signal;			public var onProjectileWeaponFired:Signal;			public var onBombWeaponExploded:Signal;			public var onTrapWeaponFired:Signal;			public var onCatapultWeaponFired:Signal;			public var onMultipleDirectionsProjectileWeaponFired:Signal;			public var onPathWeaponMovedToNextPoint:Signal;			public var onPathWeaponPathEnded:Signal;			public var onMultipleWeaponsWeaponFired:Signal;						/** Constructor			  *	---------------------------------------------------------------------------- */			 	public function WeaponDisplayObjectController()				{					init();				}								public function set gameboardController( gc:GameboardController ):void { _gameboardController = gc; }							/** set enemyDisplayObjectController			  *	---------------------------------------------------------------------------- */				public function set enemyDisplayObjectController( controller:EnemyDisplayObjectController ):void { _enemyDisplayObjectController = controller; }							/** get weaponDisplayObjects			  *	---------------------------------------------------------------------------- */				public function get weaponDisplayObjects():Vector.<WeaponDisplayObject> { return _weaponDisplayObjects; }				public function get weaponDisplayObjectsLength():uint { return _weaponDisplayObjectsLength; }							/** get occupiedTiles			  *	---------------------------------------------------------------------------- */				//public function get occupiedTiles():Array { return _occupiedTiles; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_debug = true;										//_weaponDisplayObjects = new Array();					_weaponDisplayObjects = new Vector.<WeaponDisplayObject>;					_weaponDisplayObjectsLength = 0;					//_blockingWeaponDisplayObjects = new Array();					//_occupiedTiles = new Array();										onWeaponRolledOver = new Signal( WeaponDisplayObject );					onWeaponRolledOut = new Signal();					onWeaponDied = new Signal( WeaponDisplayObject, Number );					onWeaponAttackTimerFired = new Signal( WeaponDisplayObject );					onProjectileWeaponFired = new Signal( WeaponDisplayObject, Point, Number );					onBombWeaponExploded = new Signal( WeaponDisplayObject, Number );					onTrapWeaponFired = new Signal( WeaponDisplayObject, Number );					onCatapultWeaponFired = new Signal( WeaponDisplayObject, Point, Number );					onMultipleDirectionsProjectileWeaponFired = new Signal( WeaponDisplayObject, Point, Point, Point, Point, Number );					onPathWeaponMovedToNextPoint = new Signal( WeaponDisplayObject );					onPathWeaponPathEnded = new Signal( WeaponDisplayObject );					onMultipleWeaponsWeaponFired = new Signal( WeaponDisplayObject, Point, Number );				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "pause();" );										for( var i:uint=0; i<_weaponDisplayObjectsLength; ++i )					{						_weaponDisplayObjects[i].pause();					}										//TODO:					//	Do blocking weapons need to be paused ??				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "unpause();" );										for( var i:uint=0; i<_weaponDisplayObjectsLength; ++i )					{						_weaponDisplayObjects[i].unpause();					}										//TODO:					//	If blocking weapons are paused, unpause them !!				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "kill();" );										/*					for( var i:uint=0; i<_weaponDisplayObjects.length; ++i )					{						WeaponDisplayObject(_weaponDisplayObjects[i]).kill();						_weaponDisplayObjects[i] = null;					}					*/					while( _weaponDisplayObjects.length > 0 )						removeWeapon( _weaponDisplayObjects[0] );										_weaponDisplayObjects = null;					/*					for( var i:uint=0; i<_blockingWeaponDisplayObjects.length; ++i )					{						WeaponDisplayObject(_blockingWeaponDisplayObjects[i]).kill();						_blockingWeaponDisplayObjects[i] = null;					}					*/					//while( _blockingWeaponDisplayObjects.length > 0 )						//removeWeapon( _blockingWeaponDisplayObjects[0] );										//_blockingWeaponDisplayObjects = null;										_gameboardController = null;					_enemyDisplayObjectController = null;										onWeaponRolledOver = null;					onWeaponRolledOut = null;					onWeaponDied = null;					onWeaponAttackTimerFired = null;					onProjectileWeaponFired = null;					onBombWeaponExploded = null;					onTrapWeaponFired = null;					onCatapultWeaponFired = null;					onMultipleDirectionsProjectileWeaponFired = null;					onPathWeaponMovedToNextPoint = null;					onPathWeaponPathEnded = null;					onMultipleWeaponsWeaponFired = null;										super.kill();				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				public function updateOnEnterFrame():void				{					for( var i:int=0; i<_weaponDisplayObjectsLength; ++i )					{						_weaponDisplayObjects[i].updateOnEnterFrame();					}				}							/** enableInteraction			  *	---------------------------------------------------------------------------- *			  *	Enables the weapon display object interactions.			  *	---------------------------------------------------------------------------- */				public function enableInteraction():void				{					for( var i:int=0; i<_weaponDisplayObjectsLength; ++i )					{						if( !_weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ADDITION_INDEX) && !_weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SHIELD_INDEX) )							_weaponDisplayObjects[i].enableInteraction();						//_weaponDisplayObjects[i].contentClip.addEventListener( MouseEvent.ROLL_OVER, handleWeaponRolledOver, false, 0, true );						//_weaponDisplayObjects[i].contentClip.addEventListener( MouseEvent.ROLL_OUT, handleWeaponRolledOut, false, 0, true );					}				}							/** disableInteraction			  *	---------------------------------------------------------------------------- *			  *	Disables the weapon display object interactions.			  *	---------------------------------------------------------------------------- */				public function disableInteraction():void				{					for( var i:int=0; i<_weaponDisplayObjectsLength; ++i )					{						_weaponDisplayObjects[i].disableInteraction();						//_weaponDisplayObjects[i].contentClip.removeEventListener( MouseEvent.ROLL_OVER, handleWeaponRolledOver, false, 0, true );						//_weaponDisplayObjects[i].contentClip.removeEventListener( MouseEvent.ROLL_OUT, handleWeaponRolledOut, false, 0, true );					}				}								protected function handleWeaponRolledOver( weaponDisplayObject:WeaponDisplayObject ):void				{					_currentWeaponRolledOver = weaponDisplayObject;										//var localPosition:Point = UtilFunctions.localToLocal( _currentWeaponRolledOver.contentClip, _gameboardController.gameboardReference.weaponMarker_mc.parent );					//_gameboardController.gameboardReference.weaponMarker_mc.x = localPosition.x;					//_gameboardController.gameboardReference.weaponMarker_mc.y = localPosition.y;					//_gameboardController.gameboardReference.weaponMarker_mc.visible = true;										//_currentWeaponRolledOver.contentClip.stage.addEventListener( MouseEvent.MOUSE_MOVE, handleMouseMoveWhenWeaponIsRolledOver, false, 0, true );										//if( !UtilFunctions.getCollisionRect( _gameboardController.gameboardReference.weaponMarker_mc, _currentWeaponRolledOver.contentClip, _gameboardController.gameboardReference ).isEmpty() )						//dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_WEAPON_ROLLED_OVER, {weaponDisplayObject:_currentWeaponRolledOver}) );					onWeaponRolledOver.dispatch( _currentWeaponRolledOver );				}								protected function handleWeaponRolledOut( weaponDisplayObject:WeaponDisplayObject ):void				{					//_currentWeaponRolledOver.contentClip.stage.removeEventListener( MouseEvent.MOUSE_MOVE, handleMouseMoveWhenWeaponIsRolledOver );					_currentWeaponRolledOver = null;										//dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_WEAPON_ROLLED_OUT) );					onWeaponRolledOut.dispatch();				}				/*				protected function handleMouseMoveWhenWeaponIsRolledOver( event:MouseEvent ):void				{					var localPosition:Point = _gameboardController.gameboardReference.weaponMarker_mc.parent.globalToLocal( new Point(_currentWeaponRolledOver.contentClip.stage.mouseX, _currentWeaponRolledOver.contentClip.stage.mouseY) );					_gameboardController.gameboardReference.weaponMarker_mc.x = localPosition.x;					_gameboardController.gameboardReference.weaponMarker_mc.y = localPosition.y;					//_gameboardController.gameboardReference.weaponMarker_mc.visible = true;										if( !UtilFunctions.getCollisionRect( _gameboardController.gameboardReference.weaponMarker_mc, _currentWeaponRolledOver.currentAnimationDisplayObject.contentClip , _gameboardController.gameboardReference ).isEmpty() )					{						trace( "rect not empty" );						dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_WEAPON_ROLLED_OVER, {weaponDisplayObject:_currentWeaponRolledOver}) );					}					else					{						trace( "rect empty" );						dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_WEAPON_ROLLED_OUT) );					}				}				*/			/** addWeapon			  *	---------------------------------------------------------------------------- *			  *	Add weaponDisplayObject to the controller system.			  *	---------------------------------------------------------------------------- */				public function addWeapon( displayObject:WeaponDisplayObject ):void				{					//trace( "time when addWeapon called: "+getTimer() );										var i:int;										//displayObject.addEventListener( GameLevelEvent.DIE, handleWeaponDied, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.REMOVE_FROM_GAME, handleWeaponRemovedFromGame, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.HIT, handleWeaponHit, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.ATTACK_TIMER_FIRE, handleWeaponAttackTimerFired, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.ON_WEAPON_ROLLED_OVER, handleWeaponRolledOver, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.ON_WEAPON_ROLLED_OUT, handleWeaponRolledOut, false, 0, true );					displayObject.onDied.add( handleWeaponDied );					displayObject.onRemovedFromGame.add( handleWeaponRemovedFromGame );					displayObject.onHit.add( handleWeaponHit );					displayObject.onAttackTimerFired.add( handleWeaponAttackTimerFired );					displayObject.onRolledOver.add( handleWeaponRolledOver );					displayObject.onRolledOut.add( handleWeaponRolledOut );										if( displayObject is ShieldWeaponDisplayObject )					{						for( i=0; i<_weaponDisplayObjectsLength; ++i )						{							if( _weaponDisplayObjects[i].currentTile.isTheSameAsTile(displayObject.currentTile) && !(_weaponDisplayObjects[i] is AdditionWeaponDisplayObject) )							{								_weaponDisplayObjects[i].shield = displayObject as ShieldWeaponDisplayObject;								break;							}						}					}					else if( displayObject is AdditionWeaponDisplayObject )					{											}					else					{						if( displayObject is ProjectileWeaponDisplayObject )						{							//displayObject.addEventListener( GameLevelEvent.PROJECTILE_FIRE, handleProjectileWeaponFired, false, 0, true );							displayObject.onProjectileFired.add( handleProjectileWeaponFired );						}						else if( displayObject is BombWeaponDisplayObject )						{							//displayObject.addEventListener( GameLevelEvent.BOMB_EXPLODE, handleBombWeaponExploded, false, 0, true );							displayObject.onBombExploded.add( handleBombWeaponExploded );							//(displayObject as BombWeaponDisplayObject).startExplodeTimer();						}						else if( displayObject is TrapWeaponDisplayObject )						{							//displayObject.addEventListener( GameLevelEvent.TRAP_FIRE, handleTrapWeaponFired, false, 0, true );							displayObject.onTrapFired.add( handleTrapWeaponFired );						}						else if( displayObject is CatapultWeaponDisplayObject )						{							//displayObject.addEventListener( GameLevelEvent.CATAPULT_FIRE, handleCatapultWeaponFired, false, 0, true );							displayObject.onCatapultFired.add( handleCatapultWeaponFired );						}						else if( displayObject is MultipleDirectionsProjectileWeaponDisplayObject )						{							//displayObject.addEventListener( GameLevelEvent.MULTIPLE_DIRECTIONS_PROJECTILE_FIRE, handleMultipleDirectionsProjectileFired, false, 0, true );							displayObject.onMultipleDirectionsProjectileFired.add( handleMultipleDirectionsProjectileWeaponFired );						}						else if( displayObject is PathWeaponDisplayObject )						{							//displayObject.addEventListener( GameLevelEvent.MOVING, handleFullLaneWeaponMoving, false, 0, true );							//displayObject.addEventListener( GameLevelEvent.MOVING_TO_NEXT_TILE, handleFullLaneWeaponMovingToNextTile, false, 0, true );							//displayObject.addEventListener( GameLevelEvent.PATH_END, handleFullLaneWeaponPathEnd, false, 0, true );							displayObject.onMovedToNextPoint.add( handlePathWeaponMovedToNextPoint );							displayObject.onMovedToNextTile.add( handlePathWeaponMovedToNextTile );							displayObject.onPathEnded.add( handlePathWeaponPathEnded );						}						else if( displayObject is MultipleWeaponsWeaponDisplayObject )						{							//displayObject.addEventListener( GameLevelEvent.MULTIPLE_WEAPONS_FIRE, handleMultipleWeaponsWeaponFired, false, 0, true );							displayObject.onMultipleWeaponsFired.add( handleMultipleWeaponsWeaponFired );						}												if( displayObject.currentTile.occupiedByAddition )						{							for( i=0; i<_weaponDisplayObjectsLength; ++i )							{								if( _weaponDisplayObjects[i].currentTile.isTheSameAsTile(displayObject.currentTile) && (_weaponDisplayObjects[i] is AdditionWeaponDisplayObject) )								{									displayObject.addition = _weaponDisplayObjects[i] as AdditionWeaponDisplayObject;									break;								}							}						}					}										displayObject.positionIn2D.x = displayObject.currentTile.positionIn2D.x;					displayObject.positionIn2D.y = displayObject.currentTile.positionIn2D.y;					displayObject.render();										if( displayObject is ShieldWeaponDisplayObject )					{						displayObject.currentTile.occupiedByShield = true;					}					else if( displayObject is AdditionWeaponDisplayObject )					{						displayObject.currentTile.occupiedByAddition = true;					}					else if( !(displayObject is PathWeaponDisplayObject) )					{						displayObject.currentTile.occupiedByWeapon = true;					}										displayObject.path = _gameboardController.attackingDisplayObjectController.getPath( displayObject.currentTile );					displayObject.pathIndex = _gameboardController.attackingDisplayObjectController.getPathIndex( displayObject.currentTile );					displayObject.currentIndexInPath = _gameboardController.attackingDisplayObjectController.getCurrentIndexInPath( displayObject.currentTile, displayObject.path );										_weaponDisplayObjects.push( displayObject );					_weaponDisplayObjectsLength = _weaponDisplayObjects.length;										//trace( "direction: "+displayObject.direction );										//if( displayObject.attackingGameObject.typeIndex != GameLevelUtil.ATTACK_PROPERTY_ Weapon.TYPE_BLOCKING_INDEX )					//{						//displayObject.currentTile.addWeaponWatching( displayObject );						//displayObject.pathIndex = _gameboardController.attackingDisplayObjectController.getPathIndex( displayObject.currentTile );						//_gameboardController.pathController.markTilesForWeapon( displayObject );						//trace( "getTilesInAttackRange: "+_gameboardController.attackingDisplayObjectController.getTilesInAttackRange(displayObject) );					//}										//NOTE:					//	Find the range of the weapon and add the weapon watching to that tile															//trace( displayObject.currentTile );										/*					if( !checkIfAnyWeaponsInThisTile(displayObject.currentTile) )					{						_occupiedTiles.push( {r:displayObject.currentTile.row, c:displayObject.currentTile.column} );					}					*/										if( displayObject is ShieldWeaponDisplayObject )					{						if( displayObject.direction == GameLevelUtil.DIRECTION_UP || displayObject.direction == GameLevelUtil.DIRECTION_RIGHT )						{							_gameboardReference.displayLayerClip.addClipToLayerInBack( displayObject.contentClip, displayObject.currentTile.layerNumber );						}						else						{							_gameboardReference.displayLayerClip.addClipToLayerInFront( displayObject.contentClip, displayObject.currentTile.layerNumber );						}												displayObject.disableInteraction();					}					else if( displayObject is AdditionWeaponDisplayObject )					{						_gameboardReference.displayLayerClip.moveClipToLayer( displayObject.contentClip, displayObject.currentTile.layerNumber, GameLevelDisplayLayerItem.LAYER_FOREGROUND );						displayObject.additionalClipOnGameboard = _gameboardReference.addWeaponAdditionClip( displayObject.attackingGameObject.additionalAttackUpAnimationObject, displayObject );						//displayObject.additionalClipOnGameboard.contentClip.mouseChildren = false;						//displayObject.additionalClipOnGameboard.contentClip.mouseEnabled = false;						displayObject.disableInteraction();						displayObject.contentClip.mouseChildren = false;						displayObject.contentClip.mouseEnabled = false;												//trace( 'displayObject.contentClip.parent.mouseChildren: '+displayObject.contentClip.parent.mouseChildren );						//trace( 'displayObject.contentClip.parent.mouseEnabled: '+displayObject.contentClip.parent.mouseEnabled );												//trace( "displayObject.additionalClipOnGameboard: "+displayObject.additionalClipOnGameboard );					}					else					{						_gameboardReference.displayLayerClip.moveClipToLayer( displayObject.contentClip, displayObject.currentTile.layerNumber );					}										displayObject.placedOnBoard();										var globalPosition:Point = displayObject.contentClip.parent.localToGlobal( new Point(displayObject.contentClip.x, displayObject.contentClip.y) );					EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {particleCacheId:"PlacementPoof", globalPosition:globalPosition} );										//trace( "globalPosition: "+globalPosition );					//trace( "weapon placement sound: "+SoundsIndex.getInstance().getSoundBySoundId("sfx_weapon_placement.wav") );										//SoundEffectPlayer.getInstance().setVolume( SoundsIndex.getInstance().getSoundBySoundId("sfx_weapon_placement.wav").volume, 0, "sfx_weapon_placement.wav" );					SoundEffectPlayer.getInstance().playLibrarySound( "sfx_weapon_placement.wav", false, "sfx_weapon_placement.wav", "sfx_weapon_placement.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );										//dispatchEvent( new CustomEvent("onProjectileFire", {weaponDisplayObject:displayObject, projectile:new Projectile(), shootTo:new Point(displayObject.positionIn2D.x, displayObject.positionIn2D.y+200)}) );				}							/** removeWeapon			  *	---------------------------------------------------------------------------- *			  *	Removes weaponDisplayObject from the controller system.			  *	---------------------------------------------------------------------------- */				public function removeWeapon( displayObject:WeaponDisplayObject ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "removeWeapon("+displayObject+");" );										var weaponDisplayObject:WeaponDisplayObject = VectorUtil.remove( _weaponDisplayObjects, displayObject );					_weaponDisplayObjectsLength = _weaponDisplayObjects.length;										//trace( "weaponDisplayObject: "+weaponDisplayObject );										if( weaponDisplayObject != null )//&& weaponDisplayObject.alive )					{						if( weaponDisplayObject is ShieldWeaponDisplayObject )						{							weaponDisplayObject.currentTile.occupiedByShield = false;						}						else if( weaponDisplayObject is AdditionWeaponDisplayObject )						{							_gameboardReference.removeWeaponAdditionClip( displayObject.additionalClipOnGameboard );							weaponDisplayObject.currentTile.occupiedByAddition = false;						}						else						{							weaponDisplayObject.currentTile.occupiedByWeapon = false;						}												//weaponDisplayObject.removeEventListener( GameLevelEvent.DIE, handleWeaponDied );						//weaponDisplayObject.removeEventListener( GameLevelEvent.REMOVE_FROM_GAME, handleWeaponRemovedFromGame );						//weaponDisplayObject.removeEventListener( GameLevelEvent.HIT, handleWeaponHit );						//weaponDisplayObject.removeEventListener( GameLevelEvent.ATTACK_TIMER_FIRE, handleWeaponAttackTimerFired );						weaponDisplayObject.onDied.remove( handleWeaponDied );						weaponDisplayObject.onRemovedFromGame.remove( handleWeaponRemovedFromGame );						weaponDisplayObject.onHit.remove( handleWeaponHit );						weaponDisplayObject.onAttackTimerFired.remove( handleWeaponAttackTimerFired );						weaponDisplayObject.onRolledOver.remove( handleWeaponRolledOver );						weaponDisplayObject.onRolledOut.remove( handleWeaponRolledOut );												if( displayObject is ProjectileWeaponDisplayObject )						{							//weaponDisplayObject.removeEventListener( GameLevelEvent.PROJECTILE_FIRE, handleProjectileWeaponFired );							weaponDisplayObject.onProjectileFired.remove( handleProjectileWeaponFired );						}						else if( displayObject is BombWeaponDisplayObject )						{							//weaponDisplayObject.removeEventListener( GameLevelEvent.BOMB_EXPLODE, handleBombWeaponExploded );							weaponDisplayObject.onBombExploded.remove( handleBombWeaponExploded );						}						else if( displayObject is TrapWeaponDisplayObject )						{							//weaponDisplayObject.removeEventListener( GameLevelEvent.TRAP_FIRE, handleTrapWeaponFired );							weaponDisplayObject.onTrapFired.remove( handleTrapWeaponFired );						}						else if( displayObject is CatapultWeaponDisplayObject )						{							//weaponDisplayObject.removeEventListener( GameLevelEvent.CATAPULT_FIRE, handleCatapultWeaponFired );							weaponDisplayObject.onCatapultFired.remove( handleCatapultWeaponFired );						}						else if( displayObject is MultipleDirectionsProjectileWeaponDisplayObject )						{							//weaponDisplayObject.removeEventListener( GameLevelEvent.MULTIPLE_DIRECTIONS_PROJECTILE_FIRE, handleMultipleDirectionsProjectileFired );							weaponDisplayObject.onMultipleDirectionsProjectileFired.remove( handleMultipleDirectionsProjectileWeaponFired );						}						else if( displayObject is PathWeaponDisplayObject )						{							//weaponDisplayObject.removeEventListener( GameLevelEvent.MOVING, handleFullLaneWeaponMoving );							//weaponDisplayObject.removeEventListener( GameLevelEvent.MOVING_TO_NEXT_TILE, handleFullLaneWeaponMovingToNextTile );							//weaponDisplayObject.removeEventListener( GameLevelEvent.PATH_END, handleFullLaneWeaponPathEnd );							weaponDisplayObject.onMovedToNextPoint.remove( handlePathWeaponMovedToNextPoint );							weaponDisplayObject.onMovedToNextTile.remove( handlePathWeaponMovedToNextTile );							weaponDisplayObject.onPathEnded.remove( handlePathWeaponPathEnded );						}						else if( displayObject is MultipleWeaponsWeaponDisplayObject )						{							//weaponDisplayObject.removeEventListener( GameLevelEvent.MULTIPLE_WEAPONS_FIRE, handleMultipleWeaponsWeaponFired );							weaponDisplayObject.onMultipleWeaponsFired.remove( handleMultipleWeaponsWeaponFired );						}												weaponDisplayObject.contentClip.parent.removeChild( weaponDisplayObject.contentClip );						weaponDisplayObject.kill();						weaponDisplayObject = null;					}									}							/** unflagHitByLaserAttack			  *	---------------------------------------------------------------------------- *			  *	Resets the flags that these weapons have been hit by this laser enemy.			  *	---------------------------------------------------------------------------- 				public function unflagHitByLaserAttack():void				{					ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "unflagHitByLaserAttack();" );										for( var i:int=0; i<_weaponDisplayObjectsLength; ++i )					{						_weaponDisplayObjects[i].resetHitByLaserEnemy();					}				}*/											/** removeWeaponInTile			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 				public function removeWeaponInTile( tile:GameboardTile ):void				{					var weaponDisplayObject:WeaponDisplayObject = getWeaponInTile( tile );										if( weaponDisplayObject != null )					{						removeWeapon( weaponDisplayObject );					}				}*/							/** getWeaponInTile			  *	---------------------------------------------------------------------------- *			  *	Returns the weapon that is currentonly the tile			  *	---------------------------------------------------------------------------- */				public function getWeaponInTile( tile:GameboardTile ):WeaponDisplayObject				{					//if( _debug ) ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "getWeaponInTile("+tile+");" );										for( var i:uint=0; i<_weaponDisplayObjectsLength; ++i )					{						//trace( "_weaponDisplayObjects[i].currentTile: "+_weaponDisplayObjects[i].currentTile );												if( _weaponDisplayObjects[i].currentTile.row == tile.row && _weaponDisplayObjects[i].currentTile.column  == tile.column && 							!_weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ADDITION_INDEX) &&							!_weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SHIELD_INDEX) )						{							return _weaponDisplayObjects[i];						}					}										return null;				}							/** checkIfAnyWeaponsInThisTile			  *	---------------------------------------------------------------------------- *			  *	Check the tile to see if there's a weapon on it.			  *	---------------------------------------------------------------------------- 				public function checkIfAnyWeaponsInThisTile( tile:GameboardTile ):Boolean				{					for( var i:uint=0; i<_occupiedTiles.length; ++i )					{						if( _occupiedTiles[i].row == tile.row && _occupiedTiles[i].column == tile.column )							return false;					}										return false;				}								public function removeOccupiedTile( tile:GameboardTile ):void				{					for( var i:uint=0; i<_occupiedTiles.length; ++i )					{						if( _occupiedTiles[i].row == tile.row && _occupiedTiles[i].column == tile.column )						{							GameboardTile(_occupiedTiles[i]).occupiedByWeapon = false;							_occupiedTiles.splice( i, 1 );							break;						}					}				}				*/							/** handleWeaponDied			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				protected function handleWeaponDied( weaponDisplayObject:WeaponDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "handleWeaponDied();" );										//removeWeapon( event.currentTarget as WeaponDisplayObject );										if( weaponDisplayObject == _currentWeaponRolledOver )					{						//dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_WEAPON_ROLLED_OUT) );						onWeaponRolledOut.dispatch();					}										if( !weaponDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_BOMB_INDEX ) )					{						var randomIndex:int;												if( weaponDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_STONE_INDEX ) )						{							randomIndex = int(Math.random()*2);							if( randomIndex == 0 )								SoundEffectPlayer.getInstance().playLibrarySound( "sfx_weapon_destroyed_stone_1.wav", false, "sfx_weapon_destroyed_stone_1.wav", "sfx_weapon_destroyed_stone_1.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );							else if( randomIndex == 1 )								SoundEffectPlayer.getInstance().playLibrarySound( "sfx_weapon_destroyed_stone_2.wav", false, "sfx_weapon_destroyed_stone_2.wav", "sfx_weapon_destroyed_stone_2.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );						}						else if( weaponDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_WOOD_INDEX ) )						{							SoundEffectPlayer.getInstance().playLibrarySound( "sfx_wooden_weapon_destroyed.wav", false, "sfx_wooden_weapon_destroyed.wav", "sfx_wooden_weapon_destroyed.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );						}					}										var range:Number = 90 + (weaponDisplayObject.attackingGameObject.deathEffectRange-1)*90;										//trace( "weapon death range: "+range );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.DIE, {weaponDisplayObject:weaponDisplayObject, range:range}) );					onWeaponDied.dispatch( weaponDisplayObject, range );				}							/** handleWeaponRemovedFromGame			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				protected function handleWeaponRemovedFromGame( weaponDisplayObject:WeaponDisplayObject ):void				{					if( weaponDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_TRAP_INDEX) || weaponDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SPRING_TRAP_INDEX) )						_gameboardController.attackingDisplayObjectController.removeWeapon( weaponDisplayObject );										removeWeapon( weaponDisplayObject );				}							/** handleWeaponHit			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				private function handleWeaponHit( weaponDisplayObject:WeaponDisplayObject ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "handleWeaponHit();" );										//trace( "attackProperties: "+WeaponDisplayObject(event.currentTarget).attackingGameObject.attackProperties );					//trace( "hasAttackProperty(Stone): "+WeaponDisplayObject(event.currentTarget).attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_STONE_INDEX ) );					//trace( "hasAttackProperty(Wood): "+WeaponDisplayObject(event.currentTarget).attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_WOOD_INDEX ) );										if( SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_HIT_PARTICLE) )					{						var globalPosition:Point = weaponDisplayObject.contentClip.parent.localToGlobal( new Point(weaponDisplayObject.contentClip.x, weaponDisplayObject.contentClip.y) );												if( weaponDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_STONE_INDEX ) )						{							EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {particleCacheId:"RockChip_Effect", globalPosition:globalPosition} );						}						else if( weaponDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_WOOD_INDEX ) )						{							EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {particleCacheId:"WoodChip_Effect", globalPosition:globalPosition} );						}					}									}							/** handleWeaponAttackTimerFired			  *	---------------------------------------------------------------------------- *			  *	Weapon's rate of fire cools down, now it's asking for another enemy to hit			  *	if there are any in its range.			  *	---------------------------------------------------------------------------- */				protected function handleWeaponAttackTimerFired( weaponDisplayObject:WeaponDisplayObject ):void				{					//dispatchEvent( new GameLevelEvent(GameLevelEvent.ATTACK_TIMER_FIRE, {weaponDisplayObject:weaponDisplayObject}) );					onWeaponAttackTimerFired.dispatch( weaponDisplayObject );				}							/** handleProjectileWeaponFired			  *	---------------------------------------------------------------------------- *			  *	This event is fired when the weapon projectile is fired.			  *	Enemy's rate of fire cools down, now it's asking for another weapon to hit			  *	if there are any in its range.			  *	---------------------------------------------------------------------------- */				protected function handleProjectileWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootTo:Point, altitude:Number ):void				{					ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "handleProjectileWeaponFired();" );										//var customParameters:Object = event.customParameters == null ? new Object() : event.customParameters;						//customParameters.weaponDisplayObject = event.currentTarget as WeaponDisplayObject;						//customParameters.direction = event.currentTarget.direction;											//dispatchEvent( new GameLevelEvent(GameLevelEvent.PROJECTILE_FIRE, customParameters) );										//trace( "shootTo: "+shootTo );					//trace( "altitude: "+altitude );										onProjectileWeaponFired.dispatch( weaponDisplayObject, shootTo, 0 );				}							/** handleBombWeaponExploded			  *	---------------------------------------------------------------------------- */				protected function handleBombWeaponExploded( weaponDisplayObject:WeaponDisplayObject, range:Number ):void				{					//var customParameters:Object = event.customParameters == null ? new Object() : event.customParameters;						//customParameters.weaponDisplayObject = event.currentTarget as WeaponDisplayObject;						//customParameters.range = 45 + (event.currentTarget.attackingGameObject.deathEffectRange-1)*90;					//_enemyDisplayObjectController.attackEnemiesInARange( WeaponDisplayObject(event.currentTarget).positionIn2D, event.customParameters.range, WeaponDisplayObject(event.currentTarget) );										//WeaponDisplayObject(event.currentTarget).kill();					//dispatchEvent( new GameLevelEvent(GameLevelEvent.BOMB_EXPLODE, customParameters) );					//onBombWeaponExploded.dispatch( weaponDisplayObject, range );				}							/** handleTrapWeaponFired			  *	---------------------------------------------------------------------------- */				protected function handleTrapWeaponFired( weaponDisplayObject:WeaponDisplayObject, range:Number ):void				{					//var customParameters:Object = event.customParameters == null ? new Object() : event.customParameters;						//customParameters.weaponDisplayObject = event.currentTarget as WeaponDisplayObject;										//_enemyDisplayObjectController.attackEnemiesInARange( WeaponDisplayObject(event.currentTarget).positionIn2D, event.customParameters.range, WeaponDisplayObject(event.currentTarget) );					//dispatchEvent( new GameLevelEvent(GameLevelEvent.TRAP_FIRE, customParameters) );					onTrapWeaponFired.dispatch( weaponDisplayObject, range );				}							/** handleCatapultWeaponFired			  *	---------------------------------------------------------------------------- */				protected function handleCatapultWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootTo:Point, altitude:Number ):void				{					//var projectile:Projectile = new Projectile();					//	projectile.upAnimationObject = WeaponDisplayObject(event.currentTarget).attackingGameObject.additionalAttackUpAnimationObject;					//	projectile.downAnimationObject = WeaponDisplayObject(event.currentTarget).attackingGameObject.additionalAttackDownAnimationObject;											//dispatchEvent( new GameLevelEvent(GameLevelEvent.CATAPULT_FIRE, {weaponDisplayObject:WeaponDisplayObject(event.currentTarget), shootTo:event.customParameters.shootTo, altitude:event.customParameters.altitude}) );					onCatapultWeaponFired.dispatch( weaponDisplayObject, shootTo, 0 );				}							/** handleMultipleDirectionsProjectileWeaponFired			  *	---------------------------------------------------------------------------- *			  *	Dispatched when a MulitpleDirectionsWeaponDisplayObject fires.			  *	e.g. Multi Direction Coconut Shooter			  *	---------------------------------------------------------------------------- */				protected function handleMultipleDirectionsProjectileWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootToUp:Point, shootToRight:Point, shootToDown:Point, shootToLeft:Point, altitude:Number ):void				{					//var customParameters:Object = event.customParameters;						//customParameters.weaponDisplayObject = event.currentTarget as MultipleDirectionsProjectileWeaponDisplayObject;										//dispatchEvent( new GameLevelEvent(GameLevelEvent.MULTIPLE_DIRECTIONS_PROJECTILE_FIRE, customParameters) );					onMultipleDirectionsProjectileWeaponFired.dispatch( weaponDisplayObject, shootToUp, shootToRight, shootToDown, shootToLeft, 0 );				}							/** handlePathWeaponMovedToNextPoint			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				protected function handlePathWeaponMovedToNextPoint( weaponDisplayObject:WeaponDisplayObject ):void				{					//var customParameters:Object = event.customParameters == null ? new Object() : event.customParameters;						//customParameters.weaponDisplayObject = event.currentTarget as WeaponDisplayObject;										//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING, customParameters) );					onPathWeaponMovedToNextPoint.dispatch( weaponDisplayObject );				}							/** handlePathWeaponMovedToNextTile			  *	---------------------------------------------------------------------------- *			  *	When a PathWeaponDisplayObject moves to a different tile, move the clip to			  *	a different layer for the depth change.			  *	---------------------------------------------------------------------------- */				protected function handlePathWeaponMovedToNextTile( weaponDisplayObject:WeaponDisplayObject, tile:GameboardTile ):void				{					//ConsoleBroadcaster.broadcast( "WeaponDisplayObjectController", "handleFullLaneWeaponMovingToNextTile();" );					_gameboardReference.displayLayerClip.moveClipToLayer( weaponDisplayObject.contentClip, tile.layerNumber );				}							/** handlePathWeaponPathEnded			  *	---------------------------------------------------------------------------- *			  *	Dispatched when a PathWeaponDisplayObject reaches the end of its path.			  *	---------------------------------------------------------------------------- */				protected function handlePathWeaponPathEnded( weaponDisplayObject:WeaponDisplayObject ):void				{					//dispatchEvent( new GameLevelEvent(GameLevelEvent.PATH_END, {weaponDisplayObject:event.currentTarget as WeaponDisplayObject}) );					onPathWeaponPathEnded.dispatch( weaponDisplayObject );										//removeWeapon( event.currentTarget as WeaponDisplayObject );				}							/** handleMultipleWeaponsWeaponFired			  *	---------------------------------------------------------------------------- *			  *	Dispatched when a MultipleWeaponsWeapon fires.			  *	---------------------------------------------------------------------------- */				protected function handleMultipleWeaponsWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootTo:Point, altitude:Number ):void				{					//var customParameters:Object = event.customParameters;						//customParameters.weaponDisplayObject = event.currentTarget as MultipleWeaponsWeaponDisplayObject;										//dispatchEvent( new GameLevelEvent(GameLevelEvent.MULTIPLE_WEAPONS_FIRE, customParameters) );					onMultipleWeaponsWeaponFired.dispatch( weaponDisplayObject, shootTo, 0 );				}						}	}