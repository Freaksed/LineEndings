/** ProjectileDisplayObjectController  *	---------------------------------------------------------------------------- *  *	@desc:  *		Thils class controls all the chickens that are currently on the board,  *		active or non active.  *	  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */	package com.boogabooga.controller.gamelevel	{		import flash.display.MovieClip;		import flash.events.*;		import flash.errors.*;		import flash.geom.Point;		import flash.utils.getQualifiedClassName;		import flash.utils.getDefinitionByName;		import flash.utils.Timer;				import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.sound.SoundEffectPlayer;		import com.avatarlabs.utils.timers.CustomTimer;		import org.osflash.signals.Signal;				import com.boogabooga.controller.gamelevel.DisplayObjectController;		import com.boogabooga.data.SoundData;		import com.boogabooga.data.SoundsIndex;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.GameLevelDataIndex;		import com.boogabooga.data.gamelevel.Projectile;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.Gameboard;		import com.boogabooga.ui.gamelevel.enemies.*;		import com.boogabooga.ui.gamelevel.projectiles.*;		import com.boogabooga.ui.gamelevel.weapons.*;		import com.boogabooga.utils.GameLevelUtil;				public class ProjectileDisplayObjectController extends DisplayObjectController		{			//protected var _projectileDisplayObjects:Array;			protected var _projectileDisplayObjects:Vector.<ProjectileDisplayObject>;			protected var _projectileDisplayObjectsLength:int;			protected var _unusedProjectileDisplayObjects:Vector.<ProjectileDisplayObject>;			protected var _unusedProjectileDisplayObjectsLength:int;						protected var _gameboardController:GameboardController;			protected var _enemyDisplayObjectController:EnemyDisplayObjectController;			protected var _weaponDisplayObjectController:WeaponDisplayObjectController;			protected var _gateDisplayObjectController:GateDisplayObjectController;						public var onCatapultAmmoHit:Signal;						/** Constructor			  *	---------------------------------------------------------------------------- */			 	public function ProjectileDisplayObjectController()				{					init();				}								public function set gameboardController( gc:GameboardController ):void { _gameboardController = gc; }				public function set enemyDisplayObjectController( e:EnemyDisplayObjectController ):void { _enemyDisplayObjectController = e; }				public function set weaponDisplayObjectController( w:WeaponDisplayObjectController ):void { _weaponDisplayObjectController = w; }				public function set gateDisplayObjectController( g:GateDisplayObjectController ):void { _gateDisplayObjectController = g; }								public function get unusedProjectileDisplayObjects():Vector.<ProjectileDisplayObject> { return _unusedProjectileDisplayObjects; }				public function set unusedProjectileDisplayObjectsLength( i:int ):void { _unusedProjectileDisplayObjectsLength = i; }				public function get unusedProjectileDisplayObjectsLength():int { return _unusedProjectileDisplayObjectsLength; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_debug = false;					//_projectileDisplayObjects = new Array();					_projectileDisplayObjects = new Vector.<ProjectileDisplayObject>;					_projectileDisplayObjectsLength = 0;					_unusedProjectileDisplayObjects = new Vector.<ProjectileDisplayObject>;					_unusedProjectileDisplayObjectsLength = 0;										onCatapultAmmoHit = new Signal( ProjectileDisplayObject, Number );				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "ProjectileDisplayObjectController", "pause();" );										for( var i:uint=0; i<_projectileDisplayObjectsLength; ++i )					{						_projectileDisplayObjects[i].pause();					}				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "ProjectileDisplayObjectController", "unpause();" );										for( var i:uint=0; i<_projectileDisplayObjectsLength; ++i )					{						_projectileDisplayObjects[i].unpause();					}				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					/*					for( var i:uint=0; i<_chickenDisplayObjects.length; ++i )					{						_chickenDisplayObjects[i].removeEventListener( "onClick", handleChickenDisplayObjectClicked );						_chickenDisplayObjects[i].removeEventListener( "onDurationEnd", handleChickenDisplayObjectDurationEnded );						ChickenDisplayObject(_chickenDisplayObjects[i]).kill();						_chickenDisplayObjects[i] = null;					}					*/										while( _projectileDisplayObjects.length > 0 )						removeProjectile( _projectileDisplayObjects[0] );										_gameboardController = null;										onCatapultAmmoHit = null;										var projectileDisplayObject:ProjectileDisplayObject;					while( _unusedProjectileDisplayObjects.length > 0 )					{						projectileDisplayObject = VectorUtil.remove( _unusedProjectileDisplayObjects, _unusedProjectileDisplayObjects[0] );						projectileDisplayObject.kill();						projectileDisplayObject = null;					}										//trace( "_unusedProjectileDisplayObjects.length: "+_unusedProjectileDisplayObjects.length );										_projectileDisplayObjects = null;					_unusedProjectileDisplayObjects = null;										super.kill();				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				public function updateOnEnterFrame():void				{					for( var i:int=0; i<_projectileDisplayObjectsLength; ++i )					{						_projectileDisplayObjects[i].updateOnEnterFrame();					}				}							/** addProjectile			  *	---------------------------------------------------------------------------- *			  *	Adds projectile to the game. Adds it to the array			  *	---------------------------------------------------------------------------- */				public function addProjectile( displayObject:ProjectileDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "ProjectileDisplayObjectController", "addProjectile();" );										//displayObject.addEventListener( GameLevelEvent.MOVING, handleProjectileMoving, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.REMOVE_FROM_GAME, handleProjectileRemovedFromGame, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.CATAPULT_AMMO_HIT, handleCatapultAmmoHit, false, 0, true );					displayObject.onMoved.add( handleProjectileMoved );					displayObject.onRemovedFromGame.add( handleProjectileRemovedFromGame );										if( displayObject is CatapultDisplayObject )						CatapultDisplayObject(displayObject).onAmmoHit.add( handleCatapultAmmoHit );										displayObject.render();										_gameboardReference.projectileClipsContainer_mc.addChild( displayObject.contentClip );										_projectileDisplayObjects.push( displayObject );					_projectileDisplayObjectsLength = _projectileDisplayObjects.length;										//trace( "_projectileDisplayObjects.length: "+_projectileDisplayObjects.length );										displayObject.startMoving();				}							/** removeProjectile			  *	---------------------------------------------------------------------------- *			  *	Removes projectile from the game. Removes listeners from projectile, kill it			  *	and removes it from the list of the projectiles.			  *	---------------------------------------------------------------------------- */				public function removeProjectile( displayObject:ProjectileDisplayObject ):void				{					var projectileDisplayObject:ProjectileDisplayObject = VectorUtil.remove( _projectileDisplayObjects, displayObject );					if( projectileDisplayObject != null )					{						//projectileDisplayObject.removeEventListener( GameLevelEvent.MOVING, handleProjectileMoving );						//projectileDisplayObject.removeEventListener( GameLevelEvent.REMOVE_FROM_GAME, handleProjectileRemovedFromGame );						//projectileDisplayObject.removeEventListener( GameLevelEvent.CATAPULT_AMMO_HIT, handleCatapultAmmoHit );						projectileDisplayObject.onMoved.remove( handleProjectileMoved );						projectileDisplayObject.onRemovedFromGame.remove( handleProjectileRemovedFromGame );												if( projectileDisplayObject is CatapultDisplayObject )							CatapultDisplayObject(projectileDisplayObject).onAmmoHit.remove( handleCatapultAmmoHit );						MovieClip(projectileDisplayObject.contentClip.parent).removeChild( projectileDisplayObject.contentClip );												if( projectileDisplayObject.type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							projectileDisplayObject.reset();							_unusedProjectileDisplayObjects.push( projectileDisplayObject );							_unusedProjectileDisplayObjectsLength = _unusedProjectileDisplayObjects.length;						}						else						{							projectileDisplayObject.kill();							projectileDisplayObject = null;						}					}										_projectileDisplayObjectsLength = _projectileDisplayObjects.length;									}							/** handleProjectileMoved			  *	---------------------------------------------------------------------------- */				protected function handleProjectileMoved( projectileDisplayObject:ProjectileDisplayObject ):void				{					//TODO:					//	Check if the projectile hits anything					//	Check if projectile can actually work on the enemies too.					//	Optimize this, this is NOT EFFICIENT AT ALL!!!!!!!										var i:int;					//var projectileDisplayObject:ProjectileDisplayObject = event.currentTarget as ProjectileDisplayObject;					var randomIndex:int;					var projectileHit:Boolean = false;					var distance:Number;					var altDiff:Number;										if( projectileDisplayObject.attackingGameObject is Weapon )					{						for( i=0; i<_enemyDisplayObjectController.enemyDisplayObjects.length; ++i )						{							if( (projectileDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SINGLE_LANE_INDEX) && projectileDisplayObject.pathIndex != _enemyDisplayObjectController.enemyDisplayObjects[i].pathIndex) )							{								continue;							}														if( _enemyDisplayObjectController.enemyDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FLYER_INDEX) && !projectileDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FLYER_INDEX) )							{								continue;							}														if( _enemyDisplayObjectController.enemyDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_GHOST_INDEX) && _enemyDisplayObjectController.enemyDisplayObjects[i].ghosting )							{								if( !projectileDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ENCHANTED_INDEX) )									continue;							}														distance = (projectileDisplayObject.positionIn2D.y - _enemyDisplayObjectController.enemyDisplayObjects[i].positionIn2D.y) * (projectileDisplayObject.positionIn2D.y - _enemyDisplayObjectController.enemyDisplayObjects[i].positionIn2D.y);							distance += (projectileDisplayObject.positionIn2D.x - _enemyDisplayObjectController.enemyDisplayObjects[i].positionIn2D.x) * (projectileDisplayObject.positionIn2D.x - _enemyDisplayObjectController.enemyDisplayObjects[i].positionIn2D.x);							//trace( "distance: "+distance );							if( distance >= 10000 )							{								continue;							}														altDiff = _enemyDisplayObjectController.enemyDisplayObjects[i].altitude - projectileDisplayObject.altitude;							altDiff = altDiff < 0 ? -altDiff : altDiff;														if( _enemyDisplayObjectController.enemyDisplayObjects[i].alive &&								altDiff < 50 &&								!UtilFunctions.getCollisionRect( projectileDisplayObject.hitarea_mc, _enemyDisplayObjectController.enemyDisplayObjects[i].hitarea_mc, _gameboardReference ).isEmpty() )							//if( !projectileDisplayObject.getCollisionRect( projectileDisplayObject.hitarea_mc, _enemyDisplayObjectController.enemyDisplayObjects[i].hitarea_mc, _gameboardReference ).isEmpty() )							{								//trace( "HIT" );								//_enemyDisplayObjectController.enemyDisplayObjects[i].hit( projectileDisplayObject.attackingGameObject, projectileDisplayObject.attackingGameObject.power );																if( projectileDisplayObject is CatapultDisplayObject )								{									//trace( "catapult ammo hits" );																		//NOTE:									//	Dispatch this event so GameboardController can take care of displaying particle effects on the board.									var range:Number = 90+(projectileDisplayObject.attackingGameObject.projectileEffectRange-1)*90;									//dispatchEvent( new GameLevelEvent(GameLevelEvent.CATAPULT_AMMO_HIT, {projectileDisplayObject:projectileDisplayObject, range:range}) );									onCatapultAmmoHit.dispatch( projectileDisplayObject, range );									_enemyDisplayObjectController.attackEnemiesInARange( projectileDisplayObject.positionIn2D, range, projectileDisplayObject, projectileDisplayObject.attackingGameObject.power );								}								else								{									//trace( "projectile ammo hits" );																		_enemyDisplayObjectController.enemyDisplayObjects[i].hit( projectileDisplayObject.attackingGameObject, projectileDisplayObject.attackingGameObject.power );								}																if( projectileDisplayObject.attackingGameObject.hitSoundDataIds.length > 0 )								{									randomIndex = int( Math.random()*projectileDisplayObject.attackingGameObject.hitSoundDataIds.length );									//trace( "play sound "+projectileDisplayObject.attackingGameObject.hitSoundDataIds[randomIndex] );									var soundData:SoundData = SoundsIndex.getInstance().getSoundById(projectileDisplayObject.attackingGameObject.hitSoundDataIds[randomIndex]);									SoundEffectPlayer.getInstance().playLibrarySound( soundData.soundId, false, projectileDisplayObject.contentClip.name, soundData.soundId );									soundData = null;								}								projectileDisplayObject.die();								break;							}						}					}					else if( projectileDisplayObject.attackingGameObject is Enemy )					{						for( i=0; i<_weaponDisplayObjectController.weaponDisplayObjects.length; ++i )						{							//trace( "_weaponDisplayObjectController.weaponDisplayObjects[i].ignoredByEnemy: "+_weaponDisplayObjectController.weaponDisplayObjects[i].ignoredByEnemy );							//trace( "_weaponDisplayObjectController.weaponDisplayObjects[i].alive: "+_weaponDisplayObjectController.weaponDisplayObjects[i].alive );							//trace( "collisionREct.isEmpty(): "+projectileDisplayObject.getCollisionRect( projectileDisplayObject.hitarea_mc, _weaponDisplayObjectController.weaponDisplayObjects[i].hitarea_mc, _gameboardReference ).isEmpty() );							//trace( "projectileDisplayObject.attackingGameObject.attackingGameObject: "+projectileDisplayObject.attackingGameObject.attackingGameObject );							//trace( "projectileDisplayObject.attackingGameObject.attackingGameObject.power: "+projectileDisplayObject.attackingGameObject.attackingGameObject.power );														if( (projectileDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SINGLE_LANE_INDEX) && projectileDisplayObject.pathIndex != _weaponDisplayObjectController.weaponDisplayObjects[i].pathIndex) )							{								continue;							}														distance = (projectileDisplayObject.positionIn2D.y - _weaponDisplayObjectController.weaponDisplayObjects[i].positionIn2D.y) * (projectileDisplayObject.positionIn2D.y - _weaponDisplayObjectController.weaponDisplayObjects[i].positionIn2D.y);							distance += (projectileDisplayObject.positionIn2D.x - _weaponDisplayObjectController.weaponDisplayObjects[i].positionIn2D.x) * (projectileDisplayObject.positionIn2D.x - _weaponDisplayObjectController.weaponDisplayObjects[i].positionIn2D.x);							//trace( "distance: "+distance );							if( distance >= 10000 )							{								continue;							}														altDiff = _weaponDisplayObjectController.weaponDisplayObjects[i].altitude - projectileDisplayObject.altitude;							altDiff = altDiff < 0 ? -altDiff : altDiff;														if( !_weaponDisplayObjectController.weaponDisplayObjects[i].ignoredByEnemy && 								_weaponDisplayObjectController.weaponDisplayObjects[i].alive &&								altDiff < 50 &&								!UtilFunctions.getCollisionRect( projectileDisplayObject.hitarea_mc, _weaponDisplayObjectController.weaponDisplayObjects[i].hitarea_mc, _gameboardReference ).isEmpty() )							{								_weaponDisplayObjectController.weaponDisplayObjects[i].hit( projectileDisplayObject.attackingGameObject, projectileDisplayObject.attackingGameObject.power );								/*								if( projectileDisplayObject is CatapultDisplayObject )								{																	}								else								{																	}								*/																if( projectileDisplayObject.attackingGameObject.hitSoundDataIds.length > 0 )								{									randomIndex = int( Math.random()*projectileDisplayObject.attackingGameObject.hitSoundDataIds.length );									//trace( "play sound "+projectileDisplayObject.attackingGameObject.hitSoundDataIds[randomIndex] );									var soundData:SoundData = SoundsIndex.getInstance().getSoundById(projectileDisplayObject.attackingGameObject.hitSoundDataIds[randomIndex]);									SoundEffectPlayer.getInstance().playLibrarySound( soundData.soundId, false, projectileDisplayObject.contentClip.name, soundData.soundId );									soundData = null;								}								projectileDisplayObject.die();								break;							}						}												if( projectileDisplayObject.alive )						{							//trace( "checking against the gate" );														for( i=0; i<_gateDisplayObjectController.gateDisplayObjects.length; ++i )							{								if( _gateDisplayObjectController.gateDisplayObjects[i].isInPath )								{									distance = (projectileDisplayObject.positionIn2D.y - _gateDisplayObjectController.gateDisplayObjects[i].positionIn2D.y) * (projectileDisplayObject.positionIn2D.y - _gateDisplayObjectController.gateDisplayObjects[i].positionIn2D.y);									distance += (projectileDisplayObject.positionIn2D.x - _gateDisplayObjectController.gateDisplayObjects[i].positionIn2D.x) * (projectileDisplayObject.positionIn2D.x - _gateDisplayObjectController.gateDisplayObjects[i].positionIn2D.x);									//trace( "distance: "+distance );									if( distance >= 10000 )									{										continue;									}																		altDiff = _gateDisplayObjectController.gateDisplayObjects[i].altitude - projectileDisplayObject.altitude;									altDiff = altDiff < 0 ? -altDiff : altDiff;																		//trace( "altDiff: "+altDiff );									//trace( "hit rect: "+UtilFunctions.getCollisionRect( projectileDisplayObject.hitarea_mc, _gateDisplayObjectController.gateDisplayObjects[i].hitarea_mc, _gameboardReference ).isEmpty() );																		if( _gateDisplayObjectController.gateDisplayObjects[i].alive && 										altDiff < 50 &&									   !UtilFunctions.getCollisionRect( projectileDisplayObject.hitarea_mc, _gateDisplayObjectController.gateDisplayObjects[i].hitarea_mc, _gameboardReference ).isEmpty() )									{										_gateDisplayObjectController.gateDisplayObjects[i].hit( projectileDisplayObject.attackingGameObject, projectileDisplayObject.attackingGameObject.power );										if( projectileDisplayObject.attackingGameObject.hitSoundDataIds.length > 0 )										{											randomIndex = int( Math.random()*projectileDisplayObject.attackingGameObject.hitSoundDataIds.length );											//trace( "play sound "+projectileDisplayObject.attackingGameObject.hitSoundDataIds[randomIndex] );											var soundData:SoundData = SoundsIndex.getInstance().getSoundById(projectileDisplayObject.attackingGameObject.hitSoundDataIds[randomIndex]);											SoundEffectPlayer.getInstance().playLibrarySound( soundData.soundId, false, projectileDisplayObject.contentClip.name, soundData.soundId );											soundData = null;										}										projectileDisplayObject.die();										break;									}								}							}						}					}										if( projectileDisplayObject.alive && projectileDisplayObject.type == ProjectileDisplayObject.TYPE_PROJECTILE && 						(projectileDisplayObject.positionIn2D.x < GameLevelDataIndex.getInstance().gameTilesBounds.left || projectileDisplayObject.positionIn2D.x > GameLevelDataIndex.getInstance().gameTilesBounds.right ||							projectileDisplayObject.positionIn2D.y < GameLevelDataIndex.getInstance().gameTilesBounds.top-100 || projectileDisplayObject.positionIn2D.y > GameLevelDataIndex.getInstance().gameTilesBounds.bottom) )					{						//trace( projectileDisplayObject.attackingGameObject.hitSoundDataIds );						//trace( "projectile is out of bounds" );						projectileDisplayObject.dieFromOutOfBounds();					}					/*					else if( projectileDisplayObject.altitude > 30 )					{						projectileDisplayObject.dieFromOutOfBounds();					}					*/				}							/** handleProjectileStopMoving			  *	---------------------------------------------------------------------------- 				protected function handleProjectileStopsMoving( event:CustomEvent ):void				{									}*/							/** handleProjectileStopMoving			  *	---------------------------------------------------------------------------- *			  *	Removes projectile from the game.			  *	---------------------------------------------------------------------------- */				protected function handleProjectileRemovedFromGame( projectileDisplayObject:ProjectileDisplayObject ):void				{					removeProjectile( projectileDisplayObject );				}								protected function handleCatapultAmmoHit( projectileDisplayObject:ProjectileDisplayObject ):void				{					//var projectileDisplayObject:ProjectileDisplayObject = event.currentTarget as ProjectileDisplayObject;					//dispatchEvent( new GameLevelEvent(GameLevelEvent.CATAPULT_AMMO_HIT, {projectileDisplayObject:projectileDisplayObject, range:90+(projectileDisplayObject.attackingGameObject.projectileEffectRange-1)*90}) );					onCatapultAmmoHit.dispatch( projectileDisplayObject, 90+(projectileDisplayObject.attackingGameObject.projectileEffectRange-1)*90 );				}						}	}