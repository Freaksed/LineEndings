/** GodDisplayObjectController  *	---------------------------------------------------------------------------- *  *	@desc:  *		Thils class controls all the enemies that are currently on the board,  *		active or non active.  *	  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */	package com.boogabooga.controller.gamelevel	{		import flash.display.MovieClip;		import flash.events.*;		import flash.errors.*;		import flash.geom.Point;		import flash.utils.getQualifiedClassName;		import flash.utils.getDefinitionByName;		import flash.utils.Timer;				import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.UtilFunctions;		import org.osflash.signals.Signal;				import com.boogabooga.controller.gamelevel.DisplayObjectController;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.Gameboard;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.GodDisplayObject;		import com.boogabooga.utils.GameLevelUtil;				public class GodDisplayObjectController extends DisplayObjectController		{			protected var _gameboardController:GameboardController;			protected var _godDisplayObjects:Vector.<GodDisplayObject>;			protected var _godDisplayObjectsLength:int;						protected var _attackPoints:Vector.<Point>;						public var onGodAttacked:Signal;			public var onGodAttackEnded:Signal;						/** Constructor			  *	---------------------------------------------------------------------------- */			 	public function GodDisplayObjectController()				{					init();				}								public function set gameboardController( gc:GameboardController ):void { _gameboardController = gc; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_debug = true;					_godDisplayObjects = new Vector.<GodDisplayObject>;					_attackPoints = new Vector.<Point>;										onGodAttacked = new Signal( GodDisplayObject );					onGodAttackEnded = new Signal( GodDisplayObject );				}							/** initAttackPoints			  *	---------------------------------------------------------------------------- *			  *	Initialize the random attack points for the attacks.			  *	---------------------------------------------------------------------------- */				public function initAttackPoints():void				{					//_attackPoints.push( _gameboardReference.tiles[0][2].positionIn2D.clone() );					_attackPoints.push( _gameboardReference.tiles[0][2].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[0][2].contentClip.x, _gameboardReference.tiles[0][2].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[0][5].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[0][5].contentClip.x, _gameboardReference.tiles[0][5].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[1][1].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[1][1].contentClip.x, _gameboardReference.tiles[1][1].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[1][4].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[1][4].contentClip.x, _gameboardReference.tiles[1][4].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[1][7].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[1][7].contentClip.x, _gameboardReference.tiles[1][7].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[2][5].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[2][5].contentClip.x, _gameboardReference.tiles[2][5].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[3][0].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[3][0].contentClip.x, _gameboardReference.tiles[3][0].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[3][6].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[3][6].contentClip.x, _gameboardReference.tiles[3][6].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[4][2].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[4][2].contentClip.x, _gameboardReference.tiles[4][2].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[4][6].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[4][6].contentClip.x, _gameboardReference.tiles[4][6].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[5][0].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[5][0].contentClip.x, _gameboardReference.tiles[5][0].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[5][2].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[5][2].contentClip.x, _gameboardReference.tiles[5][2].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[5][4].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[5][4].contentClip.x, _gameboardReference.tiles[5][4].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[6][3].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[6][3].contentClip.x, _gameboardReference.tiles[6][3].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[6][7].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[6][7].contentClip.x, _gameboardReference.tiles[6][7].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[7][2].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[7][2].contentClip.x, _gameboardReference.tiles[7][2].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[7][5].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[7][5].contentClip.x, _gameboardReference.tiles[7][5].contentClip.y)) );					_attackPoints.push( _gameboardReference.tiles[7][7].contentClip.parent.localToGlobal(new Point(_gameboardReference.tiles[7][7].contentClip.x, _gameboardReference.tiles[7][7].contentClip.y)) );				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GodDisplayObjectController", "pause();" );										for( var i:uint=0; i<_godDisplayObjectsLength; ++i )					{						_godDisplayObjects[i].pause();					}				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GodDisplayObjectController", "unpause();" );										for( var i:uint=0; i<_godDisplayObjectsLength; ++i )					{						_godDisplayObjects[i].unpause();					}				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GodDisplayObjectController", "kill();" );										while( _godDisplayObjects.length > 0 )						removeGod( _godDisplayObjects[0] );										_godDisplayObjects = null;					_gameboardController =  null;										onGodAttacked = null;					onGodAttackEnded = null;										super.kill();				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				public function updateOnEnterFrame():void				{					for( var i:int=0; i<_godDisplayObjectsLength; ++i )					{						_godDisplayObjects[i].updateOnEnterFrame();					}				}							/** addGod			  *	---------------------------------------------------------------------------- *			  *	Adds god display object to stage, add all the required event listeners.			  *	---------------------------------------------------------------------------- */				public function addGod( displayObject:GodDisplayObject ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "GodDisplayObjectController", "addGod("+displayObject+");" );										//displayObject.addEventListener( GameLevelEvent.ON_GOD_SUMMONED, handleSummonStarts, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.ON_GOD_INIT_ATTACK, handleInitAttack, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.ON_GOD_ATTACK_ENDED, handleAttackEnded, false, 0, true );					//displayObject.addEventListener( GameLevelEvent.ON_GOD_ATTACK, handleAttack, false, 0, true );					displayObject.onSummoned.add( handleSummoned );					displayObject.onAttackInit.add( handleAttackInit );					displayObject.onAttackEnded.add( handleAttackEnded );					displayObject.onAttacked.add( handleAttacked );										_godDisplayObjects.push( displayObject );					_godDisplayObjectsLength = _godDisplayObjects.length;					//_gameboardReference.displayLayerClip.moveClipToLayer( displayObject.contentClip, displayObject.currentTile.layerNumber );					//_gameboardReference.effectClipsContainer_mc.addChild( displayObject.contentClip );										var localPosition:Point = UtilFunctions.localToLocal( displayObject.currentTile.contentClip, _gameboardReference.effectClipsContainer_mc );					//var globalPosition:Point = displayObject.currentTile.contentClip.parent.localToGlobal										displayObject.contentClip.x = localPosition.x;					displayObject.contentClip.y = localPosition.y;					_gameboardReference.effectClipsContainer_mc.addChild( displayObject.contentClip );															//trace( "localPosition: "+localPosition );					//trace( "localPosition by tile: "+UtilFunctions.localToLocal( displayObject.currentTile.contentClip, _gameboardReference.effectClipsContainer_mc ));										//displayObject.render();					displayObject.startSummoning();				}							/** removeGod			  *	---------------------------------------------------------------------------- *			  *	Removes god display object from stage, remove all the listeners, etc.			  *	---------------------------------------------------------------------------- */				public function removeGod( displayObject:GodDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GodDisplayObjectController", "removeGod("+displayObject+");" );										var godDisplayObject:GodDisplayObject = VectorUtil.remove( _godDisplayObjects, displayObject );					_godDisplayObjectsLength = _godDisplayObjects.length;										if( godDisplayObject != null )					{						//godDisplayObject.removeEventListener( GameLevelEvent.ON_GOD_SUMMONED, handleSummonStarts );						//godDisplayObject.removeEventListener( GameLevelEvent.ON_GOD_INIT_ATTACK, handleInitAttack );						//godDisplayObject.removeEventListener( GameLevelEvent.ON_GOD_ATTACK, handleAttack );						//godDisplayObject.removeEventListener( GameLevelEvent.ON_GOD_ATTACK_ENDED, handleAttackEnded );						godDisplayObject.onSummoned.remove( handleSummoned );						godDisplayObject.onAttackInit.remove( handleAttackInit );						godDisplayObject.onAttackEnded.remove( handleAttackEnded );						godDisplayObject.onAttacked.remove( handleAttacked );						godDisplayObject.contentClip.parent.removeChild( godDisplayObject.contentClip );						godDisplayObject.kill();						godDisplayObject = null;					}				}				/*				protected function handleSummoningAnimationEnds( event:CustomEvent ):void				{					GodDisplayObject(event.currentTarget).startAttackingAnimation();				}				*/							/** handleSummoned			  *	---------------------------------------------------------------------------- *			  *	This event is fired when the summoning animation starts.			  *	---------------------------------------------------------------------------- */				//protected function handleSummonStarts( event:GameLevelEvent ):void				protected function handleSummoned():void				{					/*					var globalPosition:Point = (event.currentTarget as GodDisplayObject).contentClip.parent.localToGlobal( new Point(event.currentTarget.contentClip.x, event.currentTarget.contentClip.y) );										var localPosition:Point = _gameboardReference.effectClipsContainer_mc.globalToLocal( globalPosition );										event.currentTarget.contentClip.x = localPosition.x;					event.currentTarget.contentClip.y = localPosition.y;										_gameboardReference.effectClipsContainer_mc.addChild( event.currentTarget.contentClip );					*/					_gameboardController.pauseForGodAttack();				}				/*				protected function handleSummonEnds( event:CustomEvent ):void				{					//_gameboardController.unpauseForGodAttack();									}				*/			/** handleAttackInit			  *	---------------------------------------------------------------------------- *			  *	Init the god object and to start attacking.			  *	---------------------------------------------------------------------------- */				//protected function handleInitAttack( event:GameLevelEvent ):void				protected function handleAttackInit( godDisplayObject:GodDisplayObject ):void				{					//_gameboardReference.godAttackAnimation_mc.addChild( event.customParameters.attackAnimation );										//GodDisplayObject(event.currentTarget).startAttacking();										if( godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_TRICKSTER_INDEX) )					{						//_isTricksterGodInPlay = true;						_gameboardController.setTricksterGodInPlay( godDisplayObject.god.additionalAttackValue*1000 );												EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {gameLevelDisplayObject:godDisplayObject, particleId:godDisplayObject.god.attackParticleAnimationObjectId, globalPosition:_attackPoints[4]} );						EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {gameLevelDisplayObject:godDisplayObject, particleId:godDisplayObject.god.attackParticleAnimationObjectId, globalPosition:_attackPoints[10]} );						EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {gameLevelDisplayObject:godDisplayObject, particleId:godDisplayObject.god.attackParticleAnimationObjectId, globalPosition:_attackPoints[14]} );					}					else if( godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_WARRIOR_INDEX) )					{						_gameboardController.setWarriorGodInPlay( godDisplayObject.god.additionalAttackValue*1000 );					}					else if( godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_WIND_INDEX) )					{						_gameboardController.setWindGoddessInPlay();					}					else if( godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ONE_HIT_KILL_INDEX) )					{						_gameboardController.setDeathGodInPlay();					}										_gameboardController.unpauseForGodAttack();					_gameboardController.startShakingGameboardForGod();				}							/** handleAttack			  *	---------------------------------------------------------------------------- *			  *	Attack all the enemies when the attack animation is happening.			  *	Enemies can only be attacked once per attack though.			  *	---------------------------------------------------------------------------- */				//protected function handleAttack( event:GameLevelEvent ):void				protected function handleAttacked( godDisplayObject:GodDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GodDisplayObjectController", "handleAttack();" );										//var randomPosition:Point = new Point();						//randomPosition.x = _gameboardReference.bound.x + _gameboardReference.bound.width/2 + Math.random()*_gameboardReference.bound.width/2 - Math.random()*_gameboardReference.bound.width/2;						//randomPosition.y = _gameboardReference.bound.y + _gameboardReference.bound.height/2 + Math.random()*_gameboardReference.bound.height/2 - Math.random()*_gameboardReference.bound.height/2;						//randomPosition.x = _gameboardReference.bound.x+_gameboardReference.bound.width;						//randomPosition.y = _gameboardReference.bound.y+_gameboardReference.bound.height;										//trace( "randomPosition: "+GameLevelUtil.getIsometricPosition(randomPosition) );					//trace( "_gameboardReference.bound: "+_gameboardReference.bound );										//var globalPosition:Point = (event.currentTarget as GodDisplayObject).contentClip.parent.localToGlobal( GameLevelUtil.getPositionInIsometric(_attackPoints[int(Math.random()*_attackPoints.length)]) );					//var globalPosition:Point = _gameboardRefer										//trace( "globalPosition: "+globalPosition );										if( !godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_TRICKSTER_INDEX) && !godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_WARRIOR_INDEX) && !godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ONE_HIT_KILL_INDEX) )					{						if( godDisplayObject.god.attackParticleAnimationObjectId != 0 )							EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {gameLevelDisplayObject:godDisplayObject, particleId:godDisplayObject.god.attackParticleAnimationObjectId, globalPosition:_attackPoints[int(Math.random()*_attackPoints.length)]} );						else							EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {gameLevelDisplayObject:godDisplayObject, particleCacheId:"Explosion", globalPosition:_attackPoints[int(Math.random()*_attackPoints.length)]} );					}										//dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_GOD_ATTACK, {godDisplayObject:godDisplayObject}) );					onGodAttacked.dispatch( godDisplayObject );				}							/** handleAttackEnded			  *	---------------------------------------------------------------------------- *			  *	Attack the enemy for one last time, and stops the attack.			  *	---------------------------------------------------------------------------- */				//protected function handleAttackEnded( event:GameLevelEvent ):void				protected function handleAttackEnded( godDisplayObject:GodDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GodDisplayObjectController", "handleAttackEnded();" );										//GodDisplayObject(event.currentTarget)					//dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_GOD_ATTACK_ENDED, {godDisplayObject:event.currentTarget as GodDisplayObject}) );					onGodAttackEnded.dispatch( godDisplayObject );										//removeGod( event.currentTarget as GodDisplayObject );				}		}	}