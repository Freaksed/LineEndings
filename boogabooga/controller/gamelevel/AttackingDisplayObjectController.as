/** AttackingDisplayObjectController  *	---------------------------------------------------------------------------- *  *	@desc:  *		Thils class controls all the chickens that are currently on the board,  *		active or non active.  *	  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */	package com.boogabooga.controller.gamelevel	{		import flash.display.MovieClip;		import flash.events.*;		import flash.errors.*;		import flash.geom.Point;		import flash.utils.getQualifiedClassName;		import flash.utils.getDefinitionByName;		import flash.utils.Timer;				import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.cache.HashTable;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.timers.CustomTimer;				import com.boogabooga.controller.gamelevel.DisplayObjectController;		import com.boogabooga.data.gamelevel.AttackingTileTracker;		import com.boogabooga.data.gamelevel.AttackingDisplayObjectTracker;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.ui.gamelevel.Gameboard;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.GameLevelAttackingDisplayObject;		import com.boogabooga.ui.gamelevel.GateDisplayObject;		import com.boogabooga.ui.gamelevel.enemies.*;		import com.boogabooga.ui.gamelevel.weapons.*;		import com.boogabooga.utils.GameLevelUtil;		import com.boogabooga.data.gamelevel.AbstractGameObject;				public class AttackingDisplayObjectController extends DisplayObjectController		{			protected var _weaponTrackers:Vector.<AttackingDisplayObjectTracker>;			protected var _weaponTrackersLength:int;			protected var _gateTrackers:Vector.<AttackingDisplayObjectTracker>;			protected var _gateTrackersLength:int;			//protected var _enemyTrackers:Array;			protected var _enemyTrackers:Vector.<AttackingDisplayObjectTracker>;			protected var _enemyTrackersLength:int;			//protected var _tileTrackers:Array;			protected var _tileTrackers:Vector.<AttackingTileTracker>;			protected var _tileTrackersLength:int;			protected var _paths:Vector.<Vector.<GameboardTile>>;						/** Constructor			  *	---------------------------------------------------------------------------- */			 	public function AttackingDisplayObjectController()				{					init();				}								public function get paths():Vector.<Vector.<GameboardTile>> { return _paths; }				public function get tileTrackers():Vector.<AttackingTileTracker> { return _tileTrackers; }				public function get weaponTrackers():Vector.<AttackingDisplayObjectTracker> { return _weaponTrackers; }				public function get enemyTrackers():Vector.<AttackingDisplayObjectTracker> { return _enemyTrackers; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_debug = true;										//_tileTrackers = new Array();					_tileTrackers = new Vector.<AttackingTileTracker>;					_tileTrackersLength = 0;					//_weaponTrackers = new Array();					_weaponTrackers = new Vector.<AttackingDisplayObjectTracker>;					_weaponTrackersLength = 0;					_gateTrackers = new Vector.<AttackingDisplayObjectTracker>;					_gateTrackersLength = 0;					//_enemyTrackers = new Array();					_enemyTrackers = new Vector.<AttackingDisplayObjectTracker>;					_enemyTrackersLength = 0;					_paths = new Vector.<Vector.<GameboardTile>>;									}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "pause();" );									}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "unpause();" );									}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "kill();" );										//TODO:					//	Kill all the trackers and the paths here										var i:uint;										for( i=0; i<_tileTrackers.length; ++i )					{						_tileTrackers[i].kill();					}					VectorUtil.removeAll( _tileTrackers );					_tileTrackers = null;					_tileTrackersLength = 0;										for( i=0; i<_weaponTrackers.length; ++i )					{						_weaponTrackers[i].kill();					}					VectorUtil.removeAll( _weaponTrackers );					_weaponTrackers = null;					_weaponTrackersLength = 0;															for( i=0; i<_enemyTrackers.length; ++i )					{						_enemyTrackers[i].kill();					}					VectorUtil.removeAll( _enemyTrackers );					_enemyTrackers = null;					_enemyTrackersLength = 0;										VectorUtil.removeAll( _paths );					_paths = null;										super.kill();				}							/** addTile			  *	---------------------------------------------------------------------------- */				public function addTile( tile:GameboardTile ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "addTile();" );										//trace( "tile: "+tile );					//trace( "tile.id: "+tile.id );										var tileTracker:AttackingTileTracker = new AttackingTileTracker();						tileTracker.tile = tile;						tileTracker.id = tile.id;						//tileTracker.weaponsWatching = new Array();						//tileTracker.enemiesWatching = new Array();										_tileTrackers.push( tileTracker );					_tileTrackersLength = _tileTrackers.length;										//trace( "_tileTrackers: "+_tileTrackers );				}							/** addPaths			  *	---------------------------------------------------------------------------- */				public function addPaths( paths:Vector.<Vector.<GameboardTile>> ):void				{					var i:uint, j:uint;										_paths = paths;										for( i=0; i<paths.length; ++i )					{						for( j=0; j<paths[i].length; ++j )						{							addTile( paths[i][j] );							paths[i][j].editable = true;							paths[i][j].tileType = GameboardTile.TILE_TYPE_PATH;							paths[i][j].showTileClip( GameboardTile(paths[i][j]).tileTypeIndex );							paths[i][j].editable = false;						}					}				}							/** addGate			  *	---------------------------------------------------------------------------- */				public function addGate( gateDO:GateDisplayObject ):void				{					var tileTracker:AttackingTileTracker = VectorUtil.find( _tileTrackers, gateDO.currentTile, "id" );					if( tileTracker != null )					{						tileTracker.addObjectOnTile( gateDO );						tileTracker = null;					}										var gateTracker:AttackingDisplayObjectTracker = new AttackingDisplayObjectTracker();						gateTracker.attackingDisplayObject = gateDO;										_gateTrackers.push( gateTracker );					_gateTrackersLength = _gateTrackers.length;										gateTracker = null;				}							/** removeGate			  *	---------------------------------------------------------------------------- */				public function removeGate( gateDO:GateDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "removeGate("+gateDO+");" );										var tileTracker:AttackingTileTracker = VectorUtil.find( _tileTrackers, gateDO.currentTile, "id" );					if( tileTracker != null )					{						tileTracker.removeObjectOnTile( gateDO );						tileTracker = null;					}										for( var i:int=0; i<_gateTrackersLength; ++i )					{						if( _gateTrackers[i].attackingDisplayObject == gateDO )						{							_gateTrackers[i] = null;							_gateTrackers.splice( i, 1 );							_gateTrackersLength = _gateTrackers.length;														break;						}					}				}							/** addWeapon			  *	---------------------------------------------------------------------------- */				public function addWeapon( weaponDO:GameLevelAttackingDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "addWeapon("+weaponDO+");" );										var weaponTracker:AttackingDisplayObjectTracker = new AttackingDisplayObjectTracker();						weaponTracker.attackingDisplayObject = weaponDO;										//var tiles:Vector.<GameboardTile> = getTilesInAttackRange( weaponDO );					var tiles:Vector.<GameboardTile> = getTilesInAttackRangeForGameObject(weaponDO.attackingGameObject, weaponDO.currentTile, weaponDO.direction);					var tilesLength = tiles.length;					var i:int, j:int;					var tileTracker:AttackingTileTracker;					var targetAttacked:GameLevelAttackingDisplayObject;										if( weaponDO.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_CATAPULT_INDEX) )					{						tiles.reverse();					}										//trace( "tiles in attack range "+tiles );										tileTracker = VectorUtil.find( _tileTrackers, weaponDO.currentTile, "id" )					if( tileTracker != null )					{						tileTracker.addObjectOnTile( weaponDO );						tileTracker = null;					}										for( i=tilesLength-1; i>=0; --i )					{						tileTracker = VectorUtil.find( _tileTrackers, tiles[i], "id" );												//TODO:						//	Need to attack all targets in the range instead of all targets in the first tile it's watching						if( tileTracker != null )						{							tileTracker.addWeaponWatching( weaponDO );							weaponTracker.addTileWatching( tiles[i] );														//weaponDO.attackTargets( tileTracker.enemiesOnTile );							tileTracker = null;						}					}										//targetAttacked = weaponDO.attackTargets( getTargetsInAttackRange(weaponDO) );										_weaponTrackers.push( weaponTracker );					_weaponTrackersLength = _weaponTrackers.length;										weaponTracker = null;										checkForTargets( weaponDO );										//outputTileTrackers();					//outputWeaponTrackers();															//TODO:					//	Check if there are any enemies within the range of the weapon					//	Check if there are any enemies watching the tile when weapon is added				}							/** removeWeapon			  *	---------------------------------------------------------------------------- */				public function removeWeapon( weaponDO:GameLevelAttackingDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "removeWeapon("+weaponDO+");" );										var weaponIndex:uint;										for( var i:int=0; i<_weaponTrackersLength; ++i )					{						//AttackingDisplayObjectTracker(_weaponTrackers[i]).attackingDisplayObject = null;						if( _weaponTrackers[i].attackingDisplayObject == weaponDO )						{							//weaponIndex = i;														removeWeaponWatchingFromTiles( weaponDO );							_weaponTrackers[i].attackingDisplayObject = null;														//while( AttackingDisplayObjectTracker(_weaponTrackers[i]).tilesWatching.length > 0 )							//	AttackingDisplayObjectTracker(_weaponTrackers[i]).tilesWatching.pop();														_weaponTrackers[i] = null;							_weaponTrackers.splice( i, 1 );							_weaponTrackersLength = _weaponTrackers.length;														break;						}					}										var tileTracker:AttackingTileTracker = VectorUtil.find( _tileTrackers, weaponDO.currentTile, "id" );										if( tileTracker != null )					{						tileTracker.removeObjectOnTile( weaponDO );						tileTracker = null;					}										//outputTileTrackers();					//outputWeaponTrackers();				}							/** removeWeaponWatchingFromTiles			  *	---------------------------------------------------------------------------- */				protected function removeWeaponWatchingFromTiles( weaponDO:GameLevelAttackingDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "removeWeaponWatchingFromTiles("+weaponDO+");" );										for( var i:uint=0; i<_tileTrackersLength; ++i )					{						_tileTrackers[i].removeWeaponWatching( weaponDO );					}				}							/** hitWeaponsByLaserEnemy			  *	---------------------------------------------------------------------------- */				public function hitWeaponsByLaserEnemy( enemyDO:GameLevelAttackingDisplayObject ):void				{					//var tiles:Vector.<GameboardTile> = getTilesInAttackRange( enemyDO );					var tiles:Vector.<GameboardTile> = getTilesInAttackRangeForGameObject(enemyDO.attackingGameObject, enemyDO.currentTile, enemyDO.direction);					var tileTracker:AttackingTileTracker;					var i:int, j:int;										for( i=0; i<tiles.length; ++i )					{						hitAndFlagDisplayObjectsBy( enemyDO, tiles[i] );					}				}							/** addEnemy			  *	---------------------------------------------------------------------------- */				public function addEnemy( enemyDO:GameLevelAttackingDisplayObject ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "addEnemy("+enemyDO+");" );										var enemyTracker:AttackingDisplayObjectTracker = new AttackingDisplayObjectTracker();						enemyTracker.attackingDisplayObject = enemyDO;										//var tiles:Vector.<GameboardTile> = getTilesInAttackRange( enemyDO );					var tiles:Vector.<GameboardTile> = getTilesInAttackRangeForGameObject(enemyDO.attackingGameObject, enemyDO.currentTile, enemyDO.direction);					var i:int, j:int;					var tileTracker:AttackingTileTracker;					var targetAttacked:GameLevelAttackingDisplayObject;										//trace( "tiles: "+tiles );										tileTracker = VectorUtil.find( _tileTrackers, enemyDO.currentTile, "id" );					if( tileTracker != null )					{						tileTracker.addObjectOnTile( enemyDO );						tileTracker = null;					}										for( i=tiles.length-1; i>=0; --i )					{												//TODO:						//	Need to attack all targets in the range instead of all targets in the first tile it's watching						tileTracker = VectorUtil.find( _tileTrackers, tiles[i], "id" );						if( tileTracker != null )						{							tileTracker.addEnemyWatching( enemyDO );							enemyTracker.addTileWatching( tiles[i] );							//enemyDO.attackTargets( tileTracker.weaponsOnTile );							tileTracker = null;						}											}										_enemyTrackers.push( enemyTracker );					_enemyTrackersLength = _enemyTrackers.length;					enemyTracker = null;										checkForTargets( enemyDO );										//outputTileTrackers();					//outputEnemyTrackers();										//TODO:					//	Check if there are any weapons watching this tile				}							/** removeEnemy			  *	---------------------------------------------------------------------------- *			  *	Removes an enemy and removes its tracker from the list of enemy trackers.			  *	Also removes the enemy from the tiles.			  *	---------------------------------------------------------------------------- */				public function removeEnemy( enemyDO:GameLevelAttackingDisplayObject ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "removeEnemy("+enemyDO+");" );										for( var i:uint=0; i<_enemyTrackersLength; ++i )					{						if( _enemyTrackers[i].attackingDisplayObject == enemyDO )						{							removeEnemyFromTiles( enemyDO );							_enemyTrackers[i].attackingDisplayObject = null;														_enemyTrackers[i] = null;							_enemyTrackers.splice( i, 1 );							_enemyTrackersLength = _enemyTrackers.length;														break;						}					}					/*					if( !enemyDO.alive )					{						trace( "enemy is dead, remove this.." );					}					*/					for( i=0; i<_tileTrackersLength; ++i )					{						//if( _tileTrackers[i].id == enemyDO.currentTile.id )						//{							//AttackingTileTracker(_tileTrackers[i]).removeObjectOnTile( enemyDO );						//}												_tileTrackers[i].removeObjectOnTile( enemyDO );					}															//var tileTracker:AttackingTileTracker = ArrayUtil.find( _tileTrackers, enemyDO.currentTile, "id" );					//if( tileTracker != null )					//{						//tileTracker.removeObjectOnTile( enemyDO );						//tileTracker = null;					//}									}							/** moveEnemyToTile			  *	---------------------------------------------------------------------------- *			  *	Removes the enemy from one tile tracker to the next tile tracker.			  *	Reassigns the tiles that it's watching and check for any weapons in range.			  *	---------------------------------------------------------------------------- */				public function moveEnemyToTile( enemyDO:GameLevelAttackingDisplayObject, tile:GameboardTile ):void				{					//trace( "moveEnemyToTile();" );										removeEnemy( enemyDO );					addEnemy( enemyDO );										//Check if there are any weapons watching these tiles					var tileTracker:AttackingTileTracker = VectorUtil.find( _tileTrackers, tile, "id" );										try					{						for( var i:uint=0; i<tileTracker.weaponsWatching.length; ++i )						{							checkForTargets( tileTracker.weaponsWatching[i] );						}					}					catch( e:Error )					{						ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "No TileTracker !!! "+e.message );					}									}							/** moveEnemyToNextPoint			  *	---------------------------------------------------------------------------- *			  *	This function is called when enemies are moving between points. This checks			  *	if there are any weapons in its range to attack.			  *	---------------------------------------------------------------------------- */				public function moveEnemyToNextPoint( enemyDO:GameLevelAttackingDisplayObject ):void				{					//trace( "moveEnemyToNextPoint" );										checkForTargets( enemyDO );				}							/** removeEnemyFromTiles			  *	---------------------------------------------------------------------------- *			  *	Removes enemy from all the tiles.			  *	---------------------------------------------------------------------------- */				public function removeEnemyFromTiles( enemyDO:GameLevelAttackingDisplayObject ):void				{					for( var i:uint=0; i<_tileTrackersLength; ++i )					{						_tileTrackers[i].removeEnemyWatching( enemyDO );					}				}							/** hitAndFlagDisplayObjectsBy			  *	---------------------------------------------------------------------------- *			  *	Hits the enemies/weapons on either tile specified in the second argument. 			  *	Or if that's not specified, it will use weapon's/enemy's currentTile. It hits 			  *	the enemies/weapons in the tile and will flag them with the weapon/enemy 			  *	so that they can't hit twice by the same weapon/enemy.			  *	For example the ball roll weapon, or the laser enemies.			  *	This function is clever enough to figure out if the attackingDO is a weapon			  *	or enemy and will flag enemies or weapons appropriately.			  *	---------------------------------------------------------------------------- */				public function hitAndFlagDisplayObjectsBy( attackingDO:GameLevelAttackingDisplayObject, tile:GameboardTile=null ):void				{					var tileTracker:AttackingTileTracker;					var i:int;					var attackingDisplayObjectTracker:AttackingDisplayObjectTracker;										if( tile != null )						tileTracker = VectorUtil.find( _tileTrackers, tile, "id" );					else						tileTracker = VectorUtil.find( _tileTrackers, attackingDO.currentTile, "id" );										//trace( "weaponDO.currentTile: "+weaponDO.currentTile );					//trace( "tileTracker: "+tileTracker );										if( tileTracker != null )					{						//trace( "enemies on tile :"+tileTracker.enemiesOnTile );												if( attackingDO is WeaponDisplayObject )						{							for( i=0; i<tileTracker.enemiesOnTile.length; ++i )							{								//tileTracker.enemiesOnTile[i]								attackingDisplayObjectTracker = getAttackingDisplayObjectTracker( _enemyTrackers, tileTracker.enemiesOnTile[i] );																//trace( "found enemyTracker" );																if( attackingDisplayObjectTracker != null && attackingDisplayObjectTracker.addAttackedByDisplayObject(attackingDO) )								{									tileTracker.enemiesOnTile[i].hit( attackingDO.attackingGameObject, attackingDO.attackingGameObject.power, attackingDO.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ONE_HIT_KILL_INDEX) );																		if( attackingDO.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_PATH_INDEX) )									{										attackingDO.playHitSound();									}								}							}						}						else if( attackingDO is EnemyDisplayObject )						{							for( i=0; i<tileTracker.weaponsOnTile.length; ++i )							{								//trace( tileTracker.weaponsOnTile );								//tileTracker.enemiesOnTile[i]																if( tileTracker.weaponsOnTile[i] is WeaponDisplayObject )								{									attackingDisplayObjectTracker = getAttackingDisplayObjectTracker( _weaponTrackers, tileTracker.weaponsOnTile[i] );																		//trace( "found enemyTracker" );								}								else if( tileTracker.weaponsOnTile[i] is GateDisplayObject )								{									attackingDisplayObjectTracker = getAttackingDisplayObjectTracker( _gateTrackers, tileTracker.weaponsOnTile[i] );								}																if( attackingDisplayObjectTracker != null && attackingDisplayObjectTracker.addAttackedByDisplayObject(attackingDO) )								{									tileTracker.weaponsOnTile[i].hit( attackingDO.attackingGameObject, attackingDO.attackingGameObject.power, attackingDO.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ONE_HIT_KILL_INDEX) );								}							}						}					}				}							/** resetDisplayObjectsHitFlagBy			  *	---------------------------------------------------------------------------- *			  *	Resets the enemy's/weapon's hit flag by a certain weapon/enemy.			  *	This function is clever enough to figure out if the attackingDO is a weapon			  *	or enemy and will remove flag from enemies or weapons appropriately.			  *	---------------------------------------------------------------------------- */				public function resetDisplayObjectsHitFlagBy( attackingDO:GameLevelAttackingDisplayObject ):void				{					var i:int;										if( attackingDO is WeaponDisplayObject )					{						for( i=0; i<_enemyTrackersLength; ++i )						{							//trace( "found enemy tracker and remove the weapon hit, "+_enemyTrackers[i].attackingDisplayObject );							_enemyTrackers[i].removeAttackedByDisplayObject( attackingDO );						}					}					else if( attackingDO is EnemyDisplayObject )					{						for( i=0; i<_weaponTrackersLength; ++i )						{							_weaponTrackers[i].removeAttackedByDisplayObject( attackingDO );						}												for( i=0; i<_gateTrackersLength; ++i )						{							_gateTrackers[i].removeAttackedByDisplayObject( attackingDO );						}					}				}							/** checkForTargets			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function checkForTargets( displayObject:GameLevelAttackingDisplayObject ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "checkForTargets("+displayObject+");" );										var tracker:AttackingDisplayObjectTracker;					var tileTracker:AttackingTileTracker;					var i:int;					//var anyTargetsToAttack:Boolean = false;					var targetAttacked:GameLevelAttackingDisplayObject;					var targets:Vector.<GameLevelAttackingDisplayObject> = new Vector.<GameLevelAttackingDisplayObject>;										//NOTE:					//	Comment these for TESTING!										if( displayObject is WeaponDisplayObject )					{												tracker = getAttackingDisplayObjectTracker( _weaponTrackers, displayObject );												//trace( "tilesWatching: "+tracker.tilesWatching );												try						{							if( displayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_CATAPULT_INDEX) )							{								for( i=tracker.tilesWatchingLength-1; i>=0; --i )								{									tileTracker = VectorUtil.find( _tileTrackers, tracker.tilesWatching[i], "id" );									targets = targets.concat(tileTracker.enemiesOnTile);								}																targetAttacked = displayObject.attackTargets( targets );								if( targetAttacked != null )								{									displayObject.startAttackAnimation();								}							}							else							{								for( i=tracker.tilesWatchingLength-1; i>=0; --i )								{									tileTracker = VectorUtil.find( _tileTrackers, tracker.tilesWatching[i], "id" );									//trace( "tileTracker.enemiesOnTile: "+tileTracker.enemiesOnTile );																		//trace( tileTracker.tile );									//targets = targets.concat( tileTracker.enemiesOnTile );									targets = tileTracker.enemiesOnTile;									targetAttacked = displayObject.attackTargets( targets );									if( targetAttacked != null )									{										displayObject.startAttackAnimation();										break;									}								}							}							/*							targetAttacked = displayObject.attackTargets( targets );							if( targetAttacked != null )							{								displayObject.startAttackAnimation();								//break;							}							*/						}						catch( e:Error )						{							ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "Weapon Tracker is not found !!! "+e.message );						}																		//targetAttacked = displayObject.attackTargets( getTargetsInAttackRange(displayObject) );					}					else if( displayObject is EnemyDisplayObject )					{						tracker = getAttackingDisplayObjectTracker( _enemyTrackers, displayObject );												//trace( "tilesWatching: "+tracker.tilesWatching );												//try						//{														for( i=tracker.tilesWatchingLength-1; i>=0; --i )							{								tileTracker = VectorUtil.find( _tileTrackers, tracker.tilesWatching[i], "id" );								//trace( "tileTracker.weaponsOnTile: "+tileTracker.weaponsOnTile );																//targets = targets.concat( tileTracker.weaponsOnTile );								targets = tileTracker.weaponsOnTile;								targetAttacked = displayObject.attackTargets( targets );								if( targetAttacked != null )								{									displayObject.startAttackAnimation();									break;								}							}							/*							targetAttacked = displayObject.attackTargets( targets );							if( targetAttacked != null )							{								displayObject.startAttackAnimation();								//break;							}							*/							//trace( "targets: "+targets );							//trace( "targetAttacked: "+targetAttacked );							//trace( "moving: "+(displayObject as EnemyDisplayObject).moving );														//if( targetAttacked != null ) trace( "targetAttacked.alive: "+targetAttacked.alive );														//trace( "targetAttacked: "+targetAttacked );							//trace( "pausedMoving: "+displayObject.pausedMoving );							if( targetAttacked != null && !targetAttacked.alive )							{								(displayObject as EnemyDisplayObject).stopAttacking();								(displayObject as EnemyDisplayObject).continueMoving();							}							else if ( targetAttacked == null && (displayObject as EnemyDisplayObject).pausedMoving )							{								(displayObject as EnemyDisplayObject).continueMoving();							}						//}						//catch( e:Error )						//{							//ConsoleBroadcaster.broadcast( "AttackingDisplayObjectController", "Enemy Tracker is not found !!! "+e.message );						//}					}										tracker = null;					tileTracker = null;									}							/** getAttackingDisplayObjectTracker			  *	---------------------------------------------------------------------------- */				protected function getAttackingDisplayObjectTracker( trackers:*, attackingDO:GameLevelAttackingDisplayObject ):AttackingDisplayObjectTracker				{					for( var i:uint=0; i<trackers.length; ++i )					{						if( trackers[i].attackingDisplayObject == attackingDO )						{							return trackers[i];						}					}										return null;				}							/** getWeaponTracker			  *	---------------------------------------------------------------------------- */				public function getWeaponTracker( attackingDO:GameLevelAttackingDisplayObject ):AttackingDisplayObjectTracker				{					return getAttackingDisplayObjectTracker( _weaponTrackers, attackingDO );				}							/** getEnemyTracker			  *	---------------------------------------------------------------------------- */				public function getEnemyTracker( attackingDO:GameLevelAttackingDisplayObject ):AttackingDisplayObjectTracker				{					return getAttackingDisplayObjectTracker( _enemyTrackers, attackingDO );				}							/** getPath			  *	---------------------------------------------------------------------------- */				public function getPath( tile:GameboardTile ):Vector.<GameboardTile>				{					var i:uint, j:uint;										for( i=0; i<_paths.length; ++i )					{						for( j=0; j<_paths[i].length; ++j )						{							//if( _paths[i][j].row == tile.row && _paths[i][j].column == tile.column )							if( GameboardTile(_paths[i][j]).isTheSameAsTile( tile ) )							{								return _paths[i];							}						}					}										return null;				}							/** getPathIndex			  *	---------------------------------------------------------------------------- */				public function getPathIndex( tile:GameboardTile ):int				{					var i:uint, j:uint;										//trace( "getPathIndex("+tile+");" );										for( i=0; i<_paths.length; ++i )					{						for( j=0; j<_paths[i].length; ++j )						{							//if( _paths[i][j].row == tile.row && _paths[i][j].column == tile.column )							if( GameboardTile(_paths[i][j]).isTheSameAsTile( tile ) )							{								return i;							}						}					}										return -1;				}								public function getCurrentIndexInPath( tile:GameboardTile, path:Vector.<GameboardTile> ):int				{					for( var i:uint=0; i<path.length; ++i )					{						if( GameboardTile(path[i]).isTheSameAsTile(tile) )							return i;					}										return -1;				}							/** getTargetsInAttackRange			  *	---------------------------------------------------------------------------- *			  *	Returns all targets in attack range.			  *	---------------------------------------------------------------------------- 				public function getTargetsInAttackRange( attackingDisplayObject:GameLevelAttackingDisplayObject ):Array				{					var tracker:AttackingDisplayObjectTracker;					var tileTracker:AttackingTileTracker;					var i:uint;					var targetAttacked:GameLevelAttackingDisplayObject;					var targets:Array = new Array();										if( attackingDisplayObject is WeaponDisplayObject )						tracker = getAttackingDisplayObjectTracker( _weaponTrackers, attackingDisplayObject );					else if( attackingDisplayObject is EnemyDisplayObject )						tracker = getAttackingDisplayObjectTracker( _enemyTrackers, attackingDisplayObject );										if( tracker != null )					{						for( i=0; i<tracker.tilesWatchingLength; ++i )						{							tileTracker = VectorUtil.find( _tileTrackers, tracker.tilesWatching[i], "id" );							//trace( "tileTracker.enemiesOnTile: "+tileTracker.enemiesOnTile );														if( attackingDisplayObject is WeaponDisplayObject )								targets = targets.concat( tileTracker.enemiesOnTile );							else if( attackingDisplayObject is EnemyDisplayObject )								targets = targets.concat( tileTracker.weaponsOnTile );													}					}										if( targets.length > 0 )						return targets;										return null;				}*/							/** getTilesInAttackRange			  *	---------------------------------------------------------------------------- *			  *	Returns the tiles that are in attack range.			  *	---------------------------------------------------------------------------- */				public function getTilesInAttackRange( attackingDisplayObject:GameLevelAttackingDisplayObject ):Vector.<GameboardTile>				{					/*					var pathIndex:int = getPathIndex( attackingDisplayObject.currentTile );					var found:Boolean = false;					var tileRange:int = 0;					//var tileIndex:int = 0;					var i:uint, j:uint;										var tilesRange:Array = new Array();										//trace( "pathIndex: "+pathIndex );										if( pathIndex >= 0 )					{						//trace( _paths[pathIndex] );						//trace( "tileIndex: "+tileIndex );						//trace( "currentIndexInPath: "+attackingDisplayObject.currentIndexInPath );						//trace( "paths: "+_paths[pathIndex] );						//trace( "range: "+attackingDisplayObject.attackingGameObject.range );												var singleLane:Boolean = attackingDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_SINGLE_LANE_INDEX );						var catapult:Boolean = attackingDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_CATAPULT_INDEX );												if( attackingDisplayObject is EnemyDisplayObject )						{							if( catapult )							{								for( i=attackingDisplayObject.currentIndexInPath; i<_paths[pathIndex].length; ++i )								{									if( i < attackingDisplayObject.currentIndexInPath+attackingDisplayObject.attackingGameObject.range )										tilesRange.push( _paths[pathIndex][i] );								}							}							else							{								for( i=attackingDisplayObject.currentIndexInPath; i<_paths[pathIndex].length; ++i )								{									//trace( _paths[pathIndex][i] );																		//if( i >= attackingDisplayObject.currentIndexInPath )									//{										if( i < attackingDisplayObject.currentIndexInPath+attackingDisplayObject.attackingGameObject.range )										{											if( !singleLane )											{												tilesRange.push( _paths[pathIndex][i] );											}											else if( singleLane )											{												if( (attackingDisplayObject.direction == GameLevelUtil.DIRECTION_UP || attackingDisplayObject.direction == GameLevelUtil.DIRECTION_DOWN) 														&& GameboardTile(_paths[pathIndex][i]).column == attackingDisplayObject.currentTile.column )												{													tilesRange.push( _paths[pathIndex][i] );												}												else if( (attackingDisplayObject.direction == GameLevelUtil.DIRECTION_LEFT || attackingDisplayObject.direction == GameLevelUtil.DIRECTION_RIGHT) 														&& GameboardTile(_paths[pathIndex][i]).row == attackingDisplayObject.currentTile.row )												{													tilesRange.push( _paths[pathIndex][i] );												}											}										}										else										{											break;										}									//}								}							}														//trace( "enemy tilesRange: "+tilesRange );						}						else						{							if( attackingDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_MULTIPLE_DIRECTIONS_PROJECTILE_INDEX) )							{								//trace( "weapon is a multiple directional" );								for( i=0; i<_paths.length; ++i )								{									for( j=0; j<_paths[i].length; ++j )									{										if( _paths[i][j].row == attackingDisplayObject.currentTile.row || _paths[i][j].column == attackingDisplayObject.currentTile.column )										{											tilesRange.push( _paths[i][j] );										}									}								}							}							else if( !singleLane )							{								//trace( "weapon not a single lane" );								for( i=0; i<_paths.length; ++i )								{									for( j=0; j<_paths[i].length; ++j )									{										tilesRange.push( _paths[i][j] );									}								}							}							else							{								var startIndex:int;																//Single Lane weapons								if( catapult || attackingDisplayObject.attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_PATH_INDEX ) )								{									//trace( "catapult: "+catapult );									//trace( "path weapon: "+attackingDisplayObject.attackingGameObject.hasProjectileProperty( GameLevelUtil.ATTACK_PROPERTY_PATH_INDEX ) );									//trace( "weapon is a catapult or a path weapon" );									for( i=0; i<_paths[pathIndex].length; ++i )									{										tilesRange.push( _paths[pathIndex][i] );									}								}								else if( attackingDisplayObject.attackingGameObject.hasProjectileProperty( GameLevelUtil.ATTACK_PROPERTY_PATH_INDEX ) )								{									startIndex = attackingDisplayObject.currentIndexInPath-attackingDisplayObject.attackingGameObject.range;									startIndex = startIndex < 0 ? 0 : startIndex;																		for( i=startIndex; i<=attackingDisplayObject.currentIndexInPath; ++i )									{										tilesRange.push( _paths[pathIndex][i] );									}								}								else								{									startIndex = attackingDisplayObject.currentIndexInPath-attackingDisplayObject.attackingGameObject.range;									startIndex = startIndex < 0 ? 0 : startIndex;																		//trace( "startIndex: "+startIndex );									//trace( "currentIndexInPath: "+attackingDisplayObject.currentIndexInPath );																		//for( i=0; i<_paths[pathIndex].length; ++i )									for( i=startIndex; i<=attackingDisplayObject.currentIndexInPath; ++i )									{										//if( i <= attackingDisplayObject.currentIndexInPath && attackingDisplayObject.currentIndexInPath-i < attackingDisplayObject.attackingGameObject.range )										//{											//trace( _paths[pathIndex][i] );																						if( (attackingDisplayObject.direction == GameLevelUtil.DIRECTION_UP || attackingDisplayObject.direction == GameLevelUtil.DIRECTION_DOWN) 													&& GameboardTile(_paths[pathIndex][i]).column == attackingDisplayObject.currentTile.column )											{												tilesRange.push( _paths[pathIndex][i] );											}											else if( (attackingDisplayObject.direction == GameLevelUtil.DIRECTION_LEFT || attackingDisplayObject.direction == GameLevelUtil.DIRECTION_RIGHT) 													&& GameboardTile(_paths[pathIndex][i]).row == attackingDisplayObject.currentTile.row )											{												tilesRange.push( _paths[pathIndex][i] );											}										//}									}								}							}														//trace( "weapon tilesRange: "+tilesRange );						}					}										return tilesRange;					*/										return getTilesInAttackRangeForGameObject(attackingDisplayObject.attackingGameObject, attackingDisplayObject.currentTile, attackingDisplayObject.direction);				}							/** getTilesInAttackRangeForGameObject			  *	---------------------------------------------------------------------------- *			  *	Returns the tiles that are in attack range for a certain game object.			  *	---------------------------------------------------------------------------- */				public function getTilesInAttackRangeForGameObject( gameObject:AbstractGameObject, tile:GameboardTile, direction:int ):Vector.<GameboardTile>				{					var found:Boolean = false;					var tileRange:int = 0;					var i:uint, j:uint;					var tilesRange:Vector.<GameboardTile> = new Vector.<GameboardTile>;					var pathIndex:int;					var currentIndexInPath:int;					var path:Vector.<GameboardTile>;										for( i=0; i<_paths.length; ++i )					{						for( j=0; j<_paths[i].length; ++j )						{							if( _paths[i][j].isTheSameAsTile( tile ) )							{								pathIndex = i;								currentIndexInPath = j;								path = _paths[i];							}						}					}										if( pathIndex >= 0 )					{						var singleLane:Boolean = gameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_SINGLE_LANE_INDEX );						var catapult:Boolean = gameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_CATAPULT_INDEX );												if( gameObject is Enemy )						{							/*							if( catapult )							{								for( i=currentIndexInPath; i<path.length; ++i )								{									if( i < currentIndexInPath+gameObject.range )										tilesRange.push( path[i] );								}							}							else							{								for( i=currentIndexInPath; i<path.length; ++i )								{									if( i < currentIndexInPath+gameObject.range )									{																			}								}							}							*/														for( i=currentIndexInPath; i<path.length; ++i )							{								if( i < currentIndexInPath+gameObject.range )								{									if( catapult )									{										tilesRange.push( path[i] );									}									//else if( !singleLane )									//{										//tilesRange.push( path[i] );									//}									else if( singleLane )									{										/*										if( (direction == GameLevelUtil.DIRECTION_UP || direction == GameLevelUtil.DIRECTION_DOWN) && path[i].column == tile.column )										{											tilesRange.push( path[i] );										}										else if( (direction == GameLevelUtil.DIRECTION_LEFT || direction == GameLevelUtil.DIRECTION_RIGHT) && path[i].row == tile.row )										{											tilesRange.push( path[i] );										}										*/										if( direction == GameLevelUtil.DIRECTION_UP && path[i].column == tile.column && path[i].row <= tile.row )										{											tilesRange.push( path[i] );										}										else if( direction == GameLevelUtil.DIRECTION_DOWN && path[i].column == tile.column && path[i].row >= tile.row )										{											tilesRange.push( path[i] );										}										else if( direction == GameLevelUtil.DIRECTION_LEFT && path[i].row == tile.row && path[i].column <= tile.column )										{											tilesRange.push( path[i] );										}										else if( direction == GameLevelUtil.DIRECTION_RIGHT && path[i].row == tile.row && path[i].column >= tile.column )										{											tilesRange.push( path[i] );										}									}								}								else								{									break;								}							}						}						else						{							var columnDiff:int = 0;							var rowDiff:int = 0;														if( gameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_MULTIPLE_DIRECTIONS_PROJECTILE_INDEX) )							{								for( i=0; i<_paths.length; ++i )								{									for( j=0; j<_paths[i].length; ++j )									{										columnDiff = tile.column - _paths[i][j].column;										columnDiff = columnDiff < 0 ? -columnDiff : columnDiff;										rowDiff = tile.row - _paths[i][j].row;										rowDiff = rowDiff < 0 ? -rowDiff : rowDiff;																				if( (_paths[i][j].row == tile.row && columnDiff <= gameObject.range) || (_paths[i][j].column == tile.column && rowDiff <= gameObject.range) )										{											tilesRange.push( _paths[i][j] );										}									}								}							}							else if( !singleLane )							{								for( i=0; i<_paths.length; ++i )								{									for( j=0; j<_paths[i].length; ++j )									{										tilesRange.push( _paths[i][j] );									}								}							}							else							{								var startIndex:int;																if( catapult )								{									for( i=0; i<path.length; ++i )									{										tilesRange.push( path[i] );									}								}								else if( gameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_PATH_INDEX) )								{									for( i=0; i<=currentIndexInPath; ++i )									{										tilesRange.push( path[i] );									}								}								else if( gameObject.hasProjectileProperty(GameLevelUtil.ATTACK_PROPERTY_PATH_INDEX) )								{									startIndex = currentIndexInPath - gameObject.range;									startIndex = startIndex < 0 ? 0 : startIndex;																		for( i=startIndex; i<=currentIndexInPath; ++i )									{										tilesRange.push( path[i] );									}								}								else								{									startIndex = currentIndexInPath - gameObject.range;									startIndex = startIndex < 0 ? 0 : startIndex;																		//trace( "startIndex: "+startIndex );									//trace( "currentIndexInPath: "+currentIndexInPath );									//trace( "gameObject.range: "+gameObject.range );																											for( i=0; i<path.length; ++i )									{										//trace( "tile.row: "+tile.row );										//trace( "path[i].row: "+path[i].row );										//trace( "direction: "+direction );										/*										if( (direction == GameLevelUtil.DIRECTION_UP || direction == GameLevelUtil.DIRECTION_DOWN) && (path[i].column == tile.column) )										{											tilesRange.push( path[i] );										}										else if( (direction == GameLevelUtil.DIRECTION_LEFT || direction == GameLevelUtil.DIRECTION_RIGHT) && (path[i].row == tile.row) )										{											tilesRange.push( path[i] );										}										*/																				//trace( "path["+i+"].row: "+path[i].row );										//trace( "path["+i+"].column: "+path[i].column );										//trace( "gameObject.range: "+gameObject.range );										//trace( "direction: "+direction );										/*										if( gameObject.oneDirectionOnly )										{											columnDiff = path[i].column - tile.column;											columnDiff = columnDiff < 0 ? -columnDiff : columnDiff;											rowDiff = paht[i].row - tile.row;											rowDiff = rowDiff < 0 ? -rowDiff : rowDiff;																						if( columnDiff == 0 && rowDiff <= gameObject.range )											{												tilesRange.push( path[i] );											}											else if( rowDiff == 0 && columnDiff <= gameObject.range )											{												tilesRange.push( path[i] );											}										}										else										{*/											if( direction == GameLevelUtil.DIRECTION_UP && path[i].column == tile.column && path[i].row <= tile.row && (tile.row - path[i].row) <= gameObject.range )											{												tilesRange.push( path[i] );											}											else if( direction == GameLevelUtil.DIRECTION_DOWN && path[i].column == tile.column && path[i].row >= tile.row && (path[i].row - tile.row) <= gameObject.range )											{												tilesRange.push( path[i] );											}											else if( direction == GameLevelUtil.DIRECTION_LEFT && path[i].row == tile.row && path[i].column <= tile.column && (tile.column - path[i].column) <= gameObject.range )											{												tilesRange.push( path[i] );											}											else if( direction == GameLevelUtil.DIRECTION_RIGHT && path[i].row == tile.row && path[i].column >= tile.column && (path[i].column - tile.column) <= gameObject.range )											{												tilesRange.push( path[i] );											}										//}									}																		//trace( "-----------------" );								}							}						}					}										path = null;										return tilesRange;				}											/** outputTileTrackers			  *	---------------------------------------------------------------------------- *			  *	Displays the tile trackers for easy to read output			  *	---------------------------------------------------------------------------- */				public function outputTileTrackers():void				{					for( var i:uint=0; i<_tileTrackersLength; ++i )					{						_tileTrackers[i].output();					}				}							/** outputWeaponTrackers			  *	---------------------------------------------------------------------------- *			  *	Displays the weapon trackers for easy to read output			  *	---------------------------------------------------------------------------- */				public function outputWeaponTrackers():void				{					if( _weaponTrackersLength == 0 )					{						var outputString:String = "";							outputString += "\n/***** No weaponTrackers at this moment *****/\n";												//trace( outputString );												return;					}										for( var i:uint=0; i<_weaponTrackersLength; ++i )					{						_weaponTrackers[i].output();					}				}							/** outputEnemyTrackers			  *	---------------------------------------------------------------------------- *			  *	Displays the enemy trackers for easy to read output			  *	---------------------------------------------------------------------------- */				public function outputEnemyTrackers():void				{					if( _enemyTrackersLength == 0 )					{						var outputString:String = "";							outputString += "\n/***** No enemyTrackers at this moment *****/\n";												//trace( outputString );												return;					}										for( var i:uint=0; i<_enemyTrackersLength; ++i )					{						_enemyTrackers[i].output();					}				}		}	}