/** GameboardController  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the base class for DisplayObject Controller classes.  *	  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */	package com.boogabooga.controller.gamelevel	{		import flash.display.MovieClip;		import flash.display.Stage;		import flash.display.StageDisplayState;		import flash.display.StageScaleMode;		import flash.events.Event;		import flash.events.EventDispatcher;		import flash.events.FullScreenEvent;		import flash.events.MouseEvent;		import flash.events.TimerEvent;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.system.Capabilities;		import flash.system.System;		import flash.utils.getDefinitionByName;		import flash.utils.getTimer;		//import flash.ui.Mouse;				import com.adobe.serialization.json.JSONEncoder;		import com.adobe.serialization.json.JSONDecoder;		import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.cache.AssetLoader;		import com.avatarlabs.utils.cache.BitmapDataManager;		import com.avatarlabs.utils.cache.BitmapDataObject;		import com.avatarlabs.utils.cache.HashTable;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.AssetLoaderEvent;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.sound.SoundEffectPlayer;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.timers.ElapsedTime;		import com.greensock.TweenLite;		import org.osflash.signals.Signal;				import com.boogabooga.controller.gamelevel.DisplayObjectController;		import com.boogabooga.controller.maingame.GiftDataController;		import com.boogabooga.controller.maingame.IslandDataController;		import com.boogabooga.controller.maingame.MainGameController;		import com.boogabooga.controller.maingame.UserDataController;		import com.boogabooga.controller.maingame.TrackingDataController;		import com.boogabooga.controller.maingame.TreasureDataController;		import com.boogabooga.data.SettingsIndex;		import com.boogabooga.data.SoundData;		import com.boogabooga.data.SoundsIndex;		import com.boogabooga.data.StringsIndex;		import com.boogabooga.data.gamelevel.*;		import com.boogabooga.data.maingame.MainGameDataIndex;		import com.boogabooga.data.maingame.User;		import com.boogabooga.data.maingame.Village;		import com.boogabooga.events.BoogaEvent;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.ChickenDisplayObject;		import com.boogabooga.ui.gamelevel.DigResultView;		import com.boogabooga.ui.gamelevel.EnvironmentDisplayObject;		import com.boogabooga.ui.gamelevel.Gameboard;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.ui.gamelevel.GateDisplayObject;		import com.boogabooga.ui.gamelevel.GodDisplayObject;		import com.boogabooga.ui.gamelevel.VillagerDisplayObject;		import com.boogabooga.ui.gamelevel.enemies.*;		import com.boogabooga.ui.gamelevel.gameboardmenu.GameboardMenuContentIcon;		import com.boogabooga.ui.gamelevel.gameboardmenu.GameboardMenuGift;		import com.boogabooga.ui.gamelevel.projectiles.*;		import com.boogabooga.ui.gamelevel.weapons.*;		import com.boogabooga.ui.maingame.weaponselection.WeaponSelectionEnemyCountIcon;		import com.boogabooga.utils.ElementCompatibility;		import com.boogabooga.utils.GameLevelUtil;		import com.boogabooga.ui.gamelevel.DiggingTile;						public class GameboardController extends DisplayObjectController		{			protected var _gameLevel:GameLevel;			protected var _gameLevelElement:ElementCompatibility;			protected var _gameLevelCurrentData:GameLevelCurrentData;			protected var _distinctEnemiesInLevel:Array;			protected var _enemiesLeft:Number;			protected var _totalEnemies:Number;			//protected var _cryptologyId:int;			protected var _currentVillage:Village;			protected var _diggingMap:DiggingMap;						protected var _isDiggingOnly:Boolean;			protected var _isPaused:Boolean;			protected var _isPlaying:Boolean;			protected var _win:Boolean;			protected var _gameEnds:Boolean;			protected var _playingEndAnimation:Boolean;			protected var _defaultTilesExtraHitAreaSetting:Boolean;						//protected var _paths:Array;			protected var _tilePaths:Vector.<Vector.<GameboardTile>>;			protected var _spawnPaths:Vector.<Vector.<GameboardTile>>;			protected var _inIsometricView:Boolean;						protected var _mainLoopTimer:CustomTimer;			protected var _countdownTimer:CustomTimer;						protected var _enemiesSpawned:int;			protected var _totalWeapons:int;			protected var _totalGods:int;						protected var _backgroundMusicOptions:Array;			protected var _currentBackgroundMusic:String;			protected var _isPlayingBackgroundMusic:Boolean;						private var _isTricksterGodInPlay:Boolean;			private var _isWarriorGodInPlay:Boolean;			private var _isWindGoddessInPlay:Boolean;			private var _isDeathGodInPlay:Boolean;						private var _shakeGameboardTimer:CustomTimer;			private var _tricksterGodDurationTimer:CustomTimer;			private var _warriorGodDurationTimer:CustomTimer;						//For tracking			protected var _elapsedTime:ElapsedTime;						protected var _weaponDisplayObjectController:WeaponDisplayObjectController;			protected var _enemyDisplayObjectController:EnemyDisplayObjectController;			protected var _chickenDisplayObjectController:ChickenDisplayObjectController;			protected var _waveZoneControllers:Vector.<WaveZoneController>;			protected var _effectsController:EffectsController;			protected var _attackingDisplayObjectController:AttackingDisplayObjectController;			protected var _gateDisplayObjectController:GateDisplayObjectController;			protected var _godDisplayObjectController:GodDisplayObjectController;			protected var _projectileDisplayObjectController:ProjectileDisplayObjectController;			protected var _villagerDisplayObjectController:VillagerDisplayObjectController;									public var onTutorialLevelIntroFinished:Signal;			public var onGameEnded:Signal;						/** Constructor			  *	---------------------------------------------------------------------------- */			 	public function GameboardController()				{					init();				}								override public function set gameboardReference( g:Gameboard ):void				{					super.gameboardReference = g;										_gameboardReference.gameboardController = this;					//_gameboardReference.addEventListener( "onStartGameClicked", handleStartGameClicked, false, 0, true );					//_gameboardReference.addEventListener( "onPauseGameClicked", handlePauseGameClicked, false, 0, true );					//_gameboardReference.addEventListener( "onUnpauseGameClicked", handleUnpauseGameClicked, false, 0, true );					//_gameboardReference.addEventListener( "onFullScreenClicked", handleFullScreenClicked, false, 0, true );					//_gameboardReference.addEventListener( GameLevelEvent.ON_SLOT_SPIN_STARTS, handleSlotSpinStarts, false, 0, true );					//_gameboardReference.addEventListener( GameLevelEvent.ON_SLOT_SPIN_ENDS, handleSlotSpinEnds, false, 0, true );					_gameboardReference.onSlotSpinStarted.add( handleSlotSpinStarted );					_gameboardReference.onSlotSpinEnded.add( handleSlotSpinEnded );					//_gameboardReference.addEventListener( GameLevelEvent.ON_MENU_ICON_SELECTED, handleMenuIconSelected, false, 0, true );					//_gameboardReference.addEventListener( GameLevelEvent.ON_WEAPON_ADDED, handleWeaponAdded, false, 0, true );					//_gameboardReference.addEventListener( GameLevelEvent.ON_MENU_DELETE_SELECTED, handleMenuDeleteSelected, false, 0, true );					_gameboardReference.addEventListener( GameLevelEvent.REPLAY_GAME_CLICKED, handleReplayGameClicked, false, 0, true );					_gameboardReference.addEventListener( GameLevelEvent.EXIT_GAME_CLICKED, handleExitGameClicked, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_BUY_CHICKEN, handleBuyChicken, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_RESULT_SCREEN_WIN_ANIMATION_DONE, handleWinAnimationDone, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_RESULT_SCREEN_LOSE_ANIMATION_DONE, handleLoseAnimationDone, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_DIG_TREASURE, handleTreasureDug, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_DIG_TREASURE_ANIMATION_COMPLETE, handleTreasureDugAnimationComplete, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_DIG_SOUND_START, handleDigSoundStart, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_DIG_RESULT_VIEW_NEXT, handleDigResultExit, false, 0, true );					//_gameboardReference.addEventListener( BoogaEvent.ON_DIG_RESULT_VIEW_LEAVE_EARLY, handleDigResultLeaveEarly, false, 0, true );					_gameboardReference.addEventListener( BoogaEvent.ON_NEW_DISCOVERIES_VIEW_NEXT, handleNewDiscoveriesExit, false, 0, true );					//_gameboardReference.addEventListener( BoogaEvent.ON_PLACE_WEAPON_ON_INVALID_SPOT, handlePlaceWeaponOnInvalidSpot, false, 0, true );					_gameboardReference.onWeaponPlacedOnInvalidSpot.add( handleWeaponPlacedOnInvalidSpot );					_gameboardReference.onDigTextAnimationCompleted.add( handleDigTextAnimationCompleted );									}								public function get win():Boolean { return _win; }								public function get enemyDisplayObjectController():EnemyDisplayObjectController { return _enemyDisplayObjectController; }				public function get weaponDisplayObjectController():WeaponDisplayObjectController { return _weaponDisplayObjectController; }				public function get chickenDisplayObjectController():ChickenDisplayObjectController { return _chickenDisplayObjectController; }				public function set gameLevel( g:GameLevel ) { _gameLevel = g; _gameLevelElement = GameLevelUtil.checkForElement( _gameLevel ); }				public function get gameLevel():GameLevel { return _gameLevel; }				public function get gameLevelCurrentData():GameLevelCurrentData { return _gameLevelCurrentData; }				public function get attackingDisplayObjectController():AttackingDisplayObjectController { return _attackingDisplayObjectController; }								//public function set cryptologyId( i:int ):void { _cryptologyId = i; }				public function set currentVillage( v:Village ):void { _currentVillage = v; trace( "_currentVillage: "+_currentVillage ); }				public function set diggingMap( d:DiggingMap ):void { _diggingMap = d; }								public function get isPlaying():Boolean { return _isPlaying; }				public function get isPaused():Boolean { return _isPaused; }								//public function set isTricksterGodInPlay( b:Boolean ):void { _isTricksterGodInPlay = b; }				public function get isTricksterGodInPlay():Boolean { return _isTricksterGodInPlay; }								//public function set isWarriorGodInPlay( b:Boolean ):void { _isWarriorGodInPlay = b; }				public function get isWarriorGodInPlay():Boolean { return _isWarriorGodInPlay; }											/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_debug = true;					//_cryptologyId = 0;										_backgroundMusicOptions = [ "music_loop_gameplay_1.wav", "music_loop_gameplay_3.wav", "music_loop_gameplay_4.wav" ];										EventNotificationCenter.getInstance().addSignalListener( BoogaEvent.ON_CHEAT_DETECTED, handleCheatDetected, this );					//EventNotificationCenter.getInstance().addEventListener( "onSpacePressed", handleSpacePressed, false, 0, true );					//EventNotificationCenter.getInstance().addEventListener( BoogaEvent.ON_WARNING_HIDE, handleWarningHid, false, 0, true );										SettingsIndex.getInstance().onPerformanceItemsToggled.add( handlePerformanceItemsToggled );										if( MainGameController.getInstance().currentUser.tutorialGameLevel )					{						onTutorialLevelIntroFinished = new Signal();					}									}								public function resetState():void				{					_win = false;					_gameEnds = false;					_isPlaying = false;					_isPaused = false;				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "pause();" );										if( _gameboardReference.introAnimationViewClip != null && _gameboardReference.introAnimationViewClip.running )					{						_gameboardReference.introAnimationViewClip.pause();					}										if( _isPlaying && !_isPaused )					{						EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_FPS_CHECKER_STOPPED, this );												_elapsedTime.pause();												_isPaused = true;												_gameboardReference.pause();												if( _tricksterGodDurationTimer != null && _tricksterGodDurationTimer.isRunning )						{							_tricksterGodDurationTimer.pause();						}												if( _warriorGodDurationTimer != null && _warriorGodDurationTimer.isRunning )						{							_warriorGodDurationTimer.pause();						}												if( _shakeGameboardTimer != null && _shakeGameboardTimer.isRunning )							_shakeGameboardTimer.pause();												for( var i:int=0; i<_waveZoneControllers.length; ++i )						{							_waveZoneControllers[i].pause();						}												_projectileDisplayObjectController.pause();						_gateDisplayObjectController.pause();						_godDisplayObjectController.pause();						_weaponDisplayObjectController.pause();						_villagerDisplayObjectController.pause();						_enemyDisplayObjectController.pause();						_chickenDisplayObjectController.pause();						_effectsController.pause();												SoundEffectPlayer.getInstance().pause();											}					else if( _gameEnds )					{						_gameboardReference.pause();												if( _playingEndAnimation )						{							if( _win )								_gameboardReference.resultScreenWinClip.pause();							else								_gameboardReference.resultScreenLoseClip.pause();						}						else						{							if( _win )								_gameboardReference.hideDigMouseCursor();						}					}					else if( _isDiggingOnly )					{						_gameboardReference.pause();						_gameboardReference.hideDigMouseCursor();					}				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "unpause();" );										if( _gameboardReference.introAnimationViewClip != null && _gameboardReference.introAnimationViewClip.running )					{						_gameboardReference.introAnimationViewClip.unpause();					}										if( _isPlaying && _isPaused )					{						_elapsedTime.unpause();												_isPaused = false;												_gameboardReference.unpause();												if( _tricksterGodDurationTimer != null && _tricksterGodDurationTimer.isRunning )						{							_tricksterGodDurationTimer.unpause();						}												if( _warriorGodDurationTimer != null && _warriorGodDurationTimer.isRunning )						{							_warriorGodDurationTimer.unpause();						}												if( _shakeGameboardTimer != null && _shakeGameboardTimer.isRunning )							_shakeGameboardTimer.unpause();												for( var i:int=0; i<_waveZoneControllers.length; ++i )						{							_waveZoneControllers[i].unpause();						}												_projectileDisplayObjectController.unpause();						_gateDisplayObjectController.unpause();						_godDisplayObjectController.unpause();						_weaponDisplayObjectController.unpause();						_villagerDisplayObjectController.unpause();						_enemyDisplayObjectController.unpause();						_chickenDisplayObjectController.unpause();						_effectsController.unpause();												SoundEffectPlayer.getInstance().unpause();												EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_FPS_CHECKER_STARTED, this );					}					else if( _gameEnds )					{						_gameboardReference.unpause();												if( _playingEndAnimation )						{							if( _win )								_gameboardReference.resultScreenWinClip.unpause();							else								_gameboardReference.resultScreenLoseClip.unpause();						}						else						{							if( _win )								_gameboardReference.showDigMouseCursor();						}					}					else if( _isDiggingOnly )					{						_gameboardReference.unpause();						_gameboardReference.showDigMouseCursor();					}				}							/** pauseForGodAttack			  *	---------------------------------------------------------------------------- *			  *	Pauses the elements in the gamebaord play and pauses them for a bit when			  *	god animation occurs.			  *	---------------------------------------------------------------------------- */				public function pauseForGodAttack():void				{					ConsoleBroadcaster.broadcast( "GameboardController", "pauseForGodAttack();" );										if( _isPlaying && !_isPaused )					{						_isPaused = true;												_gameboardReference.pause( false );												if( _tricksterGodDurationTimer != null && _tricksterGodDurationTimer.isRunning )						{							_tricksterGodDurationTimer.pause();						}												if( _warriorGodDurationTimer != null && _warriorGodDurationTimer.isRunning )						{							_warriorGodDurationTimer.pause();						}												for( var i:int=0; i<_waveZoneControllers.length; ++i )						{							_waveZoneControllers[i].pause();						}												_projectileDisplayObjectController.pause();						_weaponDisplayObjectController.pause();						_villagerDisplayObjectController.pause();						_enemyDisplayObjectController.pause();						_chickenDisplayObjectController.pause();						_effectsController.pause();					}				}							/** unpauseForGodAttack			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function unpauseForGodAttack():void				{					ConsoleBroadcaster.broadcast( "GameboardController", "unpauseForGodAttack();" );										if( _isPlaying && _isPaused )					{						_isPaused = false;												_gameboardReference.unpause();												if( _tricksterGodDurationTimer != null && _tricksterGodDurationTimer.isRunning )						{							_tricksterGodDurationTimer.unpause();						}												if( _warriorGodDurationTimer != null && _warriorGodDurationTimer.isRunning )						{							_warriorGodDurationTimer.unpause();						}												for( var i:int=0; i<_waveZoneControllers.length; ++i )						{							_waveZoneControllers[i].unpause();						}												_projectileDisplayObjectController.unpause();						_weaponDisplayObjectController.unpause();						_villagerDisplayObjectController.unpause();						_enemyDisplayObjectController.unpause();						_chickenDisplayObjectController.unpause();						_effectsController.unpause();					}				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "kill();" );										if( _mainLoopTimer != null )						_mainLoopTimer.stop();										if( _countdownTimer != null )					{						_countdownTimer.stop();						_countdownTimer.reset();						//_countdownTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, handleCountdownTimerCompleted );						//_countdownTimer = null;					}										if( _tricksterGodDurationTimer != null && _tricksterGodDurationTimer.isRunning )					{						_tricksterGodDurationTimer.stop();					}										_isPlaying = false;										if( _isPlayingBackgroundMusic )					{						_isPlayingBackgroundMusic = false;						SoundEffectPlayer.getInstance().stopSound( _currentBackgroundMusic, _currentBackgroundMusic, _currentBackgroundMusic, SoundEffectPlayer.SOUND_PLAYER_MUSIC );						_currentBackgroundMusic = "";					}										//GameLevelCurrentData.getInstance().kill();										if( !_isDiggingOnly )					{												if( _attackingDisplayObjectController != null )						{							_attackingDisplayObjectController.kill();							_attackingDisplayObjectController = null;						}												if( _waveZoneControllers != null )						{							for( var i:uint=0; i<_waveZoneControllers.length; ++i )							{								//"onEnemySpawned", handleEnemySpawned								//_waveZoneControllers[i].removeEventListener( "onEnemySpawned", handleEnemySpawned );								//_waveZoneControllers[i].removeEventListener( "onWaveZoneEnds", handleWaveZoneEnded );								_waveZoneControllers[i].onEnemySpawned.remove( handleEnemySpawned );								_waveZoneControllers[i].kill();								_waveZoneControllers[i] = null;							}														_waveZoneControllers = null;						}												if( _projectileDisplayObjectController != null )						{							//_projectileDisplayObjectController.removeEventListener( GameLevelEvent.CATAPULT_AMMO_HIT, handleCatapultAmmoHit );							_projectileDisplayObjectController.onCatapultAmmoHit.remove( handleCatapultAmmoHit );							_projectileDisplayObjectController.kill();							_projectileDisplayObjectController = null;						}												if( _godDisplayObjectController != null )						{							//_godDisplayObjectController.removeEventListener( GameLevelEvent.ON_GOD_ATTACK, handleGodAttacked );							//_godDisplayObjectController.removeEventListener( GameLevelEvent.ON_GOD_ATTACK_ENDED, handleGodAttackEnded );							_godDisplayObjectController.onGodAttacked.remove( handleGodAttacked );							_godDisplayObjectController.onGodAttackEnded.remove( handleGodAttackEnded );							_godDisplayObjectController.kill();							_godDisplayObjectController = null;						}												if( _weaponDisplayObjectController != null )						{							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.ATTACK_TIMER_FIRE, handleWeaponAttackTimerFired );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.PROJECTILE_FIRE, handleProjectileWeaponFired );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.CATAPULT_FIRE, handleCatapultWeaponFired );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.BOMB_EXPLODE, handleBombWeaponExploded );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.TRAP_FIRE, handleTrapWeaponFired );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.MULTIPLE_DIRECTIONS_PROJECTILE_FIRE, handleMultipleDirectionsProjectileWeaponFired );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.MOVING, handleFullLaneWeaponMoving );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.PATH_END, handleFullLaneWeaponPathEnded );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.MULTIPLE_WEAPONS_FIRE, handleMultipleWeaponsWeaponFired );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.DIE, handleWeaponDied );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.REMOVE_FROM_GAME, handleWeaponRemovedFromGame );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.ON_WEAPON_ROLLED_OVER, handleWeaponRolledOver );							//_weaponDisplayObjectController.removeEventListener( GameLevelEvent.ON_WEAPON_ROLLED_OUT, handleWeaponRolledOut );							_weaponDisplayObjectController.onWeaponAttackTimerFired.remove( handleWeaponAttackTimerFired );							_weaponDisplayObjectController.onProjectileWeaponFired.remove( handleProjectileWeaponFired );							_weaponDisplayObjectController.onCatapultWeaponFired.remove( handleCatapultWeaponFired );							//_weaponDisplayObjectController.onBombWeaponExploded.remove( handleBombWeaponExploded );							_weaponDisplayObjectController.onTrapWeaponFired.remove( handleTrapWeaponFired );							_weaponDisplayObjectController.onMultipleDirectionsProjectileWeaponFired.remove( handleMultipleDirectionsProjectileWeaponFired );							_weaponDisplayObjectController.onPathWeaponMovedToNextPoint.remove( handlePathWeaponMovedToNextPoint );							_weaponDisplayObjectController.onPathWeaponPathEnded.remove( handlePathWeaponPathEnded );							_weaponDisplayObjectController.onMultipleWeaponsWeaponFired.remove( handleMultipleWeaponsWeaponFired );							_weaponDisplayObjectController.onWeaponDied.remove( handleWeaponDied );							_weaponDisplayObjectController.onWeaponRolledOver.remove( handleWeaponRolledOver );							_weaponDisplayObjectController.onWeaponRolledOut.remove( handleWeaponRolledOut );							_weaponDisplayObjectController.kill();							_weaponDisplayObjectController = null;						}												if( _enemyDisplayObjectController != null )						{							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.MOVING_TO_NEXT_TILE, handleEnemyMovingToNextTile );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.MOVING_TO_NEXT_POINT, handleEnemyMovingToNextPoint );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.SPAWN_PATH_END, handleEnemyHitsEndOfSpawnPath );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.PATH_END, handleEnemyHitsEndOfPath );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.ATTACK_TIMER_FIRE, handleEnemyAttackTimerFired );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.PROJECTILE_FIRE, handleProjectileEnemyFired );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.CATAPULT_FIRE, handleCatapultEnemyFired );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.LASER_FIRE, handleLaserEnemyFired );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.LASER_HIT, handleLaserEnemyHit );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.LASER_STOP, handleLaserEnemyStopped );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.LAY_EGG, handleEggLayerEnemyLaidEgg );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.HATCH, handleEggEnemyHatched );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.LAND, handleJumpingEnemyLanded );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.DIE, handleEnemyDied );							//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.REMOVE_FROM_GAME, handleEnemyRemovedFromGame );							_enemyDisplayObjectController.onEnemyMovedToNextTile.remove( handleEnemyMovedToNextTile );							_enemyDisplayObjectController.onEnemyMovedToNextPoint.remove( handleEnemyMovedToNextPoint );							_enemyDisplayObjectController.onEnemySpawnPathEnded.remove( handleEnemySpawnPathEnded );							_enemyDisplayObjectController.onEnemySpawnPathReentered.remove( handleEnemySpawnPathReentered );							_enemyDisplayObjectController.onEnemyPathEnded.remove( handleEnemyPathEnded );							_enemyDisplayObjectController.onEnemyAttackTimerFired.remove( handleEnemyAttackTimerFired );							_enemyDisplayObjectController.onEnemyDied.remove( handleEnemyDied );							_enemyDisplayObjectController.onEnemyRemovedFromGame.remove( handleEnemyRemovedFromGame );							_enemyDisplayObjectController.onProjectileEnemyFired.remove( handleProjectileEnemyFired );							_enemyDisplayObjectController.onCatapultEnemyFired.remove( handleCatapultEnemyFired );							_enemyDisplayObjectController.onLaserEnemyFired.remove( handleLaserEnemyFired );							_enemyDisplayObjectController.onLaserEnemyHit.remove( handleLaserEnemyHit );							_enemyDisplayObjectController.onLaserEnemyStopped.remove( handleLaserEnemyStopped );							_enemyDisplayObjectController.onEggLayerEnemyLaidEgg.remove( handleEggLayerEnemyLaidEgg );							_enemyDisplayObjectController.onEggEnemyHatched.remove( handleEggEnemyHatched );							_enemyDisplayObjectController.kill();							_enemyDisplayObjectController = null;						}												if( _villagerDisplayObjectController != null )						{							_villagerDisplayObjectController.kill();							_villagerDisplayObjectController = null;						}												if( _chickenDisplayObjectController != null )						{							//_chickenDisplayObjectController.removeEventListener( GameLevelEvent.ON_CHICKEN_COLLECTED, handleChickenCollected );							//_chickenDisplayObjectController.removeEventListener( GameLevelEvent.ON_CHICKEN_OBTAINED_ANIMATION_COMPLETE, handleChickenObtainedAnimationComplete );							_chickenDisplayObjectController.onChickenObtainedAnimationCompleted.remove( handleChickenObtainedAnimationComplete );							_chickenDisplayObjectController.kill();							_chickenDisplayObjectController = null;						}												if( _effectsController != null )						{							_effectsController.kill();							_effectsController = null;						}					}										if( _gateDisplayObjectController != null )					{						//_gateDisplayObjectController.removeEventListener( GameLevelEvent.HIT, handleGateHit );						//_gateDisplayObjectController.removeEventListener( GameLevelEvent.DIE, handleGateDied );						//_gateDisplayObjectController.removeEventListener( GameLevelEvent.ON_GATE_REVIVED, handleGateRevived );						_gateDisplayObjectController.onGateHit.remove( handleGateHit );						_gateDisplayObjectController.onGateDied.remove( handleGateDied );						_gateDisplayObjectController.onGateRevived.remove( handleGateRevived );						_gateDisplayObjectController.kill();						_gateDisplayObjectController = null;					}										//_gameboardReference.removeEventListener( "onStartGameClicked", handleStartGameClicked );					//_gameboardReference.removeEventListener( "onPauseGameClicked", handlePauseGameClicked );					//_gameboardReference.removeEventListener( "onUnpauseGameClicked", handleUnpauseGameClicked );					//_gameboardReference.removeEventListener( "onFullScreenClicked", handleFullScreenClicked );					//_gameboardReference.removeEventListener( "onSlotSpinEnds", handleSlotSpinEnds );					//_gameboardReference.removeEventListener( "onWinPlayThrough", handleWinAnimationDone );					//_gameboardReference.removeEventListener( "onDigTreasure", handleTreasureDug );					//_gameboardReference.removeEventListener( "onDigResultExit", handleDigResultExit );					//_gameboardReference.removeEventListener( "onNewDiscoveriesExit", handleNewDiscoveriesExit );					_gameboardReference.kill();					//_gameboardReference = null;										EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_PLAY_VIEW_CONTROLS_SHOW, this );										MainGameController.getInstance().runGarbageCollector();				}							/** start			  *	---------------------------------------------------------------------------- *			  *	Starts the game.			  *	---------------------------------------------------------------------------- */			 	public function start():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "start();" );										MainGameController.getInstance().runGarbageCollector();										EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_FPS_CHECKER_STARTED, this );										_isDiggingOnly = false;										_gameboardReference.hideLoadingScreen();										//TODO:					//	Check the game level if we are introducing any new elements to the game										_isPlaying = true;					_isPaused = false;					_win = false;					_gameEnds = false;					_playingEndAnimation = false;					_inIsometricView = _gameboardReference.inIsometricView;										_totalWeapons = 0;					_enemiesSpawned = 0;					_totalGods = 0;										var i:int, j:int;										_totalEnemies = 0;					_distinctEnemiesInLevel = _gameLevel.distinctEnemiesInLevel;					for( i=0; i<_gameboardReference.enemyIconClips.length; ++i )					{						if( i<_distinctEnemiesInLevel.length )						{							_gameboardReference.enemyIconClips[i].setCount( _distinctEnemiesInLevel[i].enemy, _distinctEnemiesInLevel[i].quantity );							_gameboardReference.enemyIconClips[i].contentClip.visible = true;							_totalEnemies += _distinctEnemiesInLevel[i].quantity;						}						else						{							_gameboardReference.enemyIconClips[i].contentClip.visible = false;						}					}					_enemiesLeft = _totalEnemies;										//_gameLevelCurrentData = new GameLevelCurrentData();					//_gameLevelCurrentData.chickenCount = _gameLevel.startingChicken;					//_gameboardReference.chickenIndicator_mc.updateChickenAmount( _gameLevelCurrentData.chickenCount );					GameLevelCurrentData.getInstance().chickenCount = _gameLevel.startingChicken;					//_gameboardReference.chickenIndicator_mc.updateChickenAmount( _gameLevelCurrentData.chickenCount );										_enemyDisplayObjectController = new EnemyDisplayObjectController();					_enemyDisplayObjectController.gameboardReference = _gameboardReference;					_enemyDisplayObjectController.weaponDisplayObjectController = _weaponDisplayObjectController;					_enemyDisplayObjectController.gameboardController = this;					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.MOVING_TO_NEXT_TILE, handleEnemyMovingToNextTile, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.MOVING_TO_NEXT_POINT, handleEnemyMovingToNextPoint, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.SPAWN_PATH_END, handleEnemyHitsEndOfSpawnPath, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.PATH_END, handleEnemyHitsEndOfPath, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.ATTACK_TIMER_FIRE, handleEnemyAttackTimerFired, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.PROJECTILE_FIRE, handleProjectileEnemyFired, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.CATAPULT_FIRE, handleCatapultEnemyFired, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.LASER_FIRE, handleLaserEnemyFired, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.LASER_HIT, handleLaserEnemyHit, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.LASER_STOP, handleLaserEnemyStopped, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.LAY_EGG, handleEggLayerEnemyLaidEgg, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.HATCH, handleEggEnemyHatched, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.LAND, handleJumpingEnemyLanded, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.DIE, handleEnemyDied, false, 0, true );					//_enemyDisplayObjectController.addEventListener( GameLevelEvent.REMOVE_FROM_GAME, handleEnemyRemovedFromGame, false, 0, true );					_enemyDisplayObjectController.onEnemyMovedToNextTile.add( handleEnemyMovedToNextTile );					_enemyDisplayObjectController.onEnemyMovedToNextPoint.add( handleEnemyMovedToNextPoint );					_enemyDisplayObjectController.onEnemySpawnPathEnded.add( handleEnemySpawnPathEnded );					_enemyDisplayObjectController.onEnemySpawnPathReentered.add( handleEnemySpawnPathReentered );					_enemyDisplayObjectController.onEnemyPathEnded.add( handleEnemyPathEnded );					_enemyDisplayObjectController.onEnemyAttackTimerFired.add( handleEnemyAttackTimerFired );					_enemyDisplayObjectController.onEnemyDied.add( handleEnemyDied );					_enemyDisplayObjectController.onEnemyRemovedFromGame.add( handleEnemyRemovedFromGame );					_enemyDisplayObjectController.onProjectileEnemyFired.add( handleProjectileEnemyFired );					_enemyDisplayObjectController.onCatapultEnemyFired.add( handleCatapultEnemyFired );					_enemyDisplayObjectController.onLaserEnemyFired.add( handleLaserEnemyFired );					_enemyDisplayObjectController.onLaserEnemyHit.add( handleLaserEnemyHit );					_enemyDisplayObjectController.onLaserEnemyStopped.add( handleLaserEnemyStopped );					_enemyDisplayObjectController.onEggLayerEnemyLaidEgg.add( handleEggLayerEnemyLaidEgg );					_enemyDisplayObjectController.onEggEnemyHatched.add( handleEggEnemyHatched );										_weaponDisplayObjectController = new WeaponDisplayObjectController();					_weaponDisplayObjectController.gameboardReference = _gameboardReference;					_weaponDisplayObjectController.enemyDisplayObjectController = _enemyDisplayObjectController;					_weaponDisplayObjectController.gameboardController = this;					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.ATTACK_TIMER_FIRE, handleWeaponAttackTimerFired, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.PROJECTILE_FIRE, handleProjectileWeaponFired, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.CATAPULT_FIRE, handleCatapultWeaponFired, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.BOMB_EXPLODE, handleBombWeaponExploded, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.TRAP_FIRE, handleTrapWeaponFired, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.MULTIPLE_DIRECTIONS_PROJECTILE_FIRE, handleMultipleDirectionsProjectileWeaponFired, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.MOVING, handleFullLaneWeaponMoving, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.PATH_END, handleFullLaneWeaponPathEnded, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.MULTIPLE_WEAPONS_FIRE, handleMultipleWeaponsWeaponFired, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.DIE, handleWeaponDied, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.ON_WEAPON_ROLLED_OVER, handleWeaponRolledOver, false, 0, true );					//_weaponDisplayObjectController.addEventListener( GameLevelEvent.ON_WEAPON_ROLLED_OUT, handleWeaponRolledOut, false, 0, true );					_weaponDisplayObjectController.onWeaponAttackTimerFired.add( handleWeaponAttackTimerFired );					_weaponDisplayObjectController.onProjectileWeaponFired.add( handleProjectileWeaponFired );					_weaponDisplayObjectController.onCatapultWeaponFired.add( handleCatapultWeaponFired );					//_weaponDisplayObjectController.onBombWeaponExploded.add( handleBombWeaponExploded );					_weaponDisplayObjectController.onTrapWeaponFired.add( handleTrapWeaponFired );					_weaponDisplayObjectController.onMultipleDirectionsProjectileWeaponFired.add( handleMultipleDirectionsProjectileWeaponFired );					_weaponDisplayObjectController.onPathWeaponMovedToNextPoint.add( handlePathWeaponMovedToNextPoint );					_weaponDisplayObjectController.onPathWeaponPathEnded.add( handlePathWeaponPathEnded );					_weaponDisplayObjectController.onMultipleWeaponsWeaponFired.add( handleMultipleWeaponsWeaponFired );					_weaponDisplayObjectController.onWeaponDied.add( handleWeaponDied );					_weaponDisplayObjectController.onWeaponRolledOver.add( handleWeaponRolledOver );					_weaponDisplayObjectController.onWeaponRolledOut.add( handleWeaponRolledOut );										_villagerDisplayObjectController = new VillagerDisplayObjectController();					_villagerDisplayObjectController.gameboardReference = _gameboardReference;					_villagerDisplayObjectController.gameboardController = this;					//_villagerDisplayObjectController.start();										//trace( "villager objects length "+_gameLevel.villagerObjects.length );					//var villagerDisplayObject:VillagerDisplayObject;					for( i=0; i<_gameLevel.villagerObjects.length; ++i )					{						//villagerDisplayObject = new VillagerDisplayObject();						//villagerDisplayObject.contentClip = new (getDefinitionByName("VillagerDisplayObjectLibrary") as Class)();						//villagerDisplayObject.init();						addVillager( _gameLevel.villagerObjects[i] );												if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevel && _gameLevel.villagerObjects[i].villagerId == 3 )						{							_villagerDisplayObjectController.villagerDisplayObjects[ _villagerDisplayObjectController.villagerDisplayObjectsLength-1 ].contentClip.visible = false;							//EventNotificationCenter.getInstance().addEventListener( "onStopVillagerRunningSound", handleVillagerStopRunning, false, 0, true );							//_gameboardReference.introAnimationViewClip.onTutorialLevelVillagerRunningStopped.add( handleVillagerRunningStopped );						}					}										_godDisplayObjectController = new GodDisplayObjectController();					_godDisplayObjectController.gameboardController = this;					_godDisplayObjectController.gameboardReference = _gameboardReference;					_godDisplayObjectController.initAttackPoints();					//_godDisplayObjectController.addEventListener( GameLevelEvent.ON_GOD_ATTACK, handleGodAttacked, false, 0, true );					//_godDisplayObjectController.addEventListener( GameLevelEvent.ON_GOD_ATTACK_ENDED, handleGodAttackEnded, false, 0, true );					_godDisplayObjectController.onGodAttacked.add( handleGodAttacked );					_godDisplayObjectController.onGodAttackEnded.add( handleGodAttackEnded );										_spawnPaths = new Vector.<Vector.<GameboardTile>>;										_attackingDisplayObjectController = new AttackingDisplayObjectController();					//_attackingDisplayObjectController.addPaths( _gameLevel.paths );					//var tilePaths:Array = new Array();					_tilePaths = new Vector.<Vector.<GameboardTile>>;					for( i=0; i<_gameLevel.paths.length; ++i )					{						//Get the actual tile paths instead of just row/column object						//trace( "tilePaths: "+_gameboardReference.getTilesForPath( _gameLevel.paths[i] ) );						_tilePaths.push( _gameboardReference.getTilesForPath( _gameLevel.paths[i] ) );											}										_attackingDisplayObjectController.addPaths( _tilePaths );					/*					for( i=0; i<8; ++i )					{						_gameboardReference.tiles[0][i].hasExtraHitArea1 = true;												if( i != 0 && _gameboardReference.tiles[0][i-1].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[0][i].hasExtraHitArea4 = true;						}												if( i != 7 && _gameboardReference.tiles[0][i+1].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[0][i].hasExtraHitArea2 = true;						}												//trace( "tile "+_gameboardReference.tiles[0][i] );						//trace( "left extra hit area: "+_gameboardReference.tiles[0][i].hasExtraHitArea4 );						//trace( "right extra hit area: "+_gameboardReference.tiles[0][i].hasExtraHitArea2 );						//trace( "---" );					}					*/					/*					for( i=0; i<GameLevelDataIndex.getInstance().boardMaxRows; ++i )					{						for( j=0; j<GameLevelDataIndex.getInstance().boardMaxColumns; ++j )						{							if( _gameboardReference.tiles[i][j].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )							{								if( j == 0 || _gameboardReference.tiles[i][j-1].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )								{									_gameboardReference.tiles[i][j].hasExtraHitArea4 = true;								}																if( j == GameLevelDataIndex.getInstance().boardMaxColumns-1 || _gameboardReference.tiles[i][j+1].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )								{									_gameboardReference.tiles[i][j].hasExtraHitArea2 = true;								}																if( i == 0 || _gameboardReference.tiles[i-1][j].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )								{									_gameboardReference.tiles[i][j].hasExtraHitArea1 = true;								}																if( i == GameLevelDataIndex.getInstance().boardMaxRows-1 || _gameboardReference.tiles[i+1][j].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )								{									_gameboardReference.tiles[i][j].hasExtraHitArea3 = true;								}							}														//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea1: "+_gameboardReference.tiles[i][j].hasExtraHitArea1 );							//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea2: "+_gameboardReference.tiles[i][j].hasExtraHitArea2 );							//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea3: "+_gameboardReference.tiles[i][j].hasExtraHitArea3 );							//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea4: "+_gameboardReference.tiles[i][j].hasExtraHitArea4 );						}					}					*/					toggleTilesExtraHitArea( true );										initGates();					for( i=0; i<_gateDisplayObjectController.gateDisplayObjects.length; ++i )					{						_attackingDisplayObjectController.addGate( _gateDisplayObjectController.gateDisplayObjects[i] );					}										_projectileDisplayObjectController = new ProjectileDisplayObjectController();					_projectileDisplayObjectController.gameboardController = this;					_projectileDisplayObjectController.gameboardReference = _gameboardReference;					_projectileDisplayObjectController.enemyDisplayObjectController = _enemyDisplayObjectController;					_projectileDisplayObjectController.weaponDisplayObjectController = _weaponDisplayObjectController;					_projectileDisplayObjectController.gateDisplayObjectController = _gateDisplayObjectController;					//_projectileDisplayObjectController.addEventListener( GameLevelEvent.CATAPULT_AMMO_HIT, handleCatapultAmmoHit, false, 0, true );					_projectileDisplayObjectController.onCatapultAmmoHit.add( handleCatapultAmmoHit );															_chickenDisplayObjectController = new ChickenDisplayObjectController();					//_chickenDisplayObjectController.gameboardReference = _gameboardReference;					//_chickenDisplayObjectController.addEventListener( GameLevelEvent.ON_CHICKEN_COLLECTED, handleChickenCollected, false, 0, true );					//_chickenDisplayObjectController.addEventListener( GameLevelEvent.ON_CHICKEN_OBTAINED_ANIMATION_COMPLETE, handleChickenObtainedAnimationComplete, false, 0, true );					_chickenDisplayObjectController.onChickenObtainedAnimationCompleted.add( handleChickenObtainedAnimationComplete );					_chickenDisplayObjectController.gameboardController = this;					_chickenDisplayObjectController.gameboardReference = _gameboardReference;										_effectsController = new EffectsController();					_effectsController.gameboardReference = _gameboardReference;					_effectsController.standardRenderer = _gameboardReference.effectClipsContainer_mc;										_waveZoneControllers = new Vector.<WaveZoneController>;										var waveZoneController:WaveZoneController;										for( i=0; i<_gameLevel.waveZones.length; ++i )					{						for( j=0; j<_tilePaths.length; ++j )						{							//trace( "_tilePaths["+j+"][0].row: "+_tilePaths[j][0].row+", column: "+_tilePaths[j][0].column );														if( i == 0 && _tilePaths[j][0].column == GameLevelDataIndex.getInstance().boardMaxColumns-1 )							{								_gameLevel.waveZones[i].paths.push( _tilePaths[j] );								_gameLevel.waveZones[i].spawnPaths.push( _gameboardReference.getTilesForSpawnPath( _gameLevel.spawnPaths[j].path, _gameLevel.spawnPaths[j].area ) );								//trace( "adding path to wave zone 1" );							}							else if( i == 1 && _tilePaths[j][0].row == GameLevelDataIndex.getInstance().boardMaxRows-1 )							{								//trace( "adding path to wave zone 2" );								_gameLevel.waveZones[i].paths.push( _tilePaths[j] );								_gameLevel.waveZones[i].spawnPaths.push( _gameboardReference.getTilesForSpawnPath( _gameLevel.spawnPaths[j].path, _gameLevel.spawnPaths[j].area ) );							}							else if( i == 2 && _tilePaths[j][0].column == 0 )							{								//trace( "adding path to wave zone 3" );								_gameLevel.waveZones[i].paths.push( _tilePaths[j] );								_gameLevel.waveZones[i].spawnPaths.push( _gameboardReference.getTilesForSpawnPath( _gameLevel.spawnPaths[j].path, _gameLevel.spawnPaths[j].area ) );							}						}											waveZoneController = new WaveZoneController();						waveZoneController.waveZone = _gameLevel.waveZones[i];						//waveZoneController.addEventListener( "onEnemySpawned", handleEnemySpawned, false, 0, true );						//waveZoneController.addEventListener( "onWaveZoneEnds", handleWaveZoneEnded, false, 0, true );						waveZoneController.onEnemySpawned.add( handleEnemySpawned );												//trace( "waveZone totalNumberOfEnemies: "+waveZoneController.waveZone.totalNumberOfEnemies );												_waveZoneControllers.push( waveZoneController );					}										_gameboardReference.slotMachineClip.slotMachine = new SlotMachine();					_gameboardReference.slotMachineClip.slotMachine.winningProbability = _gameLevel.slotWinningProbability;					_gameboardReference.start();										_chickenDisplayObjectController.initChickenMovementAreas();										if( MainGameController.getInstance().currentUser.tutorialGameLevel )					{						EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_PLAY_VIEW_CONTROLS_HIDE, this );						//_gameboardReference.gameboardMenuClip.hide();						//_gameboardReference.chickenIndicator_mc.visible = false;						_gameboardReference.hideGameboardMenu();					}										//_gameboardReference.addEventListener( Event.ENTER_FRAME, handleMainEnterFrameFired, false, 0, true );					if( _mainLoopTimer == null )					{						_mainLoopTimer = new CustomTimer( 33 );						//_mainLoopTimer.addEventListener( TimerEvent.TIMER, handleMainLoopTimerFired );						_mainLoopTimer.onTimerFired.add( handleMainLoopTimerFired );					}					GameLevelDataIndex.getInstance().currentCounter = 0;					_mainLoopTimer.start();										//If row == -1					//	This tile belongs 										if( _countdownTimer == null )					{						_countdownTimer = new CustomTimer( 100, 1 );						//_countdownTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleCountdownTimerCompleted, false, 0, true );						_countdownTimer.onTimerCompleted.add( handleCountdownTimerCompleted );					}										_countdownTimer.start();				}							/** end			  *	---------------------------------------------------------------------------- *			  *	Ends the game.			  *	---------------------------------------------------------------------------- */			 	public function end( win:Boolean=false ):void				{					//trace( "GameboardController: ------------------- end();" );										EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_FPS_CHECKER_STOPPED, this );										_countdownTimer.stop();										stopShakingGameboardForGod();										if( _isPlaying )					{						_elapsedTime.stopIt();												var gateIndex:int;						var gatesRemainingHealth:Array = [];						for( gateIndex=0; gateIndex<_gateDisplayObjectController.gateDisplayObjects.length; ++gateIndex )						{							if( _gateDisplayObjectController.gateDisplayObjects[gateIndex].isInPath )							{								//trace( "health: "+Gate(_gateDisplayObjectController.gateDisplayObjects[gateIndex].attackingGameObject).health );								//trace( "maxHealth: "+Gate(_gateDisplayObjectController.gateDisplayObjects[gateIndex].attackingGameObject).maxHealth );								gatesRemainingHealth.push( {gate:gateIndex, percentage:int(Gate(_gateDisplayObjectController.gateDisplayObjects[gateIndex].attackingGameObject).health / Gate(_gateDisplayObjectController.gateDisplayObjects[gateIndex].attackingGameObject).maxHealth * 100)} );							}						}												//trace( "elapsedTiem: "+_elapsedTime.elapsedTime );												trace( '_enemiesLeft: '+_enemiesLeft );												//We can put tracking for saveTrackingGameLevel here						var trackingDataController:TrackingDataController = new TrackingDataController();							trackingDataController.saveTrackingGameLevel( MainGameController.getInstance().currentUser.id, _gameLevel.id, gatesRemainingHealth, GameLevelCurrentData.getInstance().chickenCount, _elapsedTime.elapsedTime, win, 100-int(_enemiesLeft/_totalEnemies*100) );												if( _isPlayingBackgroundMusic )						{							_isPlayingBackgroundMusic = false;							SoundEffectPlayer.getInstance().stopSound( _currentBackgroundMusic, _currentBackgroundMusic, _currentBackgroundMusic, SoundEffectPlayer.SOUND_PLAYER_MUSIC );							_currentBackgroundMusic = "";						}												for( var i:int=0; i<_waveZoneControllers.length; ++i )						{							_waveZoneControllers[i].pause();						}												//_gameboardReference.removeEventListener( Event.ENTER_FRAME, handleMainEnterFrameFired );						//_mainLoopTimer.stop();						//_mainLoopTimer.removeEventListener( TimerEvent.TIMER, handleMainLoopTimerFired );						//_mainLoopTimer = null;												_projectileDisplayObjectController.pause();						_weaponDisplayObjectController.pause();						_weaponDisplayObjectController.disableInteraction();						_enemyDisplayObjectController.pause();						_chickenDisplayObjectController.pause();						_chickenDisplayObjectController.removeAllChickens();						_villagerDisplayObjectController.pause();						_gateDisplayObjectController.pause();						_godDisplayObjectController.pause();						//_effectsController.pause();												EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_SMALL_ADVENTURE_LEVEL_HIDE, this );												var playWinAnimation:Boolean = (MainGameController.getInstance().currentUser.currentVillageId != 1);												_gameboardReference.end( win, playWinAnimation );												_isPlaying = false;						_isPaused = false;						_win = win;												_gameEnds = true;						_playingEndAnimation = true;												if( _win )						{							if( _currentVillage != null )							{								if( MainGameController.getInstance().currentUser.getDiggingMap(_currentVillage.id) == null )								{									var diggingMap:DiggingMap = _gameLevel.diggingSpots.generateDiggingMap();										diggingMap.villageId = _currentVillage.id;										diggingMap.countTreasures();									MainGameController.getInstance().currentUser.saveDiggingMap( diggingMap );									diggingMap = null;								}								/*								if( _currentVillage.cryptologyId != 0 && !MainGameController.getInstance().currentUser.isItemUnlocked(MainGameDataIndex.getInstance().getCryptology(_currentVillage.cryptologyId)) )								{									ConsoleBroadcaster.broadcast( "GameboardController", "user unlocks cryptology "+_currentVillage.cryptologyId );									MainGameController.getInstance().addUnlockedCryptology( _currentVillage.cryptologyId );									_gameboardReference.newDiscoveriesViewClip.addNewDiscoveryItem( MainGameDataIndex.getInstance().getCryptology(_currentVillage.cryptologyId) );								}								else								{									ConsoleBroadcaster.broadcast( "GameboardController", "user already has cryptology "+_currentVillage.cryptologyId );								}								*/							}														var unlockedIds:Array = new Array();							var weapon:Weapon;							//trace( "checking weapon with a level "+(_gameLevel.level+1) );							var currentUser:User = MainGameController.getInstance().currentUser;							for( i=0; i<GameLevelDataIndex.getInstance().weapons.length; ++i )							{								weapon = GameLevelDataIndex.getInstance().weapons[i];								//trace( "weapon id: "+weapon.id );								//trace( "weapon availableOnLevel: "+weapon.availableOnLevel );								if( weapon.availableOnLevel <= (_gameLevel.level+1) && !MainGameController.getInstance().currentUser.isItemUnlocked(weapon) && weapon.listed )								{									trace( "adding weapon "+weapon.id );									unlockedIds.push( weapon.id );									_gameboardReference.newDiscoveriesViewClip.addNewDiscoveryItem( weapon );								}							}							weapon = null;														if( unlockedIds.length > 0 )							{								MainGameController.getInstance().addUnlockedWeapons( unlockedIds );							}														ArrayUtil.removeAll( unlockedIds );							var god:God;							for( i=0; i<GameLevelDataIndex.getInstance().godsCount; ++i )							{								god = GameLevelDataIndex.getInstance().gods[i];								if( god.availableOnLevel <= (_gameLevel.level+1) && !MainGameController.getInstance().currentUser.isItemUnlocked(god) )								{									trace( "adding god "+god.id );									unlockedIds.push( god.id );									_gameboardReference.newDiscoveriesViewClip.addNewDiscoveryItem( god );								}							}							god = null;														if( unlockedIds.length > 0 )							{								MainGameController.getInstance().addUnlockedGods( unlockedIds );							}														//unlockedIds = new Array();							ArrayUtil.removeAll( unlockedIds );							var enemy:Enemy;							for( i=0; i<GameLevelDataIndex.getInstance().enemiesCount; ++i )							{								/*								if( !MainGameController.getInstance().currentUser.isItemUnlocked( GameLevelDataIndex.getInstance().getEnemy(_gameLevel.distinctEnemiesInLevel[i].enemy) ) )								{									//MainGameController.getInstance().currentUser.addUnlo									unlockedIds.push( _gameLevel.distinctEnemiesInLevel[i].enemy );									trace( "adding enemy "+_gameLevel.distinctEnemiesInLevel[i].enemy );									_gameboardReference.newDiscoveriesViewClip.addNewDiscoveryItem( GameLevelDataIndex.getInstance().getEnemy(_gameLevel.distinctEnemiesInLevel[i].enemy) );								}								*/								enemy =  GameLevelDataIndex.getInstance().enemies[i];								//trace( "enemy.availableOnLevel: "+enemy.availableOnLevel );								if( enemy.availableOnLevel <= (_gameLevel.level+1) && !MainGameController.getInstance().currentUser.isItemUnlocked(enemy) && enemy.listed )								{									trace( "adding enemy "+enemy.id );									unlockedIds.push( enemy.id );									_gameboardReference.newDiscoveriesViewClip.addNewDiscoveryItem( enemy );								}							}							enemy = null;														if( unlockedIds.length > 0 )							{								MainGameController.getInstance().addUnlockedEnemies( unlockedIds );							}						}												dispatchEvent( new GameLevelEvent(GameLevelEvent.GAME_END, {win:_win}) );												if( !playWinAnimation )							handleWinAnimationDone(null);					}									}							/** showDiggingLevel			  *	---------------------------------------------------------------------------- *			  *	Shows the digging part			  *	---------------------------------------------------------------------------- */			 	public function showDiggingLevel():void				{					ConsoleBroadcaster.broadcast( "GameboardController", "showDiggigngLevel();" );										_isDiggingOnly = true;					_inIsometricView = _gameboardReference.inIsometricView;										initGates();										//_gameboardReference.addEventListener( Event.ENTER_FRAME, handleMainEnterFrameFired, false, 0, true );					if( _mainLoopTimer == null )					{						_mainLoopTimer = new CustomTimer( 33 );						//_mainLoopTimer.addEventListener( TimerEvent.TIMER, handleMainLoopTimerFired );						_mainLoopTimer.onTimerFired.add( handleMainLoopTimerFired );					}										_mainLoopTimer.start();										_gameboardReference.highlightDiggingTiles( _diggingMap );				}							/** hideDiggingLevel			  *	---------------------------------------------------------------------------- *			  *	Hides the digging level of the level.			  *	---------------------------------------------------------------------------- */			 	public function hideDiggingLevel():void				{					ConsoleBroadcaster.broadcast( "GameboardController", "hideDiggigngLevel();" );										//_gameboardReference.removeEventListener( Event.ENTER_FRAME, handleMainEnterFrameFired );					_mainLoopTimer.stop();					//_mainLoopTimer.removeEventListener( TimerEvent.TIMER, handleMainLoopTimerFired );					//_mainLoopTimer = null;										_isDiggingOnly = false;					//_gameboardReference.kill();										kill();				}							/** initGates			  *	---------------------------------------------------------------------------- *			  *	Initializes the gate components in the map.			  *	---------------------------------------------------------------------------- */			 	protected function initGates():void				{					var i:int;										_gateDisplayObjectController = new GateDisplayObjectController();					_gateDisplayObjectController.gameboardReference = _gameboardReference;					_gateDisplayObjectController.gameboardController = this;					//_gateDisplayObjectController.addEventListener( GameLevelEvent.HIT, handleGateHit, false, 0, true );					//_gateDisplayObjectController.addEventListener( GameLevelEvent.DIE, handleGateDied, false, 0, true );					//_gateDisplayObjectController.addEventListener( GameLevelEvent.ON_GATE_REVIVED, handleGateRevived, false, 0, true );					_gateDisplayObjectController.onGateHit.add( handleGateHit );					_gateDisplayObjectController.onGateDied.add( handleGateDied );					_gateDisplayObjectController.onGateRevived.add( handleGateRevived );										var gate:Gate;// = new Gate();						//gate.health = _gameLevel.gateHealth;					var gateDisplayObject:GateDisplayObject;										for( i=0; i<_gameboardReference.gateTiles.length; ++i )					{						gate = new Gate();						gate.health = _gameLevel.gateHealth;												switch( i )						{							case 0:							case 2:							case 6:								//Piece 1								gate.animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId( "Fence_Piece1" );								break;														case 1:							case 5:							case 7:								//Piece 2								gate.animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId( "Fence_Piece2" );								break;														case 3:								//Left Door								gate.animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId( "Fence_LeftDoor" );								break;														case 4:								//Right Door								gate.animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId( "Fence_RightDoor" );								break;													}												gateDisplayObject = new GateDisplayObject();						gateDisplayObject.contentClip = new (getDefinitionByName("GateDisplayObjectLibrary") as Class)();						gateDisplayObject.init();						gateDisplayObject.attackingGameObject = gate;												if( i == 3 )							gateDisplayObject.initLeftGateFire();						else if( i == 4 )							gateDisplayObject.initRightGateFire();												gateDisplayObject.currentTile = _gameboardReference.gateTiles[i];						gateDisplayObject.inIsometricView = this._inIsometricView;												if( _gameLevel.isPath(i) ) gateDisplayObject.isInPath = true;												//trace( "gate piece on row "+i+" is alive ? "+gateDisplayObject.alive );						//trace( "gateDisplayObject on "+gateDisplayObject.currentTile.positionIn2D );												//GateDisplayObject(_gameboardReference.gateTiles[i]).gate = gate;												if( i == 3 && !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevel )						{							//gateDisplayObject.contentClip.visible = false;							gateDisplayObject.hideLeftGateForTutorial();						}												_gateDisplayObjectController.addGate( gateDisplayObject );					}									}											/** toggleFullScreen			  *	---------------------------------------------------------------------------- *			  *	Toggles full screen on/off depending on the current state.			  *	---------------------------------------------------------------------------- */			 	public function toggleFullScreen():void				{					if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialFullScreen )					{						EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );						EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE_FULL_SCREEN, this );												MainGameController.getInstance().currentUser.tutorialFullScreen = false;												unpauseForGodAttack();												var userDataController:UserDataController = new UserDataController();							userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "full_screen", 0 );					}										if( _gameboardReference.contentClip.stage.displayState == StageDisplayState.NORMAL )					{						ConsoleBroadcaster.broadcast( "GameboardController", "full screen rect: "+_gameboardReference.contentClip.stage.fullScreenSourceRect );						MainGameDataIndex.getInstance().isFullScreen = true;												//MainGameDataIndex.getInstance().outOfBoundsRectangle = _gameboardReference.contentClip.stage.fullScreenSourceRect;						/*						if( Capabilities.screenResolutionX > MainGameDataIndex.getInstance().outOfBoundsRectangle.width && Capabilities.screenResolutionY > MainGameDataIndex.getInstance().outOfBoundsRectangle.height )						{							_gameboardReference.contentClip.stage.fullScreenSourceRect = new Rectangle( MainGameDataIndex.getInstance().outOfBoundsRectangle.x, MainGameDataIndex.getInstance().outOfBoundsRectangle.y, MainGameDataIndex.getInstance().outOfBoundsRectangle.width, MainGameDataIndex.getInstance().outOfBoundsRectangle.height );							_gameboardReference.contentClip.stage.scaleMode = StageScaleMode.NO_BORDER;						}						else						{							_gameboardReference.contentClip.stage.scaleMode = StageScaleMode.NO_SCALE;						}												_gameboardReference.contentClip.stage.fullScreenSourceRect = _gameboardReference.backgroundContainer_mc.getBounds(_gameboardReference.contentClip.stage);						*/						ConsoleBroadcaster.broadcast( "GameboardController", "background bounds "+_gameboardReference.backgroundContainer_mc.getBounds(_gameboardReference.contentClip.stage) );						_gameboardReference.contentClip.stage.displayState = StageDisplayState.FULL_SCREEN_INTERACTIVE;												ConsoleBroadcaster.broadcast( "GameboardController", "out of bounds rect: "+MainGameDataIndex.getInstance().outOfBoundsRectangle );					}					else					{						_gameboardReference.contentClip.stage.displayState = StageDisplayState.NORMAL;						MainGameDataIndex.getInstance().isFullScreen = false;						//MainGameDataIndex.getInstance().outOfBoundsRectangle = new Rectangle( 0, 0, _gameboardReference.contentClip.stage.stageWidth, _gameboardReference.contentClip.stage.stageHeight );					}										//MainGameDataIndex.getInstance().outOfBoundsRectangle = _gameboardReference.backgroundContainer_mc.getBounds(_gameboardReference.contentClip.stage);										ConsoleBroadcaster.broadcast( "GameboardController", "MainGameDataIndex.getInstance().outOfBoundsRectangle: "+MainGameDataIndex.getInstance().outOfBoundsRectangle );									}								public function toggleTilesExtraHitArea( defaultLevelSetting:Boolean ):void				{					//if( defaultLevelSetting == _defaultTilesExtraHitAreaSetting )						//return;										//trace( 'toggleTilesExtraHitArea('+defaultLevelSetting+');' );										_defaultTilesExtraHitAreaSetting = defaultLevelSetting;										var i:int, j:int;										if( _defaultTilesExtraHitAreaSetting )					{						for( i=0; i<GameLevelDataIndex.getInstance().boardMaxRows; ++i )						{							for( j=0; j<GameLevelDataIndex.getInstance().boardMaxColumns; ++j )							{								if( _gameboardReference.tiles[i][j].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )								{									if( j == 0 || _gameboardReference.tiles[i][j-1].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )									{										_gameboardReference.tiles[i][j].hasExtraHitArea4 = true;									}									else// if( j != 0 && _gameboardReference.tiles[i][j-1].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )									{										_gameboardReference.tiles[i][j].hasExtraHitArea4 = false;									}																		if( j == GameLevelDataIndex.getInstance().boardMaxColumns-1 || _gameboardReference.tiles[i][j+1].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )									{										_gameboardReference.tiles[i][j].hasExtraHitArea2 = true;									}									else									{										_gameboardReference.tiles[i][j].hasExtraHitArea2 = false;									}																		if( i == 0 || _gameboardReference.tiles[i-1][j].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )									{										_gameboardReference.tiles[i][j].hasExtraHitArea1 = true;									}									else									{										_gameboardReference.tiles[i][j].hasExtraHitArea1 = false;									}																		if( i == GameLevelDataIndex.getInstance().boardMaxRows-1 || _gameboardReference.tiles[i+1][j].tileTypeIndex != GameboardTile.TILE_TYPE_PATH_INDEX )									{										_gameboardReference.tiles[i][j].hasExtraHitArea3 = true;									}									else									{										_gameboardReference.tiles[i][j].hasExtraHitArea3 = false;									}								}																//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea1: "+_gameboardReference.tiles[i][j].hasExtraHitArea1 );								//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea2: "+_gameboardReference.tiles[i][j].hasExtraHitArea2 );								//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea3: "+_gameboardReference.tiles[i][j].hasExtraHitArea3 );								//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea4: "+_gameboardReference.tiles[i][j].hasExtraHitArea4 );							}						}					}					else					{						for( i=0; i<GameLevelDataIndex.getInstance().boardMaxRows; ++i )						{							for( j=0; j<GameLevelDataIndex.getInstance().boardMaxColumns; ++j )							{								if( _gameboardReference.tiles[i][j].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )								{									if( j != 0 && _gameboardReference.tiles[i][j-1].occupiedByWeapon )									{										_gameboardReference.tiles[i][j].hasExtraHitArea4 = true;									}																		if( j != GameLevelDataIndex.getInstance().boardMaxColumns-1 && _gameboardReference.tiles[i][j+1].occupiedByWeapon )									{										_gameboardReference.tiles[i][j].hasExtraHitArea2 = true;									}																		if( i != 0 && _gameboardReference.tiles[i-1][j].occupiedByWeapon )									{										_gameboardReference.tiles[i][j].hasExtraHitArea1 = true;									}																		if( i != GameLevelDataIndex.getInstance().boardMaxRows-1 && _gameboardReference.tiles[i+1][j].occupiedByWeapon )									{										_gameboardReference.tiles[i][j].hasExtraHitArea3 = true;									}																		//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea1: "+_gameboardReference.tiles[i][j].hasExtraHitArea1 );									//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea2: "+_gameboardReference.tiles[i][j].hasExtraHitArea2 );									//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea3: "+_gameboardReference.tiles[i][j].hasExtraHitArea3 );									//trace( _gameboardReference.tiles[i][j]+" hasExtraHitArea4: "+_gameboardReference.tiles[i][j].hasExtraHitArea4 );								}							}						}						/*						if( tile.row != 0 && _gameboardReference.tiles[tile.row-1][tile.column].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX && _gameboardRe )						{							_gameboardReference.tiles[tile.row-1][tile.column].hasExtraHitArea3 = true;							//trace( _gameboardReference.tiles[tile.row-1][tile.column]+' hasExtraHitArea3' );						}												if( tile.row != GameLevelDataIndex.getInstance().boardMaxRows-1 && _gameboardReference.tiles[tile.row+1][tile.column].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[tile.row+1][tile.column].hasExtraHitArea1 = true;							//trace( _gameboardReference.tiles[tile.row+1][tile.column]+' hasExtraHitArea1' );						}												if( tile.column != 0 && _gameboardReference.tiles[tile.row][tile.column-1].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[tile.row][tile.column-1].hasExtraHitArea4 = true;							//trace( _gameboardReference.tiles[tile.row][tile.column-1]+' hasExtraHitArea' );						}												if( tile.column != GameLevelDataIndex.getInstance().boardMaxColumns-1 && _gameboardReference.tiles[tile.row][tile.column+1].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[tile.row][tile.column+1].hasExtraHitArea2 = true;							//trace( _gameboardReference.tiles[tile.row][tile.column+1]+' hasExtraHitArea2' );						}						*/					}				}							/** handleCountdownTimerCompleted			  *	---------------------------------------------------------------------------- *			  *	When the countdown timer before level starts complete, game will start.			  *	---------------------------------------------------------------------------- */			 	protected function handleCountdownTimerCompleted( timer:CustomTimer ):void				{					//trace( "handleCountdownTimerCompleted();" );										//trace( _waveZoneControllers.length );										_countdownTimer.stop();					_countdownTimer.reset();					//_countdownTimer.reset();					//_countdownTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, handleCountdownTimerCompleted );					//_countdownTimer = null;					//_countdownTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleCountdownTimerCompleted, false, 0, true );										_elapsedTime = new ElapsedTime();					_elapsedTime.startIt();										for( var i:uint=0; i<_waveZoneControllers.length; ++i )					{						//trace( "WaveZoneController(_waveZoneControllers[i]).startWaveZone: "+WaveZoneController(_waveZoneControllers[i]).startWaveZone );												WaveZoneController(_waveZoneControllers[i]).startWaveZone();					}										//_chickenDisplayObjectController.start();										if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevel )					{						//_gameboardReference.addEventListener( GameLevelEvent.ON_MENU_ICON_SELECTED, handleMenuIconSelected, false, 0, true );						//_gameboardReference.addEventListener( GameLevelEvent.ON_WEAPON_ADDED, handleWeaponAdded, false, 0, true );						_gameboardReference.onWeaponAdded.add( handleWeaponAdded );						_gameboardReference.onMenuIconSelected.add( handleMenuIconSelected );												MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_3";						/*						var chickenDisplayObject:ChickenDisplayObject = _chickenDisplayObjectController.addChicken(0);						chickenDisplayObject.pause();						var globalPosition:Point = chickenDisplayObject.contentClip.parent.localToGlobal( new Point(chickenDisplayObject.contentClip.x, chickenDisplayObject.contentClip.y) );						EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_5")} );						*/												//EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_UI_ELEMENTS_HIDE, this );												//EventNotificationCenter.getInstance().addEventListener( BoogaEvent.ON_TUTORIAL_LEVEL_GATE_SHUT, handleTutorialLevelGateShut, false, 0, true );						//EventNotificationCenter.getInstance().addEventListener( BoogaEvent.ON_TUTORIAL_LEVEL_SPAWN_ENEMY, handleTutorialLevelSpawnEnemy, false, 0, true );						//EventNotificationCenter.getInstance().addEventListener( BoogaEvent.ON_TUTORIAL_LEVEL_INTRO_FINISHED, handleTutorialLevelIntroFinished, false, 0, true );												_gameboardReference.initIntroAnimation();						_gameboardReference.introAnimationViewClip.onTutorialLevelEnemySpawned.add( handleTutorialLevelSpawnEnemy );						_gameboardReference.introAnimationViewClip.onTutorialLevelGateShut.add( handleTutorialLevelGateShut );						_gameboardReference.introAnimationViewClip.onTutorialLevelIntroFinished.add( handleTutorialLevelIntroFinished );						_gameboardReference.introAnimationViewClip.onTutorialLevelVillagerRunningStopped.add( handleVillagerRunningStopped );												pauseForGodAttack();												//_chickenDisplayObjectController.start();					}					else					{						_chickenDisplayObjectController.start();												var randomIndex:int = int(Math.random()*_backgroundMusicOptions.length);						_currentBackgroundMusic = _backgroundMusicOptions[randomIndex];						_isPlayingBackgroundMusic = true;												//SoundEffectPlayer.getInstance().setVolume( SoundsIndex.getInstance().getSoundBySoundId(_currentBackgroundMusic).volume, 0, _currentBackgroundMusic );						SoundEffectPlayer.getInstance().playLibrarySound( _currentBackgroundMusic, true, _currentBackgroundMusic, _currentBackgroundMusic, SoundEffectPlayer.SOUND_PLAYER_MUSIC );												//trace( "tutorialGameLevelDelete: "+MainGameController.getInstance().currentUser.tutorialGameLevelDelete );						//trace( "villageOrder: "+MainGameController.getInstance().currentUser.getUnlockedVillage(MainGameController.getInstance().currentUser.currentVillageId).villageOrder );												if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevelDelete && MainGameController.getInstance().currentUser.getUnlockedVillage(MainGameController.getInstance().currentUser.currentVillageId).villageOrder >= 4 )						{							//_gameboardReference.addEventListener( GameLevelEvent.ON_MENU_ICON_SELECTED, handleMenuIconSelected, false, 0, true );							//_gameboardReference.addEventListener( GameLevelEvent.ON_WEAPON_ADDED, handleWeaponAdded, false, 0, true );							//_gameboardReference.addEventListener( GameLevelEvent.ON_MENU_DELETE_SELECTED, handleMenuDeleteSelected, false, 0, true );							_gameboardReference.onWeaponAdded.add( handleWeaponAdded );							_gameboardReference.onMenuIconSelected.add( handleMenuIconSelected );							_gameboardReference.onMenuDeleteSelected.add( handleMenuDeleteSelected );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_1";														var enemy:Enemy = GameLevelDataIndex.getInstance().getEnemy(_gameLevel.distinctEnemiesInLevel[0].enemy).clone();							var enemyDisplayObject:EnemyDisplayObject = EnemyDisplayObjectFactory.createEnemyDisplayObject( enemy );												//enemyDisplayObject.attackingGameObject = enemy;							enemyDisplayObject.inIsometricView = _inIsometricView;							//enemyDisplayObject.inSpawnPath = true;							enemyDisplayObject.spawnPath = _waveZoneControllers[0].waveZone.spawnPaths[0];							enemyDisplayObject.path = _waveZoneControllers[0].waveZone.paths[0];							//enemyDisplayObject.pathIndex = pathIndex;							enemyDisplayObject.currentIndexInPath = _waveZoneControllers[0].waveZone.paths[0].length-1;							//enemyDisplayObject.pathIndex = _attackingDisplayObjectController.getPathIndex( enemyDisplayObject.currentTile );							enemyDisplayObject.positionIn2D.x = _attackingDisplayObjectController.paths[0][enemyDisplayObject.currentIndexInPath].positionIn2D.x;							enemyDisplayObject.positionIn2D.y = _attackingDisplayObjectController.paths[0][enemyDisplayObject.currentIndexInPath].positionIn2D.y+30;							enemyDisplayObject.contentClip.name = "enemy"+_enemiesSpawned+"_mc";														_enemyDisplayObjectController.addEnemy( enemyDisplayObject, true );														var weapon:Weapon = GameLevelDataIndex.getInstance().getWeapon(2);							var weaponDisplayObject:WeaponDisplayObject = WeaponDisplayObjectFactory.createWeaponDisplayObject( weapon );							var lastTileIndex:int = _gameLevel.paths[0].length-1;														weaponDisplayObject.inIsometricView = this._inIsometricView;							weaponDisplayObject.currentTile = _gameboardReference.tiles[_gameLevel.paths[0][lastTileIndex].r][_gameLevel.paths[0][lastTileIndex].c];							weaponDisplayObject.contentClip.name = "weapon0_mc";														_weaponDisplayObjectController.addWeapon( weaponDisplayObject );							_attackingDisplayObjectController.addWeapon( weaponDisplayObject );							/*							weaponDisplayObject = WeaponDisplayObjectFactory.createWeaponDisplayObject( weapon );							weaponDisplayObject.inIsometricView = this._inIsometricView;							weaponDisplayObject.currentTile = _gameboardReference.tiles[_gameLevel.paths[0][lastTileIndex-1].r][_gameLevel.paths[0][lastTileIndex-1].c];							weaponDisplayObject.contentClip.name = "weapon1_mc";														_weaponDisplayObjectController.addWeapon( weaponDisplayObject );							_attackingDisplayObjectController.addWeapon( weaponDisplayObject );							*/														var globalPosition4:Point = _gameboardReference.gameboardMenu_mc.delete_mc.parent.localToGlobal( new Point(_gameboardReference.gameboardMenu_mc.delete_mc.x+20, _gameboardReference.gameboardMenu_mc.delete_mc.y+20) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition4.x, targetY:globalPosition4.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_1"), transparent:true} );														//pauseForGodAttack();														GameLevelCurrentData.getInstance().chickenCount += GameLevelDataIndex.getInstance().getWeapon(6).cost;							_gameboardReference.gameboardMenuClip.updateMenu();						}						else if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialFullScreen && MainGameController.getInstance().currentUser.getUnlockedVillage(MainGameController.getInstance().currentUser.currentVillageId).villageOrder >= 2 )						{							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_SHOW_FULL_SCREEN, this );													pauseForGodAttack();						}						else if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialSlotMachine && _gameLevel.slotEnabled )						{							var globalPosition2:Point = _gameboardReference.slotMachine_mc.parent.localToGlobal( new Point(_gameboardReference.slotMachine_mc.x+60, _gameboardReference.slotMachine_mc.y+60) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition2.x, targetY:globalPosition2.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_SLOT_1")} );														_gameboardReference.slotMachineClip.alwaysWin = true;													pauseForGodAttack();						}						else if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialBuyChicken && _gameLevel.buyChickenEnabled )						{							var globalPosition3:Point = _gameboardReference.slotMachine_mc.parent.localToGlobal( new Point(_gameboardReference.buyChicken_mc.x, _gameboardReference.buyChicken_mc.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition3.x, targetY:globalPosition3.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_BUY_CHICKEN_1")} );													pauseForGodAttack();						}					}				}							/** handleTutorialLevelGateShut			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleTutorialLevelGateShut():void				{					//EventNotificationCenter.getInstance().removeEventListener( BoogaEvent.ON_TUTORIAL_LEVEL_GATE_SHUT, handleTutorialLevelGateShut );										//_gateDisplayObjectController.gateDisplayObjects[3].contentClip.visible = true;					_gateDisplayObjectController.gateDisplayObjects[3].showLeftGateAfterTutorial();				}							/** handleTutorialLevelSpawnEnemy			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleTutorialLevelSpawnEnemy():void				{					ConsoleBroadcaster.broadcast( "GameboardController", "handleTutorialLevelSpawnEnemy();" );										//EventNotificationCenter.getInstance().removeEventListener( BoogaEvent.ON_TUTORIAL_LEVEL_SPAWN_ENEMY, handleTutorialLevelSpawnEnemy );					/*					var enemy:Enemy = GameLevelDataIndex.getInstance().getEnemy(_gameLevel.distinctEnemiesInLevel[0].enemy).clone();						enemy.speed = 6;					var enemyDisplayObject:EnemyDisplayObject = EnemyDisplayObjectFactory.createEnemyDisplayObject( enemy );										//enemyDisplayObject.attackingGameObject = enemy;					enemyDisplayObject.inIsometricView = _inIsometricView;					enemyDisplayObject.inSpawnPath = true;					enemyDisplayObject.spawnPath = _waveZoneControllers[0].waveZone.spawnPaths[0];					enemyDisplayObject.path = _waveZoneControllers[0].waveZone.paths[0];					//enemyDisplayObject.pathIndex = _attackingDisplayObjectController.getPathIndex( enemyDisplayObject.currentTile );					enemyDisplayObject.contentClip.name = "enemy"+_enemiesSpawned+"_mc";										_enemyDisplayObjectController.addEnemy( enemyDisplayObject );					*/					//_attackingDisplayObjectController.addEnemy( enemyDisplayObject );					/*					for( var i:int=0; i<_gameboardReference.enemyIconClips.length; ++i )					{						if( _gameboardReference.enemyIconClips[i].enemyId == event.customParameters.enemy.id )							_gameboardReference.enemyIconClips[i].updateCountBy(1);					}					*/					//++_enemiesSpawned;										//_enemyDisplayObjectController.enemyDisplayObjects[0].attackingGameObject.speed = 6;										//_chickenDisplayObjectController.start();					unpauseForGodAttack();				}							/** handleTutorialLevelIntroFinished			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleTutorialLevelIntroFinished():void				{					//ConsoleBroadcaster.broadcast( "GameboardController", "handleTutorialLevelIntroFinished();" );										_gameboardReference.introAnimationViewClip.onTutorialLevelEnemySpawned.remove( handleTutorialLevelSpawnEnemy );					_gameboardReference.introAnimationViewClip.onTutorialLevelGateShut.remove( handleTutorialLevelGateShut );					_gameboardReference.introAnimationViewClip.onTutorialLevelIntroFinished.remove( handleTutorialLevelIntroFinished );					_gameboardReference.introAnimationViewClip.onTutorialLevelVillagerRunningStopped.remove( handleVillagerRunningStopped );					//_gameboardReference.killIntroAnimation();					/*					MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_5";										var chickenDisplayObject:ChickenDisplayObject = _chickenDisplayObjectController.addChicken(0);					chickenDisplayObject.pause();					var globalPosition:Point = chickenDisplayObject.contentClip.parent.localToGlobal( new Point(chickenDisplayObject.contentClip.x, chickenDisplayObject.contentClip.y) );					EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false} );										_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_5") );										pauseForGodAttack();					*/				}							/** checkIfGateIsAlive			  *	---------------------------------------------------------------------------- *			  *	Checks if a gate on a column is alive or died.			  *	---------------------------------------------------------------------------- */			 	public function checkIfGateIsAlive( column:int ):Boolean				{					var gateDisplayObject:GateDisplayObject = _gateDisplayObjectController.getGateAt( column );					return (gateDisplayObject != null && gateDisplayObject.alive );				}								public function checkIfGateIsFullHealth( column:int ):Boolean				{					var gateDisplayObject:GateDisplayObject = _gateDisplayObjectController.getGateAt( column );					return (gateDisplayObject != null && gateDisplayObject.isFullHealth );				}								public function checkIfGateIsInPath( column:int ):Boolean				{					var gateDisplayObject:GateDisplayObject = _gateDisplayObjectController.getGateAt( column );					return (gateDisplayObject != null && gateDisplayObject.isInPath );				}											/**	******************************************* *			  * Gameboard Events			  *	******************************************* */			 				/** handleStartGameClicked			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handleStartGameClicked( event:Event ):void				{					ready();				}*/							/** handlePauseGameClicked			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handlePauseGameClicked( event:CustomEvent ):void				{					pause();				}*/							/** handleUnpauseGameClicked			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handleUnpauseGameClicked( event:CustomEvent ):void				{					unpause();				}*/							/** handleFullScreenClicked			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handleFullScreenClicked( event:CustomEvent ):void				{					toggleFullScreen();				}*/							/** handleSlotSpinStarted			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleSlotSpinStarted():void				{					if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialSlotMachine )					{						EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );						unpauseForGodAttack();					}				}							/** handleSlotSpinEnds			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleSlotSpinEnded( win:Boolean, winningModifier:Number ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "handleSlotSpinEnds("+win+", "+winningModifier+");" );										if( win )					{						var chickenDisplayObject:ChickenDisplayObject;												for( var i:uint=0; i<winningModifier; ++i )						{							chickenDisplayObject = _chickenDisplayObjectController.addChicken( -1, true, i, (i == winningModifier-1) );														if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialSlotMachine && i == 0 )							{								chickenDisplayObject.onSlotMachineSpawnAnimationCompleted.add( handleSlotMachineChickenAnimationCompleted );							}						}												_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_HAPPY_ANIMATION );																	}				}								protected function handleSlotMachineChickenAnimationCompleted( chickenDisplayObject:ChickenDisplayObject ):void				{					if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialSlotMachine )					{						MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_SLOT_2";												var globalPosition:Point = chickenDisplayObject.contentClip.parent.localToGlobal( new Point(chickenDisplayObject.contentClip.x, chickenDisplayObject.contentClip.y) );						EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_SLOT_2")} );												pauseForGodAttack();					}				}											/** handleMenuIconSelected			  *	---------------------------------------------------------------------------- *			  *	This event is fired when a menu icon selected. When menu icon is selected			  *	and it's part of the tutorial, display the next message.			  *	---------------------------------------------------------------------------- */			 	protected function handleMenuIconSelected():void				{					if( !_gameboardReference.isEditor && (MainGameController.getInstance().currentUser.tutorialGameLevel || MainGameController.getInstance().currentUser.tutorialGameLevelDelete) )					{						if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_5" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_6";														//force the user to put the weapon on the first tile.							var lastTileIndex:int = _gameLevel.paths[0].length-1;							var tile:GameboardTile = _gameboardReference.tiles[_gameLevel.paths[0][lastTileIndex].r][_gameLevel.paths[0][lastTileIndex].c];							var globalPosition:Point = tile.contentClip.parent.localToGlobal( new Point(tile.contentClip.x, tile.contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );														//_gameboardReference.addEventListener( BoogaEvent.ON_PLACE_WEAPON_ON_INVALID_SPOT, handlePlaceWeaponOnInvalidSpot, false, 0, true );							_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_6") );							_gameboardReference.showTutorialTilePlacementOnLastTile();														pauseForGodAttack();						}						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_8" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_9";														//force the user to put the weapon on the first tile.							var secondToLastTileIndex:int = _gameLevel.paths[0].length-2;							var secondToLastTile:GameboardTile = _gameboardReference.tiles[_gameLevel.paths[0][secondToLastTileIndex].r][_gameLevel.paths[0][secondToLastTileIndex].c];							var globalPosition:Point = secondToLastTile.contentClip.parent.localToGlobal( new Point(secondToLastTile.contentClip.x, secondToLastTile.contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );														//_gameboardReference.addEventListener( BoogaEvent.ON_PLACE_WEAPON_ON_INVALID_SPOT, handlePlaceWeaponOnInvalidSpot, false, 0, true );							_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_9") );							_gameboardReference.showTutorialTilePlacementOnSecondToLastTile();														pauseForGodAttack();						}						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_3" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_4";														var lastTileIndex:int = _gameLevel.paths[0].length-1;							var tile:GameboardTile = _gameboardReference.tiles[_gameLevel.paths[0][lastTileIndex].r][_gameLevel.paths[0][lastTileIndex].c];							var globalPosition:Point = tile.contentClip.parent.localToGlobal( new Point(tile.contentClip.x, tile.contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_4"), transparent:true} );														//_gameboardReference.addEventListener( BoogaEvent.ON_PLACE_WEAPON_ON_INVALID_SPOT, handlePlaceWeaponOnInvalidSpot, false, 0, true );														//pauseForGodAttack();						}						/*						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_9" )						{							MainGameController.getInstance().currentUser.tutorialGameLevel = false;														var userDataController:UserDataController = new UserDataController();								userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "game_level", 0 );														_gameboardReference.introAnimationViewClip.hideTutorialText();														EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														unpauseForGodAttack();						}						*/					}				}							/** handleWeaponPlacedOnInvalidSpot			  *	---------------------------------------------------------------------------- *			  *	This event is fired when users place weapons on invalid spot.			  *	---------------------------------------------------------------------------- */			 	protected function handleWeaponPlacedOnInvalidSpot( item:AbstractGameObject ):void				{					if( MainGameController.getInstance().currentUser.tutorialGameLevel )					{						//_gameboardReference.removeEventListener( BoogaEvent.ON_PLACE_WEAPON_ON_INVALID_SPOT, handlePlaceWeaponOnInvalidSpot );												if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_6" )						{							MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_5";														unpauseForGodAttack();														var firstMenuIcon:GameboardMenuContentIcon = _gameboardReference.gameboardMenuClip.getGameboardMenuIcon(0);							//trace( "firstMenuIcon: "+firstMenuIcon );							var globalPosition:Point = firstMenuIcon.contentClip.parent.localToGlobal( new Point(firstMenuIcon.contentClip.x+25, firstMenuIcon.contentClip.y+25) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );														_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_5") );														pauseForGodAttack();						}						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_9" )						{							MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_8";														unpauseForGodAttack();														var firstMenuIcon:GameboardMenuContentIcon = _gameboardReference.gameboardMenuClip.getGameboardMenuIcon(0);							//trace( "firstMenuIcon: "+firstMenuIcon );							var globalPosition:Point = firstMenuIcon.contentClip.parent.localToGlobal( new Point(firstMenuIcon.contentClip.x+25, firstMenuIcon.contentClip.y+25) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );														_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_8") );														pauseForGodAttack();						}					}					else if( MainGameController.getInstance().currentUser.tutorialGameLevelDelete )					{						//_gameboardReference.removeEventListener( BoogaEvent.ON_PLACE_WEAPON_ON_INVALID_SPOT, handlePlaceWeaponOnInvalidSpot );												if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_4" )						{							MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_3";														//var globalPosition:Point = _gameboardReference.gameboardMenu_mc.delete_mc.parent.localToGlobal( new Point(_gameboardReference.gameboardMenu_mc.delete_mc.x, _gameboardReference.gameboardMenu_mc.delete_mc.y) );							//EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_3")} );														_gameboardReference.gameboardMenuClip.getGameboardMenuIcon(0).setDeactive();							_gameboardReference.gameboardMenuClip.getGameboardMenuIcon(2).setDeactive();							var bombMenuIcon:GameboardMenuContentIcon = _gameboardReference.gameboardMenuClip.getGameboardMenuIcon(1);							//trace( "firstMenuIcon: "+firstMenuIcon );							var globalPosition:Point = bombMenuIcon.contentClip.parent.localToGlobal( new Point(bombMenuIcon.contentClip.x+25, bombMenuIcon.contentClip.y+25) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_3"), transparent:true} );														//pauseForGodAttack();						}					}					else					{						var item:AbstractGameObject = item;						//trace( item );						//var element:ElementCompatibility = GameLevelUtil.checkForElement( _gameLevel );												if( _gameLevelElement != null )						{							if( item.hasAttackProperty(_gameLevelElement.against) )							{								var eventObject:Object = {};									eventObject.showIceWarning = _gameLevelElement.against == GameLevelUtil.ATTACK_PROPERTY_ICE_INDEX;									eventObject.showFireWarning = _gameLevelElement.against == GameLevelUtil.ATTACK_PROPERTY_FIRE_INDEX;																EventNotificationCenter.getInstance().addSignalListener( BoogaEvent.ON_WARNING_HIDE, handleWarningHid, this );								EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_WARNING_SHOW, this, eventObject );								pauseForGodAttack();								/*								if( item.hasAttackProperty(_gameLevelElement.protection) )									return true;																for( i=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )								{									if( _weaponDisplayObjectController.weaponDisplayObjects[i].currentTile.isTheSameAsTile(tile) &&										_weaponDisplayObjectController.weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ADDITION_INDEX) &&										_weaponDisplayObjectController.weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(_gameLevelElement.protection) )									{										return true;									}								}																return false;								*/							}						}					}				}								protected function handleWarningHid( customParameters:Object ):void				{					EventNotificationCenter.getInstance().removeSignalListener( BoogaEvent.ON_WARNING_HIDE, handleWarningHid );					unpauseForGodAttack();				}							/** handleWeaponAdded			  *	---------------------------------------------------------------------------- *			  *	This event is fired when weapon is added to the game board level.			  *	---------------------------------------------------------------------------- */			 	protected function handleWeaponAdded():void				{					if( !_gameboardReference.isEditor && (MainGameController.getInstance().currentUser.tutorialGameLevel || MainGameController.getInstance().currentUser.tutorialGameLevelDelete) )					{						if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_6" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );							_gameboardReference.introAnimationViewClip.hideTutorialText();							_gameboardReference.hideTutorialTilePlacement();														//_enemyDisplayObjectController.addEventListener( GameLevelEvent.HIT, handleEnemyInTutorialHit, false, 0, true );							_enemyDisplayObjectController.onEnemyHit.add( handleEnemyInTutorialHit );						}						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_9" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														_gameboardReference.introAnimationViewClip.hideTutorialText();							_gameboardReference.hideTutorialTilePlacement();						}						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_4" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "";														MainGameController.getInstance().currentUser.tutorialGameLevelDelete = false;														var userDataController:UserDataController = new UserDataController();								userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "game_level_delete", 0 );														//_gameboardReference.removeEventListener( GameLevelEvent.ON_MENU_ICON_SELECTED, handleMenuIconSelected );							//_gameboardReference.removeEventListener( GameLevelEvent.ON_WEAPON_ADDED, handleWeaponAdded );							//_gameboardReference.removeEventListener( GameLevelEvent.ON_MENU_DELETE_SELECTED, handleMenuDeleteSelected );							_gameboardReference.onWeaponAdded.remove( handleWeaponAdded );							_gameboardReference.onMenuIconSelected.remove( handleMenuIconSelected );							_gameboardReference.onMenuDeleteSelected.remove( handleMenuDeleteSelected );						}						/*						var chickenDisplayObject:ChickenDisplayObject = _chickenDisplayObjectController.addChicken(0);						chickenDisplayObject.pause();						var globalPosition:Point = chickenDisplayObject.contentClip.parent.localToGlobal( new Point(chickenDisplayObject.contentClip.x, chickenDisplayObject.contentClip.y) );						EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false} );												_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_8") );												pauseForGodAttack();						*/					}				}								protected function handleEnemyInTutorialHit( enemyDisplayObject:EnemyDisplayObject ):void				{					//trace( 'handleEnemyInTutorialHit();' );					if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevel )					{						//_enemyDisplayObjectController.removeEventListener( GameLevelEvent.HIT, handleEnemyInTutorialHit );												//trace( MainGameController.getInstance().currentUser.currentTutorialStep );												if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_6" )						{							//trace( "first time enemy is getting hit" );							MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_7";														var chickenDisplayObject:ChickenDisplayObject = _chickenDisplayObjectController.addChicken(2);							chickenDisplayObject.pause();							var globalPosition:Point = chickenDisplayObject.contentClip.parent.localToGlobal( new Point(chickenDisplayObject.contentClip.x, chickenDisplayObject.contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );														chickenDisplayObject = _chickenDisplayObjectController.addChicken(1);							chickenDisplayObject.pause();														_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_7") );													}						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_9" )						{							_enemyDisplayObjectController.onEnemyHit.remove( handleEnemyInTutorialHit );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_10";														var chickenDisplayObject2:ChickenDisplayObject = _chickenDisplayObjectController.addChicken(1);							chickenDisplayObject2.pause();							var globalPosition:Point = chickenDisplayObject2.contentClip.parent.localToGlobal( new Point(chickenDisplayObject2.contentClip.x, chickenDisplayObject2.contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );														chickenDisplayObject2 = _chickenDisplayObjectController.addChicken(2);							chickenDisplayObject2.pause();														_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_10") );														_chickenDisplayObjectController.start();						}												pauseForGodAttack();					}				}								protected function handleMenuDeleteSelected():void				{					if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevelDelete )					{						if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_1" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_2";														var globalPosition:Point = _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.parent.localToGlobal( new Point(_weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.x, _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_2"), transparent:true} );														//_gameboardReference.addEventListener( BoogaEvent.ON_DELETE_WEAPON_ON_INVALID_SPOT, handleDeleteWeaponOnInvalidSpot, false, 0, true );							_gameboardReference.onWeaponDeletedOnInvalidSpot.add( handleWeaponDeletedOnInvalidSpot );														//pauseForGodAttack();						}						/*						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_3" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_4";														var globalPosition2:Point = _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.parent.localToGlobal( new Point(_weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.x, _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition2.x, targetY:globalPosition2.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_2")} );														_gameboardReference.addEventListener( BoogaEvent.ON_DELETE_WEAPON_ON_INVALID_SPOT, handleDeleteWeaponOnInvalidSpot, false, 0, true );														pauseForGodAttack();						}						/*						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_5" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_6";														var globalPosition3:Point = _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.parent.localToGlobal( new Point(_weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.x, _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition3.x, targetY:globalPosition3.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_2")} );														pauseForGodAttack();						}						*/					}				}								protected function handleWeaponDeletedOnInvalidSpot():void				{					//trace( "handleWeaponDeletedOnInvalidSpot();" );										if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevelDelete )					{						if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_2" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_1";														var globalPosition1:Point = _gameboardReference.gameboardMenu_mc.delete_mc.parent.localToGlobal( new Point(_gameboardReference.gameboardMenu_mc.delete_mc.x+20, _gameboardReference.gameboardMenu_mc.delete_mc.y+20) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition1.x, targetY:globalPosition1.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_1"), transparent:true} );														//_gameboardReference.addEventListener( BoogaEvent.ON_DELETE_WEAPON_ON_INVALID_SPOT, handleDeleteWeaponOnInvalidSpot, false, 0, true );							_gameboardReference.onWeaponDeletedOnInvalidSpot.add( handleWeaponDeletedOnInvalidSpot );														//pauseForGodAttack();						}						/*						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_4" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_3";														var globalPosition2:Point = _gameboardReference.gameboardMenu_mc.delete_mc.parent.localToGlobal( new Point(_gameboardReference.gameboardMenu_mc.delete_mc.x, _gameboardReference.gameboardMenu_mc.delete_mc.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition2.x, targetY:globalPosition2.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_3")} );														_gameboardReference.addEventListener( BoogaEvent.ON_DELETE_WEAPON_ON_INVALID_SPOT, handleDeleteWeaponOnInvalidSpot, false, 0, true );														pauseForGodAttack();						}						/*						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_5" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_6";														var globalPosition3:Point = _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.parent.localToGlobal( new Point(_weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.x, _weaponDisplayObjectController.weaponDisplayObjects[0].contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition3.x, targetY:globalPosition3.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_2")} );														pauseForGodAttack();						}						*/					}				}								private function handleReplayGameClicked( event:GameLevelEvent ):void				{									}								private function handleExitGameClicked( event:GameLevelEvent ):void				{									}							/** handleBuyChicken			  *	---------------------------------------------------------------------------- */				protected function handleBuyChicken( event:BoogaEvent ):void				{					if( MainGameController.getInstance().currentUser.tutorialBuyChicken )					{						//trace( "handleBuyChicken();" );						unpauseForGodAttack();												MainGameController.getInstance().currentUser.tutorialBuyChicken = false;												EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );												var userDataController:UserDataController = new UserDataController();							userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "buy_chicken", 0 );					}				}							/** handleWinAnimationDone			  *	---------------------------------------------------------------------------- */				protected function handleWinAnimationDone( event:BoogaEvent ):void				{					ConsoleBroadcaster.broadcast( "GameboardController", "handleWinAnimationDone();" );										_playingEndAnimation = false;										_gameboardReference.resultScreenWinClip.hide();					/*					Mouse.hide();					_gameboardReference.mouseDigIcon_mc.x = _gameboardReference.contentClip.stage.mouseX;					_gameboardReference.mouseDigIcon_mc.y = _gameboardReference.contentClip.stage.mouseY;					_gameboardReference.mouseDigIcon_mc.visible = true;					_gameboardReference.contentClip.stage.addEventListener( MouseEvent.MOUSE_MOVE, handleDiggingMouseMove, false, 0, true );					*/										//TODO:					//	If there is no spot for digging, go back to island selection view										ConsoleBroadcaster.broadcast( "GameboardController", "_currentVillage: "+_currentVillage );										if( _currentVillage != null )					{						if( MainGameController.getInstance().adventureLevelUp )						{							EventNotificationCenter.getInstance().addSignalListener( BoogaEvent.ON_ADVENTURE_LEVEL_POPUP_HIDE, handleHideAdventureLevelPopupAfterWin, this );							MainGameController.getInstance().showAdventureLevelPopup();						}						else						{							showDiggingAfterWin();						}											}				}								protected function handleLoseAnimationDone( event:BoogaEvent ):void				{					_playingEndAnimation = false;				}								protected function handleHideAdventureLevelPopupAfterWin( customParameters:Object ):void				{					EventNotificationCenter.getInstance().removeSignalListener( BoogaEvent.ON_ADVENTURE_LEVEL_POPUP_HIDE, handleHideAdventureLevelPopupAfterWin );					showDiggingAfterWin();				}								protected function showDiggingAfterWin():void				{					trace( "showDiggingAfterWin();" );										var currentDiggingMap:DiggingMap = MainGameController.getInstance().currentUser.getDiggingMap(_currentVillage.id);										//ConsoleBroadcaster.broadcast( "GameboardController", "user has diggingMap ? "+currentDiggingMap );										_gameboardReference.removeHighlightWeaponRange();										if( currentDiggingMap != null )					{						if( !currentDiggingMap.areAllSpotsDug() )						{							_gameboardReference.highlightDiggingTiles( currentDiggingMap );														if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialWin )							{								_gameboardReference.showInvisibleBlocker();							}						}						else if( _gameboardReference.newDiscoveriesViewClip.newItems.length > 0 )						{							_gameboardReference.newDiscoveriesViewClip.show();						}						else 						{							//ConsoleBroadcaster.broadcast( "GameboardController", "user has dug on all the spots and no new discoveries" );							//dispatchEvent( new BoogaEvent(BoogaEvent.ON_ISLAND_SELECT) );							_gameboardReference.levelEndResultViewClip.show();						}											}					else if( currentDiggingMap == null )					{						//ConsoleBroadcaster.broadcast( "GameboardController", "do something here, digging map isn't supposed to be null" );												//NOTE:						//	Should we create new digging map for the user?					}					else if( _gameboardReference.newDiscoveriesViewClip.newItems.length > 0 )					{						_gameboardReference.newDiscoveriesViewClip.show();					}					else					{						ConsoleBroadcaster.broadcast( "GameboardController", "Defaulted to go back to island selection if there are issues" );						//EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TRANSITION_SHOW, this );						//dispatchEvent( new BoogaEvent(BoogaEvent.ON_ISLAND_SELECT) );						_gameboardReference.levelEndResultViewClip.show();					}				}								protected function handleDigTextAnimationCompleted():void				{					//trace( "tutorialWin: "+MainGameController.getInstance().currentUser.tutorialWin );										_gameboardReference.hideInvisibleBlocker();										if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialWin )					{						//trace( "activeDiggingTiles; "+_gameboardReference.activeDiggingTiles );												var tile:GameboardTile = _gameboardReference.activeDiggingTiles[0];						var globalPosition:Point = tile.contentClip.parent.localToGlobal( new Point(tile.contentClip.x, tile.contentClip.y) );						EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_WIN_1")} );					}				}							/** handleDiggingMouseMove			  *	---------------------------------------------------------------------------- 				protected function handleDiggingMouseMove( event:MouseEvent ):void				{									}*/							/** handleTreasureDug			  *	---------------------------------------------------------------------------- */				protected function handleTreasureDug( event:BoogaEvent ):void				{					ConsoleBroadcaster.broadcast( "GameboardController", "handleTreasureDug();" );										//TODO:					//	Might have to set up 2 different views here since you can dig in 2 ways					//	- after a level ends					//	- from the archeology tab ( it doesn't go next to discoveries, it will just go back to archeology tab after DigResultView										var diggingTile:DiggingTile = event.customParameters.diggingTile;										trace( 'diggingTile.treasureId: '+diggingTile.treasureId );					trace( 'diggingTile.weaponId: '+diggingTile.weaponId );					trace( 'diggingTile.godId: '+diggingTile.godId );										if( MainGameController.getInstance().currentUser.tutorialWin )					{						EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );											MainGameController.getInstance().currentUser.tutorialWin = false;											var userDataController:UserDataController = new UserDataController();							userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "win", 0 );					}										MainGameController.getInstance().currentUser.getDiggingMap( _currentVillage.id ).digTreasureOn( diggingTile.area, diggingTile.row, diggingTile.column );										if( diggingTile.weaponId > 0 )					{						_gameboardReference.digResultViewClip.initItem( GameLevelDataIndex.getInstance().getWeapon(diggingTile.weaponId) );						var giftDataController:GiftDataController = new GiftDataController();							giftDataController.addAcceptedGift( diggingTile.weaponId, 'Weapon', MainGameController.getInstance().currentUser.id );					}					else if ( diggingTile.godId > 0 )					{						_gameboardReference.digResultViewClip.initItem( GameLevelDataIndex.getInstance().getGod(diggingTile.godId) );						var giftDataController2:GiftDataController = new GiftDataController();							giftDataController2.addAcceptedGift( diggingTile.godId, 'God', MainGameController.getInstance().currentUser.id );					}					else					{						_gameboardReference.digResultViewClip.initTreasure( MainGameDataIndex.getInstance().getTreasure(diggingTile.treasureId) );						MainGameController.getInstance().addUnlockedTreasure( diggingTile.treasureId );					}										if( MainGameController.getInstance().currentUser.getDiggingMap( _currentVillage.id ).areAllSpotsDug() )					{						_gameboardReference.digResultViewClip.disableDigEarlyButton();					}					else					{						_gameboardReference.digResultViewClip.enableDigEarlyButton();					}					//_gameboardReference.digResultViewClip.show();										//dispatchEvent( new CustomEvent("onDigTreasure", {treasureId:event.customParameters.treasureId}) );										var trackingDataController:TrackingDataController = new TrackingDataController();						trackingDataController.saveTrackingArcheology( MainGameController.getInstance().currentUser.id, !_isDiggingOnly );										//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onDigTreasure", this, {treasureId:event.customParameters.treasureId} );										MainGameController.getInstance().saveDiggingMap( MainGameController.getInstance().currentUser.getDiggingMap( _currentVillage.id ), _currentVillage.id, _isDiggingOnly );									}							/** handleTreasureDugAnimationComplete			  *	---------------------------------------------------------------------------- */				protected function handleTreasureDugAnimationComplete( event:BoogaEvent ):void				{					var allSpotsDug:Boolean = MainGameController.getInstance().currentUser.getDiggingMap(_currentVillage.id).areAllSpotsDug();										if( _isDiggingOnly )					{						if( allSpotsDug )						{							_gameboardReference.digResultViewClip.viewType = DigResultView.VIEW_TYPE_LAST_DIG_DISCOVERIES;						}						else						{							_gameboardReference.digResultViewClip.viewType = DigResultView.VIEW_TYPE_DIG_DISCOVERIES;						}												if( MainGameController.getInstance().adventureLevelUp )						{							_gameboardReference.digResultViewClip.onShowAnimationCompleted.add( handleDigResultViewAnimationCompleted );						}					}					else if( _gameboardReference.newDiscoveriesViewClip.newItems.length > 0 )					{						if( allSpotsDug )						{							_gameboardReference.digResultViewClip.viewType = DigResultView.VIEW_TYPE_LAST_DIG_DISCOVERIES;						}						else						{							_gameboardReference.digResultViewClip.viewType = DigResultView.VIEW_TYPE_DIG_DISCOVERIES;						}					}					else					{						if( allSpotsDug )						{							_gameboardReference.digResultViewClip.viewType = DigResultView.VIEW_TYPE_LAST_DIG_NO_DISCOVERIES;						}						else						{							_gameboardReference.digResultViewClip.viewType = DigResultView.VIEW_TYPE_DIG_NO_DISCOVERIES;						}												if( MainGameController.getInstance().adventureLevelUp )						{							_gameboardReference.digResultViewClip.onShowAnimationCompleted.add( handleDigResultViewAnimationCompleted );						}					}										trace( "adventureLevelUp: "+MainGameController.getInstance().adventureLevelUp );										_gameboardReference.digResultViewClip.show();									}								protected function handleDigSoundStart( event:BoogaEvent ):void				{					SoundEffectPlayer.getInstance().playLibrarySound( "sfx_shovel_dig.wav", false, "sfx_shovel_dig.wav", "sfx_shovel_dig.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );				}							/** handleDigResultExit			  *	---------------------------------------------------------------------------- */				protected function handleDigResultExit( event:BoogaEvent ):void				{					ConsoleBroadcaster.broadcast( "GameboardController", "handleDigResultExit();" );										_gameboardReference.digResultViewClip.hide();										if( MainGameController.getInstance().adventureLevelUp )					{						//_gameboardReference.digResultViewClip.onShowAnimationCompleted.add( handleDigResultViewAnimationCompleted );						EventNotificationCenter.getInstance().addSignalListener( BoogaEvent.ON_ADVENTURE_LEVEL_POPUP_HIDE, handleHideAdventureLevelPopupAfterDigResultView, this );						MainGameController.getInstance().showAdventureLevelPopup();					}					else					{						showScreensAfterDigResultView();					}				}								protected function handleDigResultViewAnimationCompleted():void				{					_gameboardReference.digResultViewClip.onShowAnimationCompleted.remove( handleDigResultViewAnimationCompleted );					//EventNotificationCenter.getInstance().addSignalListener( BoogaEvent.ON_ADVENTURE_LEVEL_POPUP_HIDE, handleHideAdventureLevelPopupAfterDigResultView, this );					MainGameController.getInstance().showAdventureLevelPopup();				}								protected function showScreensAfterDigResultView():void				{					trace( "showScreenAfterDigResultView();" );					trace( "_isDiggingOnly: "+_isDiggingOnly );										if( _isDiggingOnly )					{						dispatchEvent( new BoogaEvent(BoogaEvent.ON_ISLAND_SELECT) );					}					else					{						if( _gameboardReference.newDiscoveriesViewClip.newItems.length > 0 )							_gameboardReference.newDiscoveriesViewClip.show();						else							dispatchEvent( new BoogaEvent(BoogaEvent.ON_ISLAND_SELECT) );					}				}								protected function handleHideAdventureLevelPopupAfterDigResultView( customParameters:Object ):void				{					EventNotificationCenter.getInstance().removeSignalListener( BoogaEvent.ON_ADVENTURE_LEVEL_POPUP_HIDE, handleHideAdventureLevelPopupAfterDigResultView );					showScreensAfterDigResultView();				}							/** handleDigResultLeaveEarly			  *	---------------------------------------------------------------------------- *			  *	When user clicks on the dig early button on dig result view, prompts the user			  *	if they want to buy it for a number of facebook credits.			  *	---------------------------------------------------------------------------- */			 	protected function handleDigResultLeaveEarly( event:BoogaEvent ):void				{					//MainGameController.getInstance().addEventListener( BoogaEvent.ON_PURCHASE_SUCCESS, handlePurchaseToDigEarlySuccess );					//MainGameController.getInstance().addEventListener( BoogaEvent.ON_PURCHASE_FAIL, handlePurchaseToDigEarlyFail );					//MainGameController.getInstance().purchaseToDigEarly();					//_gameboardReference.digResultViewClip.hide();					//_gameboardReference.highlightDiggingTiles( MainGameController.getInstance().currentUser.getDiggingMap( _currentVillage.id ) );														}								protected function handlePurchaseToDigEarlySuccess( event:BoogaEvent ):void				{					MainGameController.getInstance().removeEventListener( BoogaEvent.ON_PURCHASE_SUCCESS, handlePurchaseToDigEarlySuccess );					MainGameController.getInstance().removeEventListener( BoogaEvent.ON_PURCHASE_FAIL, handlePurchaseToDigEarlyFail );										//MainGameController.getInstance().currentUser.getDiggingMap( _currentVillage.id ).output();										_gameboardReference.digResultViewClip.hide();					_gameboardReference.highlightDiggingTiles( MainGameController.getInstance().currentUser.getDiggingMap( _currentVillage.id ) );				}								protected function handlePurchaseToDigEarlyFail( event:BoogaEvent ):void				{					MainGameController.getInstance().removeEventListener( BoogaEvent.ON_PURCHASE_SUCCESS, handlePurchaseToDigEarlySuccess );					MainGameController.getInstance().removeEventListener( BoogaEvent.ON_PURCHASE_FAIL, handlePurchaseToDigEarlyFail );				}							/** handleNewDiscoveriesExit			  *	---------------------------------------------------------------------------- */				protected function handleNewDiscoveriesExit( event:CustomEvent ):void				{					ConsoleBroadcaster.broadcast( "GameboardController", "handleNewDiscoveriesExit();" );										//TODO:					//	Done with new discoveries view, go to next level					dispatchEvent( new BoogaEvent(BoogaEvent.ON_PLAY_NEXT_LEVEL, {villageId:_currentVillage.id}) );				}							/** handleMainLoopTimerFired			  *	---------------------------------------------------------------------------- *			  *	This is the main enter frame event that we are listening to. On enter frame			  *	fired, we will need to tell all controllers to update its contents.			  *	---------------------------------------------------------------------------- */			 	protected function handleMainLoopTimerFired( timer:CustomTimer ):void				{					GameLevelDataIndex.getInstance().currentCounter += 1;										if( _isPlaying && !_isPaused )					{						if( _weaponDisplayObjectController != null )							_weaponDisplayObjectController.updateOnEnterFrame();												if( _enemyDisplayObjectController != null )							_enemyDisplayObjectController.updateOnEnterFrame();												if( _projectileDisplayObjectController != null )							_projectileDisplayObjectController.updateOnEnterFrame();												if( _villagerDisplayObjectController != null )							_villagerDisplayObjectController.updateOnEnterFrame();											}										_gameboardReference.updateOnEnterFrame();										if( MainGameController.getInstance().currentUser.tutorialGameLevelDelete || (_isPlaying && !_isPaused) || _gameEnds )					{						if( _effectsController != null )							_effectsController.updateOnEnterFrame();					}										if( (MainGameController.getInstance().currentUser.tutorialGameLevel && _gameLevel.level == 1) || (MainGameController.getInstance().currentUser.tutorialSlotMachine && _gameLevel.level == 3) )					{						if( _chickenDisplayObjectController != null )							_chickenDisplayObjectController.updateOnEnterFrame( true );					}					else if( _isPlaying && !_isPaused )					{						if( _chickenDisplayObjectController != null )							_chickenDisplayObjectController.updateOnEnterFrame();					}										if( _gateDisplayObjectController != null )						_gateDisplayObjectController.updateOnEnterFrame();										if( _godDisplayObjectController != null )						_godDisplayObjectController.updateOnEnterFrame();									}											/** addWeapon			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	public function addWeapon( weapon:Weapon, tile:GameboardTile, gift:Boolean=false ):void				{					if( !gift )					{						if( weapon.consumable )						{							MainGameController.getInstance().updateConsumableItemUseCount( weapon, weapon.useCount-1 );						}						else						{							GameLevelCurrentData.getInstance().chickenCount -= weapon.cost;						}					}										_gameboardReference.gameboardMenuClip.updateMenu();										if( weapon.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_HEALING_INDEX) )					{						ConsoleBroadcaster.broadcast( "GameboardController", "heal weapon display object" );												//trace( "tile: "+tile );												var gateDisplayObject:GateDisplayObject = _gateDisplayObjectController.getGateAt(tile.column);						//_gameboardReference.gateTiles[tile.column].recover( weapon );						if( tile.row < 0 && gateDisplayObject != null )						{							//Heal gates							gateDisplayObject.recover( weapon );							var randomIndex:int = int( Math.random()*weapon.hitSoundDataIds.length );							//trace( "play sound "+projectileDisplayObject.attackingGameObject.hitSoundDataIds[randomIndex] );							//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlaySound", this, {soundDataId:weapon.hitSoundDataIds[randomIndex], loop:false} );							var soundData:SoundData = SoundsIndex.getInstance().getSoundById(weapon.hitSoundDataIds[randomIndex]);							SoundEffectPlayer.getInstance().playLibrarySound( soundData.soundId, false, soundData.soundId, soundData.soundId );							soundData = null;						}												if( weapon.deathParticleEffect != '' )						{							var globalPosition:Point = gateDisplayObject.contentClip.parent.localToGlobal( new Point(gateDisplayObject.contentClip.x, gateDisplayObject.contentClip.y) );							//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticle", this, {gameLevelDisplayObject:gateDisplayObject, particleId:weapon.deathParticleEffect, globalPosition:globalPosition} );							EventNotificationCenter.getInstance().sendSignal( "onPlayParticle", this, {gameLevelDisplayObject:gateDisplayObject, particleId:weapon.deathParticleEffect, globalPosition:globalPosition} );						}												//TOOD:						//	Can we heal weapons too ?					}					else					{						var weaponDisplayObject:WeaponDisplayObject = WeaponDisplayObjectFactory.createWeaponDisplayObject( weapon );												weaponDisplayObject.inIsometricView = this._inIsometricView;						weaponDisplayObject.currentTile = tile;						weaponDisplayObject.contentClip.name = "weapon"+_totalWeapons+"_mc";												_weaponDisplayObjectController.addWeapon( weaponDisplayObject );												if( weaponDisplayObject is ShieldWeaponDisplayObject )						{													}						else if( weaponDisplayObject is AdditionWeaponDisplayObject )						{													}						//else if( weaponDisplayObject is TrapWeaponDisplayObject )						//{							//trace( "add TrapWeaponDisplayObject" );						//}						else if( !(weaponDisplayObject is BombWeaponDisplayObject) && !(weaponDisplayObject is PathWeaponDisplayObject) )						{							_attackingDisplayObjectController.addWeapon( weaponDisplayObject );						}												_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_HAPPY_ANIMATION );												++_totalWeapons;					}										//trace( "weapon placed on "+tile );					/**/					if( !weaponDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ADDITION_INDEX) && !weaponDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SHIELD_INDEX) )					{						if( tile.row != 0 && _gameboardReference.tiles[tile.row-1][tile.column].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[tile.row-1][tile.column].hasExtraHitArea3 = true;							//trace( _gameboardReference.tiles[tile.row-1][tile.column]+' hasExtraHitArea3' );						}												if( tile.row != GameLevelDataIndex.getInstance().boardMaxRows-1 && _gameboardReference.tiles[tile.row+1][tile.column].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[tile.row+1][tile.column].hasExtraHitArea1 = true;							//trace( _gameboardReference.tiles[tile.row+1][tile.column]+' hasExtraHitArea1' );						}												if( tile.column != 0 && _gameboardReference.tiles[tile.row][tile.column-1].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[tile.row][tile.column-1].hasExtraHitArea4 = true;							//trace( _gameboardReference.tiles[tile.row][tile.column-1]+' hasExtraHitArea' );						}												if( tile.column != GameLevelDataIndex.getInstance().boardMaxColumns-1 && _gameboardReference.tiles[tile.row][tile.column+1].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )						{							_gameboardReference.tiles[tile.row][tile.column+1].hasExtraHitArea2 = true;							//trace( _gameboardReference.tiles[tile.row][tile.column+1]+' hasExtraHitArea2' );						}					}					/**/					var trackingDataController:TrackingDataController = new TrackingDataController();						trackingDataController.saveTrackingWeaponUsage( MainGameController.getInstance().currentUser.id, _gameLevel.id, weapon.id, 1 );				}							/** removeWeapon			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	public function removeWeapon( wdo:WeaponDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "removeWeapon();" );										var row:int = wdo.currentTile.row;					var column:int = wdo.currentTile.column;										_attackingDisplayObjectController.removeWeapon( wdo );					_weaponDisplayObjectController.removeWeapon( wdo );					/*					if( row != 0 && _gameboardReference.tiles[row-1][column].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )					{						_gameboardReference.tiles[row-1][column].hasExtraHitArea3 = false;					}										if( row != GameLevelDataIndex.getInstance().boardMaxRows-1 && _gameboardReference.tiles[row+1][column].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )					{						_gameboardReference.tiles[row+1][column].hasExtraHitArea1 = false;					}										if( column != 0 && _gameboardReference.tiles[row][column-1].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )					{						_gameboardReference.tiles[row][column-1].hasExtraHitArea4 = false;					}										if( column != GameLevelDataIndex.getInstance().boardMaxColumns-1 && _gameboardReference.tiles[row][column+1].tileTypeIndex == GameboardTile.TILE_TYPE_PATH_INDEX )					{						_gameboardReference.tiles[row][column+1].hasExtraHitArea2 = false;					}					*/				}							/** removeWeaponInTile			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	public function removeWeaponInTile( tile:GameboardTile ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "removeWeaponInTile("+tile+");" );										var weaponDO:WeaponDisplayObject  = _weaponDisplayObjectController.getWeaponInTile( tile );										var globalPosition:Point = weaponDO.contentClip.parent.localToGlobal( new Point(weaponDO.contentClip.x, weaponDO.contentClip.y) );					//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticleAnimation", this, {particleCacheId:"TakeawayPoof", globalPosition:globalPosition} );					EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {particleCacheId:"TakeawayPoof", globalPosition:globalPosition} );										//SoundEffectPlayer.getInstance().setVolume( SoundsIndex.getInstance().getSoundBySoundId("sfx_delete_weapon.wav").volume, 0, "sfx_delete_weapon.wav" );					SoundEffectPlayer.getInstance().playLibrarySound( "sfx_delete_weapon.wav", false, "sfx_delete_weapon.wav", "sfx_delete_weapon.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );										//_weaponDisplayObjectController.removeWeaponInTile( tile );					removeWeapon( weaponDO );										if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevelDelete )					{						if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_2" )						{							//_gameboardReference.removeEventListener( BoogaEvent.ON_DELETE_WEAPON_ON_INVALID_SPOT, handleDeleteWeaponOnInvalidSpot );							_gameboardReference.onWeaponDeletedOnInvalidSpot.remove( handleWeaponDeletedOnInvalidSpot );														unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_3";														//var globalPosition:Point = _gameboardReference.gameboardMenu_mc.delete_mc.parent.localToGlobal( new Point(_gameboardReference.gameboardMenu_mc.delete_mc.x, _gameboardReference.gameboardMenu_mc.delete_mc.y) );							//EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_3")} );														_gameboardReference.gameboardMenuClip.getGameboardMenuIcon(0).setDeactive();							_gameboardReference.gameboardMenuClip.getGameboardMenuIcon(2).setDeactive();							var bombMenuIcon:GameboardMenuContentIcon = _gameboardReference.gameboardMenuClip.getGameboardMenuIcon(1);							//trace( "firstMenuIcon: "+firstMenuIcon );							var globalPosition:Point = bombMenuIcon.contentClip.parent.localToGlobal( new Point(bombMenuIcon.contentClip.x+25, bombMenuIcon.contentClip.y+25) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_3"), transparent:true} );														//pauseForGodAttack();						}						/*						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_4" )						{							_gameboardReference.removeEventListener( BoogaEvent.ON_DELETE_WEAPON_ON_INVALID_SPOT, handleDeleteWeaponOnInvalidSpot );														unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_5";														MainGameController.getInstance().currentUser.tutorialGameLevelDelete = false;														var userDataController:UserDataController = new UserDataController();								userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "game_level_delete", 0 );													}						/*						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_DELETE_6" )						{							unpauseForGodAttack();							EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_7";														MainGameController.getInstance().currentUser.tutorialGameLevelDelete = false;														var userDataController:UserDataController = new UserDataController();								userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "game_level_delete", 0 );														//var globalPosition:Point = _gameboardReference.gameboardMenu_mc.delete_mc.parent.localToGlobal( new Point(_gameboardReference.gameboardMenu_mc.delete_mc.x, _gameboardReference.gameboardMenu_mc.delete_mc.y) );							//EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, text:StringsIndex.getInstance().getStringByName("TUTORIAL_DELETE_3")} );														//pauseForGodAttack();						}						*/					}				}							/** addEnemy			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	public function addEnemy( edo:EnemyDisplayObject ):void				{									}*/								public function removeEnemy( edo:EnemyDisplayObject ):void				{					_attackingDisplayObjectController.removeEnemy( edo );					_enemyDisplayObjectController.removeEnemy( edo );										//MainGameController.getInstance().runGarbageCollector();					//trace( "System.totalMemory: "+System.totalMemory );				}							/** addGod			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	public function addGod( god:God, tile:GameboardTile, gift:Boolean=false ):void				{					var godDisplayObject:GodDisplayObject = new GodDisplayObject();						godDisplayObject.contentClip = new (getDefinitionByName("GodDisplayObjectLibrary") as Class)();						godDisplayObject.init();						godDisplayObject.god = god;						godDisplayObject.inIsometricView = _inIsometricView;						godDisplayObject.currentTile = tile;						godDisplayObject.contentClip.name = "god"+_totalGods+"_mc";										/*					if( god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_TRICKSTER_INDEX) )					{						_isTricksterGodInPlay = true;					}					else if( god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_WIND_INDEX) )					{											}					else if( god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_WARRIOR_INDEX) )					{											}					*/					/*					if( displayObject.god.consumable )					{						MainGameController.getInstance().updateConsumableItemUseCount( displayObject.god, displayObject.god.useCount-1 );					}					else					{						GameLevelCurrentData.getInstance().chickenCount -= displayObject.god.cost;					}					*/										if( !gift )					{						MainGameController.getInstance().updateConsumableItemUseCount( godDisplayObject.god, godDisplayObject.god.useCount-1 );					}										_gameboardReference.gameboardMenuClip.updateMenu();										godDisplayObject.positionIn2D.x = godDisplayObject.currentTile.positionIn2D.x;					godDisplayObject.positionIn2D.y = godDisplayObject.currentTile.positionIn2D.y;					godDisplayObject.render();										_godDisplayObjectController.addGod( godDisplayObject );										++_totalGods;										_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_PRAY_ANIMATION );										var trackingDataController:TrackingDataController = new TrackingDataController();						trackingDataController.saveTrackingGodUsage( MainGameController.getInstance().currentUser.id, _gameLevel.id, god.id, 1 );				}								public function removeGod( displayObject:GodDisplayObject ):void				{					_godDisplayObjectController.removeGod( displayObject );				}							/** setTricksterGodInPlay			  *	---------------------------------------------------------------------------- *			  *	Sets the Trickster God in play, reverse the movements of all enemies on the 			  *	board for the duration set. When enemies reach the beginning of spawn point			  *	or the set duration has expired, they will move normally again.			  *	---------------------------------------------------------------------------- */			 	public function setTricksterGodInPlay( duration:Number ):void				{					_isTricksterGodInPlay = true;										if( _tricksterGodDurationTimer == null )					{						_tricksterGodDurationTimer = new CustomTimer( duration, 1 );						//_tricksterGodDurationTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleTricksterGodDurationTimerCompleted, false, 0, true );						_tricksterGodDurationTimer.onTimerCompleted.add( handleTricksterGodDurationTimerCompleted );					}					else if( _tricksterGodDurationTimer.isRunning )					{						_tricksterGodDurationTimer.stop();						_tricksterGodDurationTimer.reset();					}										_tricksterGodDurationTimer.start();										for( var i:int=0; i<_enemyDisplayObjectController.enemyDisplayObjectsLength; ++i )					{						_enemyDisplayObjectController.enemyDisplayObjects[i].reversed = true;					}				}							/** handleTricksterGodDurationTimerCompleted			  *	---------------------------------------------------------------------------- *			  *	When the Trickster God duration is out, make the enemies walk normally again.			  *	---------------------------------------------------------------------------- */			 	private function handleTricksterGodDurationTimerCompleted( timer:CustomTimer ):void				{					_tricksterGodDurationTimer.reset();										for( var i:int=0; i<_enemyDisplayObjectController.enemyDisplayObjectsLength; ++i )					{						_enemyDisplayObjectController.enemyDisplayObjects[i].reversed = false;					}				}							/** setWarriorGodInPlay			  *	---------------------------------------------------------------------------- *			  *	Sets the Warrior God in play, buffs up the weapons on board. The weapons			  *	will shoot at twice of the rate they're shooting right now.			  *	---------------------------------------------------------------------------- */			 	public function setWarriorGodInPlay( duration:Number ):void				{					_isWarriorGodInPlay = true;										if( _warriorGodDurationTimer == null )					{						_warriorGodDurationTimer = new CustomTimer( duration, 1 );						//_warriorGodDurationTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleWarriorGodDurationTimerCompleted, false, 0, true );						_warriorGodDurationTimer.onTimerCompleted.add( handleWarriorGodDurationTimerCompleted );					}					else if( _warriorGodDurationTimer.isRunning )					{						_warriorGodDurationTimer.stop();						_warriorGodDurationTimer.reset();					}										_warriorGodDurationTimer.start();										for( var i:int=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )					{						_weaponDisplayObjectController.weaponDisplayObjects[i].speedUpByWarriorGod();					}										_gameboardReference.highlightWeaponPoweredUpClips();				}							/** handleWarriorGodDurationTimerCompleted			  *	---------------------------------------------------------------------------- *			  *	When the Warrior God duration is out, make the weapons to shoot at normal			  *	speed again.			  *	---------------------------------------------------------------------------- */			 	private function handleWarriorGodDurationTimerCompleted( timer:CustomTimer ):void				{					_warriorGodDurationTimer.reset();										_isWarriorGodInPlay = false;										for( var i:int=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )					{						_weaponDisplayObjectController.weaponDisplayObjects[i].slowDownFromWarriorGod();					}										_gameboardReference.removeHighlightWeaponPoweredUpClips();				}							/** setWindGoddessInPlay			  *	---------------------------------------------------------------------------- *			  *	Sets the Wind Goddess in play, pushes all enemies back to starting point and			  *	after enemies reach the starting point, they will walk normally again.			  *	---------------------------------------------------------------------------- */			 	public function setWindGoddessInPlay():void				{					//_isWindGoddessInPlay = true;										for( var i:int=0; i<_enemyDisplayObjectController.enemyDisplayObjectsLength; ++i )					{						_enemyDisplayObjectController.enemyDisplayObjects[i].pushedBack = true;					}				}							/** handleWindGoddessDurationTimerComplete			  *	---------------------------------------------------------------------------- *			  *				  *	---------------------------------------------------------------------------- 			 	private function handleWindGoddessDurationTimerCompleted( event:TimerEvent ):void				{					_isWindGoddessInPlay = false;				}*/							/** setDeathGodInPlay			  *	---------------------------------------------------------------------------- *			  *				  *	---------------------------------------------------------------------------- */			 	public function setDeathGodInPlay():void				{					_isDeathGodInPlay = true;										var globalPosition:Point;										//for( var i:int=0; i<_enemyDisplayObjectController.enemyDisplayObjectsLength; ++i )					while( _enemyDisplayObjectController.enemyDisplayObjectsLength > 0 )					{						globalPosition = _enemyDisplayObjectController.enemyDisplayObjects[0].contentClip.parent.localToGlobal( new Point(_enemyDisplayObjectController.enemyDisplayObjects[0].contentClip.x, _enemyDisplayObjectController.enemyDisplayObjects[0].contentClip.y) );						//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayDeathGodParticleAnimationObject", this, {globalPosition:globalPosition} );						EventNotificationCenter.getInstance().sendSignal( "onPlayDeathGodParticleAnimationObject", this, {globalPosition:globalPosition} );												removeEnemy( _enemyDisplayObjectController.enemyDisplayObjects[0] );						--_enemiesLeft;					}									}							/** setDeathGodOutOfPlay			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	public function setDeathGodOutOfPlay():void				{					_isDeathGodInPlay = false;										checkIfAllWaveZonesEnded();				}											/** startShakingGameboardForGod			  *	---------------------------------------------------------------------------- *			  *	Shakes the gameboard when the god is in play to add more effect to the god			  *	power.			  *	---------------------------------------------------------------------------- */			 	public function startShakingGameboardForGod():void				{					if( _shakeGameboardTimer == null )					{						_shakeGameboardTimer = new CustomTimer( 25, 50 );						//_shakeGameboardTimer.addEventListener( TimerEvent.TIMER, handleShakeGameboardTimerFired, false, 0, true );						//_shakeGameboardTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleShakeGameboardTimerCompleted, false, 0, true );						_shakeGameboardTimer.onTimerFired.add( handleShakeGameboardTimerFired );						_shakeGameboardTimer.onTimerCompleted.add( handleShakeGameboardTimerCompleted );					}										_shakeGameboardTimer.start();				}							/** handleShakeGameboardTimerFired			  *	---------------------------------------------------------------------------- */			 	private function handleShakeGameboardTimerFired( timer:CustomTimer ):void				{					//_gameboardReference.contentClip.x += Math.random()*200 - Math.random()*200;					//_gameboardReference.contentClip.y += Math.random()*200 - Math.random()*200;					switch( _shakeGameboardTimer.currentCount )					{						case 1:						case 6:						case 14:						case 21:						case 35:						case 43:							_gameboardReference.contentClip.x = -10;							_gameboardReference.contentClip.y = 0;							break;												case 2:						case 8:						case 17:						case 19:						case 27:						case 42:						case 45:							_gameboardReference.contentClip.x = 10;							_gameboardReference.contentClip.y = 0;							break;												case 3:						case 18:						case 28:						case 33:							_gameboardReference.contentClip.x = 5;							_gameboardReference.contentClip.y = 10;							break;												case 4:						case 7:						case 34:						case 41:						case 50:							_gameboardReference.contentClip.x = 5;							_gameboardReference.contentClip.y = -10;							break;												case 5:						case 10:						case 16:						case 32:						case 44:							_gameboardReference.contentClip.x = -10;							_gameboardReference.contentClip.y = -5;							break;												case 9:						case 15:						case 23:						case 31:						case 47:							_gameboardReference.contentClip.x = 5;							_gameboardReference.contentClip.y = 5;							break;												case 11:						case 22:						case 36:						case 40:						case 48:							_gameboardReference.contentClip.x = -10;							_gameboardReference.contentClip.y = 5;							break;												case 12:						case 26:						case 29:						case 38:							_gameboardReference.contentClip.x = -5;							_gameboardReference.contentClip.y = 10;							break;												case 13:						case 20:						case 25:						case 37:						case 49:							_gameboardReference.contentClip.x = 10;							_gameboardReference.contentClip.y = 10;							break;												case 24:						case 30:						case 39:							_gameboardReference.contentClip.x = -5;							_gameboardReference.contentClip.y = -10;							break;					}				}							/** handleShakeGameboardTimerCompleted			  *	---------------------------------------------------------------------------- *			  *	Shake timer has completed.			  *	---------------------------------------------------------------------------- */			 	private function handleShakeGameboardTimerCompleted( timer:CustomTimer ):void				{					stopShakingGameboardForGod();				}							/** stopShakingGameboardForGod			  *	---------------------------------------------------------------------------- *			  *	Stops shaking the gameboard and reverts the gameboard position back to normal.			  *	---------------------------------------------------------------------------- */			 	public function stopShakingGameboardForGod():void				{					if( _shakeGameboardTimer != null )					{						_shakeGameboardTimer.stop();						_shakeGameboardTimer.reset();					}										_gameboardReference.contentClip.x = 0;					_gameboardReference.contentClip.y = 0;				}											/**	******************************************* *			  * VillagerDisplayObject Events			  *	******************************************* */			 	public function addVillager( gameLevelVillagerObject:GameLevelVillagerObject ):void				{					var villagerDisplayObject:VillagerDisplayObject = new VillagerDisplayObject();						villagerDisplayObject.contentClip = new (getDefinitionByName("VillagerDisplayObjectLibrary") as Class)();						villagerDisplayObject.init();						villagerDisplayObject.gameLevelVillagerObject = gameLevelVillagerObject;						villagerDisplayObject.contentClip.layerNumber = gameLevelVillagerObject.layer;						villagerDisplayObject.positionIn2D = _gameboardReference.villageTiles[gameLevelVillagerObject.row][gameLevelVillagerObject.column].positionIn2D.clone().add( new Point(gameLevelVillagerObject.positionX, gameLevelVillagerObject.positionY) );						villagerDisplayObject.inIsometricView = _gameboardReference.inIsometricView;						villagerDisplayObject.villager = GameLevelDataIndex.getInstance().getVillager( gameLevelVillagerObject.villagerId );						villagerDisplayObject.render();										_villagerDisplayObjectController.addVillager( villagerDisplayObject );				}								public function removeVillager( displayObject:VillagerDisplayObject ):void				{					_villagerDisplayObjectController.removeVillager( displayObject );				}								protected function handleVillagerRunningStopped():void				{					trace( "handleVillagerRunningStopped();" );										//_gameboardReference.introAnimationViewClip.onTutorialLevelVillagerRunningStopped.remove( handleVillagerRunningStopped );										for( var i:int=0; i<_villagerDisplayObjectController.villagerDisplayObjectsLength; ++i )					{						if( _villagerDisplayObjectController.villagerDisplayObjects[i].villager.id == 3 )						{							_villagerDisplayObjectController.villagerDisplayObjects[i].contentClip.visible = true;						}					}					//_villagerDisplayObjectController.villagerDisplayObjects[ _villagerDisplayObjectController.villagerDisplayObjectsLength-1 ].contentClip.visible = true;				}							/**	******************************************* *			  * ChickenController Events			  *	******************************************* */			 				/** handleChickenCollected			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handleChickenCollected( event:GameLevelEvent ):void				{					//GameLevelCurrentData.getInstance().chickenCount += event.customParameters.chickenCount;										//_gameboardReference.gameboardMenuClip.updateMenu();										//trace( "_gameboardReference.chickenAnimation_mc: "+_gameboardReference.chickenAnimation_mc );					//trace( "event.customParameters.chickenDisplayObject: "+event.customParameters.chickenDisplayObject );										//var position:Point = UtilFunctions.localToLocal( event.customParameters.chickenDisplayObject.contentClip.parent, _gameboardReference.chickenAnimation_mc );					//event.customParameters.chickenDisplayObject.contentClip.x = position.x;					//event.customParameters.chickenDisplayObject.contentClip.y = position.y;					//_gameboardReference.chickenAnimation_mc.addChild( event.customParameters.chickenDisplayObject.contentClip );				}*/								protected function handleChickenObtainedAnimationComplete( chickenDisplayObjectController:ChickenDisplayObjectController, chickenCount:int ):void				{					GameLevelCurrentData.getInstance().chickenCount += chickenCount;					_gameboardReference.gameboardMenuClip.updateMenu();										if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevel )					{						EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );												if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_7" )						{							//trace( "chicken length: "+_chickenDisplayObjectController.chickenDisplayObjectsLength );														if( _chickenDisplayObjectController.chickenDisplayObjectsLength > 0 )							{								var globalPosition2:Point = _chickenDisplayObjectController.chickenDisplayObjects[0].contentClip.parent.localToGlobal( new Point(_chickenDisplayObjectController.chickenDisplayObjects[0].contentClip.x, _chickenDisplayObjectController.chickenDisplayObjects[0].contentClip.y) );								EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition2.x, targetY:globalPosition2.y, showText:false, introTutorial:true} );							}							else							{								MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_8";																unpauseForGodAttack();																var firstMenuIcon:GameboardMenuContentIcon = _gameboardReference.gameboardMenuClip.getGameboardMenuIcon(0);								//trace( "firstMenuIcon: "+firstMenuIcon );								var globalPosition:Point = firstMenuIcon.contentClip.parent.localToGlobal( new Point(firstMenuIcon.contentClip.x+25, firstMenuIcon.contentClip.y+25) );								EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );																_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_8") );																pauseForGodAttack();							}						}						else if( MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_10" )						{							if( _chickenDisplayObjectController.chickenDisplayObjectsLength > 0 )							{								var globalPosition3:Point = _chickenDisplayObjectController.chickenDisplayObjects[0].contentClip.parent.localToGlobal( new Point(_chickenDisplayObjectController.chickenDisplayObjects[0].contentClip.x, _chickenDisplayObjectController.chickenDisplayObjects[0].contentClip.y) );								EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition3.x, targetY:globalPosition3.y, showText:false, introTutorial:true} );							}							else							{								//_chickenDisplayObjectController.start();																//_gameboardReference.removeEventListener( GameLevelEvent.ON_MENU_ICON_SELECTED, handleMenuIconSelected );								//_gameboardReference.removeEventListener( GameLevelEvent.ON_WEAPON_ADDED, handleWeaponAdded );								_gameboardReference.onWeaponAdded.remove( handleWeaponAdded );								_gameboardReference.onMenuIconSelected.remove( handleMenuIconSelected );																MainGameController.getInstance().currentUser.tutorialGameLevel = false;																if( GameLevelCurrentData.getInstance().gift != null )								{									_gameboardReference.giftClip.show();								}																var userDataController:UserDataController = new UserDataController();									userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "game_level", 0 );																_gameboardReference.introAnimationViewClip.hideTutorialText();																//dispatchEvent( new BoogaEvent(BoogaEvent.ON_TUTORIAL_LEVEL_INTRO_FINISHED) );								onTutorialLevelIntroFinished.dispatch();								//onTutorialLevelIntroFinished = null;																unpauseForGodAttack();																EventNotificationCenter.getInstance().sendSignal( BoogaEvent.ON_PLAY_VIEW_CONTROLS_SHOW, this );							}						}											}										if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialSlotMachine && _gameLevel.slotEnabled && MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_SLOT_2" )					{						EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );												MainGameController.getInstance().currentUser.tutorialSlotMachine = false;						_gameboardReference.slotMachineClip.alwaysWin = false;												var userDataController2:UserDataController = new UserDataController();							userDataController2.updateUserTutorial( MainGameController.getInstance().currentUser.id, "slot_machine", 0 );												unpauseForGodAttack();					}										if( SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_CHICKEN_PARTICLE) )						EventNotificationCenter.getInstance().sendSignal( GameLevelEvent.ON_CHICKEN_OBTAINED_ANIMATION_COMPLETE, this );				}							/**	******************************************* *			  * WaveZoneController Events			  *	******************************************* */			 				/** handleEnemySpawned			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleEnemySpawned( event:CustomEvent ):void				protected function handleEnemySpawned( waveZone:WaveZone, enemy:Enemy, pathIndex:int ):void				{					var enemyDisplayObject:EnemyDisplayObject = EnemyDisplayObjectFactory.createEnemyDisplayObject( enemy as Enemy );										if( MainGameController.getInstance().currentUser.tutorialGameLevel )					{						enemyDisplayObject.currentSpeed = 6;					}										//enemyDisplayObject.attackingGameObject = enemy;					enemyDisplayObject.inIsometricView = _inIsometricView;					enemyDisplayObject.inSpawnPath = true;					enemyDisplayObject.spawnPath = waveZone.spawnPaths[ pathIndex ];					enemyDisplayObject.path = waveZone.paths[ pathIndex ];					//enemyDisplayObject.pathIndex = _attackingDisplayObjectController.getPathIndex( enemyDisplayObject.currentTile );					enemyDisplayObject.contentClip.name = "enemy"+_enemiesSpawned+"_mc";										_enemyDisplayObjectController.addEnemy( enemyDisplayObject );										for( var i:int=0; i<_gameboardReference.enemyIconClips.length; ++i )					{						if( _gameboardReference.enemyIconClips[i].enemyId == enemy.id )							_gameboardReference.enemyIconClips[i].updateCountBy(1);					}										++_enemiesSpawned;										if( !_isDeathGodInPlay )					{						_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_WORRIED_ANIMATION );					}					else					{						//trace( "enemyDisplayObject.contentClip.x: "+enemyDisplayObject.contentClip.x+", y: "+enemyDisplayObject.contentClip.y );												var globalPosition:Point = enemyDisplayObject.contentClip.parent.localToGlobal( new Point(enemyDisplayObject.contentClip.x, enemyDisplayObject.contentClip.y) );						//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayDeathGodParticleAnimationObject", this, {globalPosition:globalPosition} );						EventNotificationCenter.getInstance().sendSignal( "onPlayDeathGodParticleAnimationObject", this, {globalPosition:globalPosition} );												removeEnemy( enemyDisplayObject );						--_enemiesLeft;					}									}							/** handleWaveZoneEnded			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handleWaveZoneEnded( event:CustomEvent ):void				{					ConsoleBroadcaster.broadcast( "GameboardController", "handleWaveZoneEnded("+event.customParameters.waveZoneId+");" );				}*/							/**	******************************************* *			  * WeaponDisplayObjectCotroller Events			  *	******************************************* */			  				/** handleWeaponAttackTimerFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleWeaponAttackTimerFired( weaponDisplayObject:WeaponDisplayObject ):void				{					_attackingDisplayObjectController.checkForTargets( weaponDisplayObject );				}							/** handleProjectileWeaponFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleProjectileWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootTo:Point, altitude:Number ):void				{					//var projectileDisplayObject:ProjectileDisplayObject = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();					var projectile:Projectile = new Projectile();						projectile.upAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;						projectile.upAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.upAnimationObject.customPositions[0];						projectile.downAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;						projectile.downAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.downAnimationObject.customPositions[0];										//TODO:					//	See if we can reuse the projectiles and if it helps with performance..					var projectileDisplayObject:ProjectileDisplayObject;					/**/					//trace( "unused projectile objects length: "+_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength );					for( var i:int=0; i<_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength; ++i )					{						if( _projectileDisplayObjectController.unusedProjectileDisplayObjects[i].type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							//trace( "reuse projectile display object" );							projectileDisplayObject = _projectileDisplayObjectController.unusedProjectileDisplayObjects.splice( i, 1 )[0];							projectileDisplayObject.reuse();							_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength = _projectileDisplayObjectController.unusedProjectileDisplayObjects.length;							break;						}					}					/**/					if( projectileDisplayObject == null )					{						//trace( "create new projectile display object" );						projectileDisplayObject = new ProjectileDisplayObject();						projectileDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						projectileDisplayObject.init();					}										projectileDisplayObject.direction = weaponDisplayObject.direction;					projectileDisplayObject.projectile = projectile;					projectileDisplayObject.pathIndex = weaponDisplayObject.pathIndex;					projectileDisplayObject.positionIn2D = weaponDisplayObject.positionIn2D.clone();					projectileDisplayObject.inIsometricView = _inIsometricView;					//projectileDisplayObject.destinationPointIn2D = shootTo;					projectileDisplayObject.setDestinationPointIn2D( shootTo, altitude );					projectileDisplayObject.attackingGameObject = weaponDisplayObject.attackingGameObject;					projectileDisplayObject.path = weaponDisplayObject.path;					projectileDisplayObject.currentIndexInPath = weaponDisplayObject.currentIndexInPath;										//trace( "startPositionIn2D: "+projectileDisplayObject.positionIn2D );										_projectileDisplayObjectController.addProjectile( projectileDisplayObject );				}							/** handleCatapultWeaponFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleCatapultWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootTo:Point, altitude:Number ):void				{					//var upAnimationObjectCustomPosition:Point = GameLevelUtil.getPositionIn2D( weaponDisplayObject.attackingGameObject.upAnimationObject.customPositions[0] );					//var downAnimationObjectCustomPosition:Point = GameLevelUtil.getPositionIn2D( weaponDisplayObject.attackingGameObject.downAnimationObject.customPositions[0] );										var projectile:Projectile = new Projectile();						projectile.upAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;						projectile.upAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.upAnimationObject.customPositions[0];						projectile.upAnimationObject.flippedCustomPosition = weaponDisplayObject.attackingGameObject.upAnimationObject.flippedCustomPositions[0];						//projectile.upAnimationObject.customPosition = upAnimationObjectCustomPosition;						projectile.downAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;						projectile.downAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.downAnimationObject.customPositions[0];						projectile.downAnimationObject.flippedCustomPosition = weaponDisplayObject.attackingGameObject.downAnimationObject.flippedCustomPositions[0];						//projectile.downAnimationObject.customPosition = downAnimationObjectCustomPosition;										//trace( 'weapon direction: '+weaponDisplayObject.direction );										var catapultDisplayObject:CatapultDisplayObject = new CatapultDisplayObject();						catapultDisplayObject.contentClip = new ( getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						catapultDisplayObject.init();						catapultDisplayObject.direction = weaponDisplayObject.direction;						catapultDisplayObject.projectile = projectile;						catapultDisplayObject.pathIndex = weaponDisplayObject.pathIndex;						catapultDisplayObject.positionIn2D = weaponDisplayObject.positionIn2D.clone();						catapultDisplayObject.inIsometricView = _inIsometricView;						catapultDisplayObject.setDestinationPointIn2D( shootTo, altitude );						catapultDisplayObject.attackingGameObject = weaponDisplayObject.attackingGameObject;										_projectileDisplayObjectController.addProjectile( catapultDisplayObject );				}							/** handleBombWeaponExploded			  *	---------------------------------------------------------------------------- *			  *	Attacks all enemies within the range of the bomb weapons.			  *	---------------------------------------------------------------------------- 			 	protected function handleBombWeaponExploded( event:GameLevelEvent ):void				{					//_enemyDisplayObjectController.attackEnemiesInARange( event.customParameters.weaponDisplayObject.positionIn2D, event.customParameters.range, event.customParameters.weaponDisplayObject );															if( WeaponDisplayObject(event.customParameters.weaponDisplayObject).attackingGameObject.id == 6 )					{						var globalPosition:Point = (event.customParameters.weaponDisplayObject as WeaponDisplayObject).contentClip.parent.localToGlobal( new Point(event.customParameters.weaponDisplayObject.contentClip.x, event.customParameters.weaponDisplayObject.contentClip.y) );						EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticle", this, {gameLevelDisplayObject:WeaponDisplayObject(event.customParameters.weaponDisplayObject), particleId:"tntexplosion", globalPosition:globalPosition} );					}									}*/							/** handleTrapWeaponFired			  *	---------------------------------------------------------------------------- *			  *	Attacks all enemies within the range of the trap weapons.			  *	---------------------------------------------------------------------------- */			 	protected function handleTrapWeaponFired( weaponDisplayObject:WeaponDisplayObject, range:Number ):void				{					_enemyDisplayObjectController.attackEnemiesInARange( weaponDisplayObject.positionIn2D, range, weaponDisplayObject, weaponDisplayObject.attackingGameObject.power );				}							/** handleMultipleDirectionsProjectileFired			  *	---------------------------------------------------------------------------- *			  *	Fires off projectiles in four different directions when there are enemies			  *	in the range of the weapon.			  *	---------------------------------------------------------------------------- */			 	protected function handleMultipleDirectionsProjectileWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootToUp:Point, shootToRight:Point, shootToDown:Point, shootToLeft:Point, altitude:Number ):void				{					var projectileDisplayObject:ProjectileDisplayObject;					/**/					//trace( "unused projectile objects length: "+_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength );					for( var i:int=0; i<_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength; ++i )					{						if( _projectileDisplayObjectController.unusedProjectileDisplayObjects[i].type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							//trace( "reuse projectile display object" );							projectileDisplayObject = _projectileDisplayObjectController.unusedProjectileDisplayObjects.splice( i, 1 )[0];							projectileDisplayObject.reuse();							_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength = _projectileDisplayObjectController.unusedProjectileDisplayObjects.length;							break;						}					}					/**/					if( projectileDisplayObject == null )					{						//trace( "create new projectile display object" );						projectileDisplayObject = new ProjectileDisplayObject();						projectileDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						projectileDisplayObject.init();					}										var projectile:Projectile = new Projectile();						projectile.upAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;						projectile.upAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.upAnimationObject.customPositions[0];						projectile.downAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;						projectile.downAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.downAnimationObject.customPositions[0];										projectileDisplayObject.direction = GameLevelUtil.DIRECTION_UP;					projectileDisplayObject.projectile = projectile;					projectileDisplayObject.pathIndex = weaponDisplayObject.pathIndex;					projectileDisplayObject.positionIn2D = weaponDisplayObject.positionIn2D.clone();					projectileDisplayObject.inIsometricView = _inIsometricView;					projectileDisplayObject.setDestinationPointIn2D( shootToUp, altitude );					projectileDisplayObject.attackingGameObject = weaponDisplayObject.attackingGameObject;										_projectileDisplayObjectController.addProjectile( projectileDisplayObject );					projectileDisplayObject = null;										//Add projectile #2					//trace( "unused projectile objects length: "+_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength );					for( i=0; i<_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength; ++i )					{						if( _projectileDisplayObjectController.unusedProjectileDisplayObjects[i].type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							//trace( "reuse projectile display object" );							projectileDisplayObject = _projectileDisplayObjectController.unusedProjectileDisplayObjects.splice( i, 1 )[0];							projectileDisplayObject.reuse();							_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength = _projectileDisplayObjectController.unusedProjectileDisplayObjects.length;							break;						}					}										if( projectileDisplayObject == null )					{						//trace( "create new projectile display object" );						projectileDisplayObject = new ProjectileDisplayObject();						projectileDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						projectileDisplayObject.init();					}										projectile = new Projectile();					projectile.upAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;					projectile.upAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.upAnimationObject.customPositions[1];					projectile.downAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;					projectile.downAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.downAnimationObject.customPositions[1];										projectileDisplayObject.direction = GameLevelUtil.DIRECTION_RIGHT;					projectileDisplayObject.projectile = projectile;					projectileDisplayObject.pathIndex = weaponDisplayObject.pathIndex;					projectileDisplayObject.positionIn2D = weaponDisplayObject.positionIn2D.clone();					projectileDisplayObject.inIsometricView = _inIsometricView;					projectileDisplayObject.setDestinationPointIn2D( shootToRight, altitude );					projectileDisplayObject.attackingGameObject = weaponDisplayObject.attackingGameObject;										_projectileDisplayObjectController.addProjectile( projectileDisplayObject );					projectileDisplayObject = null;										//Add projectile #3					//trace( "unused projectile objects length: "+_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength );					for( i=0; i<_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength; ++i )					{						if( _projectileDisplayObjectController.unusedProjectileDisplayObjects[i].type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							//trace( "reuse projectile display object" );							projectileDisplayObject = _projectileDisplayObjectController.unusedProjectileDisplayObjects.splice( i, 1 )[0];							projectileDisplayObject.reuse();							_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength = _projectileDisplayObjectController.unusedProjectileDisplayObjects.length;							break;						}					}										if( projectileDisplayObject == null )					{						//trace( "create new projectile display object" );						projectileDisplayObject = new ProjectileDisplayObject();						projectileDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						projectileDisplayObject.init();					}										projectile = new Projectile();					projectile.upAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;					projectile.upAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.upAnimationObject.customPositions[2];					projectile.downAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;					projectile.downAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.downAnimationObject.customPositions[2];										projectileDisplayObject.direction = GameLevelUtil.DIRECTION_DOWN;					projectileDisplayObject.projectile = projectile;					projectileDisplayObject.pathIndex = weaponDisplayObject.pathIndex;					projectileDisplayObject.positionIn2D = weaponDisplayObject.positionIn2D.clone();					projectileDisplayObject.inIsometricView = _inIsometricView;					projectileDisplayObject.setDestinationPointIn2D( shootToDown, altitude );					projectileDisplayObject.attackingGameObject = weaponDisplayObject.attackingGameObject;										_projectileDisplayObjectController.addProjectile( projectileDisplayObject );					projectileDisplayObject = null;										//Add projectile #4					//trace( "unused projectile objects length: "+_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength );					for( i=0; i<_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength; ++i )					{						if( _projectileDisplayObjectController.unusedProjectileDisplayObjects[i].type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							//trace( "reuse projectile display object" );							projectileDisplayObject = _projectileDisplayObjectController.unusedProjectileDisplayObjects.splice( i, 1 )[0];							projectileDisplayObject.reuse();							_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength = _projectileDisplayObjectController.unusedProjectileDisplayObjects.length;							break;						}					}										if( projectileDisplayObject == null )					{						//trace( "create new projectile display object" );						projectileDisplayObject = new ProjectileDisplayObject();						projectileDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						projectileDisplayObject.init();					}										projectile = new Projectile();					projectile.upAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;					projectile.upAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.upAnimationObject.customPositions[3];					projectile.downAnimationObject = weaponDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;					projectile.downAnimationObject.customPosition = weaponDisplayObject.attackingGameObject.downAnimationObject.customPositions[3];										projectileDisplayObject.direction = GameLevelUtil.DIRECTION_LEFT;					projectileDisplayObject.projectile = projectile;					projectileDisplayObject.pathIndex = weaponDisplayObject.pathIndex;					projectileDisplayObject.positionIn2D = weaponDisplayObject.positionIn2D.clone();					projectileDisplayObject.inIsometricView = _inIsometricView;					projectileDisplayObject.setDestinationPointIn2D( shootToLeft, altitude );					projectileDisplayObject.attackingGameObject = weaponDisplayObject.attackingGameObject;										_projectileDisplayObjectController.addProjectile( projectileDisplayObject );									}							/** handlePathWeaponMovedToNextPoint			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handlePathWeaponMovedToNextPoint( weaponDisplayObject:WeaponDisplayObject ):void				{					//ConsoleBroadcaster.broadcast( "GameboardController", "handleFullLaneWeaponMoving();" );										_attackingDisplayObjectController.hitAndFlagDisplayObjectsBy( weaponDisplayObject, weaponDisplayObject.currentTile );				}							/** handlePathWeaponPathEnded			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handlePathWeaponPathEnded( weaponDisplayObject:WeaponDisplayObject ):void				{					_attackingDisplayObjectController.resetDisplayObjectsHitFlagBy( weaponDisplayObject );				}							/** handleMultipleWeaponsWeaponFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleMultipleWeaponsWeaponFired( weaponDisplayObject:WeaponDisplayObject, shootTo:Point, altitude:Number ):void				{					var projectileDisplayObject:ProjectileDisplayObject;					/**/					//trace( "unused projectile objects length: "+_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength );					for( var i:int=0; i<_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength; ++i )					{						if( _projectileDisplayObjectController.unusedProjectileDisplayObjects[i].type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							//trace( "reuse projectile display object" );							projectileDisplayObject = _projectileDisplayObjectController.unusedProjectileDisplayObjects.splice( i, 1 )[0];							projectileDisplayObject.reuse();							_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength = _projectileDisplayObjectController.unusedProjectileDisplayObjects.length;							break;						}					}					/**/					if( projectileDisplayObject == null )					{						//trace( "create new projectile display object" );						projectileDisplayObject = new ProjectileDisplayObject();						projectileDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						projectileDisplayObject.init();					}										var projectile:Projectile = new Projectile();						projectile.upAnimationObject = weaponDisplayObject.currentAttackingGameObject.additionalAttackUpAnimationObject;						projectile.upAnimationObject.customPosition = weaponDisplayObject.currentAttackingGameObject.upAnimationObject.customPositions[0];						projectile.downAnimationObject = weaponDisplayObject.currentAttackingGameObject.additionalAttackDownAnimationObject;						projectile.downAnimationObject.customPosition = weaponDisplayObject.currentAttackingGameObject.downAnimationObject.customPositions[0];										projectileDisplayObject.direction = weaponDisplayObject.direction;					projectileDisplayObject.projectile = projectile;					projectileDisplayObject.pathIndex = weaponDisplayObject.pathIndex;					projectileDisplayObject.positionIn2D = weaponDisplayObject.positionIn2D.clone();					projectileDisplayObject.inIsometricView = _inIsometricView;					projectileDisplayObject.setDestinationPointIn2D( shootTo, altitude );					projectileDisplayObject.attackingGameObject = weaponDisplayObject.currentAttackingGameObject;										//trace( "projectile has poison ? "+projectileDisplayObject.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_POISON_INDEX) );										_projectileDisplayObjectController.addProjectile( projectileDisplayObject );									}							/** handleWeaponDied			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleWeaponDied( weaponDisplayObject:WeaponDisplayObject, range:Number ):void				{					_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_WORRIED_ANIMATION );										if( weaponDisplayObject.attackingGameObject.deathParticleEffect != '' )					{						var globalPosition:Point = weaponDisplayObject.contentClip.parent.localToGlobal( new Point(weaponDisplayObject.contentClip.x, weaponDisplayObject.contentClip.y) );						//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticle", this, {gameLevelDisplayObject:weaponDisplayObject, particleId:weaponDisplayObject.attackingGameObject.deathParticleEffect, globalPosition:globalPosition} );						EventNotificationCenter.getInstance().sendSignal( "onPlayParticle", this, {gameLevelDisplayObject:weaponDisplayObject, particleId:weaponDisplayObject.attackingGameObject.deathParticleEffect, globalPosition:globalPosition} );					}										//trace( "death property of bomb ? "+weaponDisplayObject.attackingGameObject.hasDeathProperty( GameLevelUtil.ATTACK_PROPERTY_BOMB_INDEX ) );										if( weaponDisplayObject.attackingGameObject.hasDeathProperty( GameLevelUtil.ATTACK_PROPERTY_BOMB_INDEX ) )					{						//trace( "enemy has death property of bomb" );						//trace( "attacks all enemies in range of "+range );						_enemyDisplayObjectController.attackEnemiesInARange( weaponDisplayObject.positionIn2D, range, weaponDisplayObject, weaponDisplayObject.attackingGameObject.deathEffectPower );					}										_attackingDisplayObjectController.removeWeapon( weaponDisplayObject );				}							/** handleWeaponRemovedFromGame			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handleWeaponRemovedFromGame( event:GameLevelEvent ):void				{					removeWeapon( event.customParameters.weaponDisplayObject );				}*/								protected function handleWeaponRolledOver( weaponDisplayObject:WeaponDisplayObject ):void				{					_gameboardReference.highlightWeaponRange( weaponDisplayObject.attackingGameObject, weaponDisplayObject.currentTile, weaponDisplayObject.direction );				}								protected function handleWeaponRolledOut():void				{					_gameboardReference.stopWeaponRangeClipsAnimation();				}							/**	******************************************* *			  * EnemyDisplayObjectCotroller Events			  *	******************************************* */			 				/** handleEnemyMovedToNextTile			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleEnemyMovingToNextTile( event:GameLevelEvent ):void				protected function handleEnemyMovedToNextTile( enemyDisplayObject:EnemyDisplayObject, tile:GameboardTile ):void				{					//_attackingDisplayObjectController.moveEnemy( event.customParameters.enemyDisplayObject );										//_attackingDisplayObjectController.addEnemy( event.customParameters.enemyDisplayObject );					_attackingDisplayObjectController.moveEnemyToTile( enemyDisplayObject, tile );										if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevel && MainGameController.getInstance().currentUser.currentTutorialStep == "TUTORIAL_LEVEL_3" )					{						//trace( "-------------- tile: "+tile );						if( !EnemyDisplayObject(enemyDisplayObject).inSpawnPath && tile.row == 6 && tile.column == 4 )						{							enemyDisplayObject.currentSpeed = GameLevelDataIndex.getInstance().getEnemy( enemyDisplayObject.attackingGameObject.id ).speed;							/*							MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_5";														var chickenDisplayObject:ChickenDisplayObject = _chickenDisplayObjectController.addChicken(0);							chickenDisplayObject.pause();							var globalPosition:Point = chickenDisplayObject.contentClip.parent.localToGlobal( new Point(chickenDisplayObject.contentClip.x, chickenDisplayObject.contentClip.y) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false} );														_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_5") );														pauseForGodAttack();							*/														//_gameboardReference.removeEventListener( BoogaEvent.ON_PLACE_WEAPON_ON_INVALID_SPOT, handlePlaceWeaponOnInvalidSpot );														MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_5";														unpauseForGodAttack();														EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_UI_ELEMENTS_SHOW, this );														//_gameboardReference.gameboardMenuClip.show();							//_gameboardReference.chickenIndicator_mc.visible = true;							_gameboardReference.showGameboardMenu();														var firstMenuIcon:GameboardMenuContentIcon = _gameboardReference.gameboardMenuClip.getGameboardMenuIcon(0);							//trace( "firstMenuIcon: "+firstMenuIcon );							var globalPosition:Point = firstMenuIcon.contentClip.parent.localToGlobal( new Point(firstMenuIcon.contentClip.x+25, firstMenuIcon.contentClip.y+25) );							EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );														_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_5") );														pauseForGodAttack();														var randomIndex:int = int(Math.random()*_backgroundMusicOptions.length);							_currentBackgroundMusic = _backgroundMusicOptions[randomIndex];							_isPlayingBackgroundMusic = true;														//SoundEffectPlayer.getInstance().setVolume( SoundsIndex.getInstance().getSoundBySoundId(_currentBackgroundMusic).volume, 0, _currentBackgroundMusic );							SoundEffectPlayer.getInstance().playLibrarySound( _currentBackgroundMusic, true, _currentBackgroundMusic, _currentBackgroundMusic, SoundEffectPlayer.SOUND_PLAYER_MUSIC );						}					}				}							/** handleEnemyMovedToNextPoint			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleEnemyMovingToNextPoint( event:GameLevelEvent ):void				protected function handleEnemyMovedToNextPoint( enemyDisplayObject:EnemyDisplayObject ):void				{					//TODO PRIORITY 1:					//	Optimize this so that enemies aren't checking for targets to hit all the time !!!!!										_attackingDisplayObjectController.checkForTargets( enemyDisplayObject );				}							/** handleEnemySpawnPathEnded			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleEnemyHitsEndOfSpawnPath( event:GameLevelEvent ):void				protected function handleEnemySpawnPathEnded( enemyDisplayObject:EnemyDisplayObject ):void				{					enemyDisplayObject.pathIndex = _attackingDisplayObjectController.getPathIndex( enemyDisplayObject.currentTile );					_attackingDisplayObjectController.moveEnemyToTile( enemyDisplayObject, enemyDisplayObject.currentTile );										enemyDisplayObject.startMoving();				}								private function handleEnemySpawnPathReentered( enemyDisplayObject:EnemyDisplayObject ):void				{					_attackingDisplayObjectController.removeEnemy( enemyDisplayObject );					enemyDisplayObject.startMoving();				}							/** handleEnemyHitsEndOfPath			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleEnemyHitsEndOfPath( event:GameLevelEvent ):void				protected function handleEnemyPathEnded( enemyDisplayObject:EnemyDisplayObject ):void				{					//TODO:  (revised on 4/21)					//	When enemy reaches the end of the path, that means there is no more gate.					//	So user loses.										_attackingDisplayObjectController.removeEnemyFromTiles( enemyDisplayObject );					/*					var enemyDO:EnemyDisplayObject = enemyDisplayObject;					var gateIndex:uint = enemyDO.currentTile.column;										//if( _gameboardReference.gateTiles[gateIndex].alive )					if( _gateDisplayObjectController.checkIfGateIsAlive(gateIndex) )					{						trace( "ATTACK THE GATE" );					}					else					{						trace( "WALK TO THE VILLAGE" );					}					*/										_gameboardReference.resultScreenLoseClip.enemyId = Enemy(enemyDisplayObject.attackingGameObject).id;										end( false );				}							/** handleEnemyAttackTimerFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleEnemyAttackTimerFired( enemyDisplayObject:EnemyDisplayObject ):void				{					//trace( "handleEnemyAttackTimerFired();" );										_attackingDisplayObjectController.checkForTargets( enemyDisplayObject );				}							/** handleEnemyDied			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleEnemyDied( enemyDisplayObject:EnemyDisplayObject ):void				{					_attackingDisplayObjectController.removeEnemy( enemyDisplayObject );					--_enemiesLeft;										/*					else if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevelDelete )					{						unpauseForGodAttack();						EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );												MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_DELETE_5";												MainGameController.getInstance().currentUser.tutorialGameLevelDelete = false;												var userDataController:UserDataController = new UserDataController();							userDataController.updateUserTutorial( MainGameController.getInstance().currentUser.id, "game_level_delete", 0 );					}					*/										if( !(enemyDisplayObject is EggEnemyDisplayObject) )						_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_HAPPY_ANIMATION );				}							/** handleEnemyRemovedFromGame			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleEnemyRemovedFromGame( enemyDisplayObject:EnemyDisplayObject ):void				{					removeEnemy( enemyDisplayObject );					/*					if( !_gameboardReference.isEditor && MainGameController.getInstance().currentUser.tutorialGameLevel )					{						MainGameController.getInstance().currentUser.currentTutorialStep = "TUTORIAL_LEVEL_10";												//unpauseForGodAttack();						//EventNotificationCenter.getInstance().sendNotification( BoogaEvent.ON_TUTORIAL_HIDE, this );												var chickenDisplayObject:ChickenDisplayObject = _chickenDisplayObjectController.addChicken(1);						chickenDisplayObject.pause();						var globalPosition:Point = chickenDisplayObject.contentClip.parent.localToGlobal( new Point(chickenDisplayObject.contentClip.x, chickenDisplayObject.contentClip.y) );						EventNotificationCenter.getInstance().sendNotificationWithParameters( BoogaEvent.ON_TUTORIAL_SHOW, this, {targetX:globalPosition.x, targetY:globalPosition.y, showText:false, introTutorial:true} );												chickenDisplayObject = _chickenDisplayObjectController.addChicken(2);						chickenDisplayObject.pause();												_gameboardReference.introAnimationViewClip.showTutorialText( StringsIndex.getInstance().getStringByName("TUTORIAL_LEVEL_10") );												pauseForGodAttack();					}					*/										checkIfAllWaveZonesEnded();				}							/** checkIfAllWaveZonesEnded			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	private function checkIfAllWaveZonesEnded():void				{					var allWaveZonesEnded:Boolean = true;					for( var i:int=0; i<_waveZoneControllers.length; ++i )					{						allWaveZonesEnded = allWaveZonesEnded && _waveZoneControllers[i].ended;					}										//trace( "allWaveZonesEnded: "+allWaveZonesEnded );					//trace( "_enemyDisplayObjectController.enemyDisplayObjectsLength: "+_enemyDisplayObjectController.enemyDisplayObjectsLength );										if( allWaveZonesEnded && _enemyDisplayObjectController.enemyDisplayObjectsLength == 0 )						end( true );				}							/** handleProjectileEnemyFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleProjectileEnemyFired( enemyDisplayObject:EnemyDisplayObject, direction:int, shootTo:Point, altitude:Number ):void				{					//var projectileDisplayObject:ProjectileDisplayObject = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();										var projectileDisplayObject:ProjectileDisplayObject;					/**/					//trace( "unused projectile objects length: "+_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength );					for( var i:int=0; i<_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength; ++i )					{						if( _projectileDisplayObjectController.unusedProjectileDisplayObjects[i].type == ProjectileDisplayObject.TYPE_PROJECTILE )						{							//trace( "reuse projectile display object" );							projectileDisplayObject = _projectileDisplayObjectController.unusedProjectileDisplayObjects.splice( i, 1 )[0];							projectileDisplayObject.reuse();							_projectileDisplayObjectController.unusedProjectileDisplayObjectsLength = _projectileDisplayObjectController.unusedProjectileDisplayObjects.length;							break;						}					}					/**/					if( projectileDisplayObject == null )					{						//trace( "create new projectile display object" );						projectileDisplayObject = new ProjectileDisplayObject();						projectileDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						projectileDisplayObject.init();					}										var projectile:Projectile = new Projectile();						projectile.upAnimationObject = enemyDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;						projectile.upAnimationObject.customPosition = enemyDisplayObject.attackingGameObject.attackUpAnimationObject.customPositions[0];						projectile.downAnimationObject = enemyDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;						projectile.downAnimationObject.customPosition = enemyDisplayObject.attackingGameObject.attackDownAnimationObject.customPositions[0];											projectileDisplayObject.direction = direction;					projectileDisplayObject.projectile = projectile;					projectileDisplayObject.pathIndex = enemyDisplayObject.pathIndex;					projectileDisplayObject.positionIn2D = enemyDisplayObject.positionIn2D.clone();					projectileDisplayObject.inIsometricView = _inIsometricView;					projectileDisplayObject.setDestinationPointIn2D( shootTo, altitude );					projectileDisplayObject.attackingGameObject = enemyDisplayObject.attackingGameObject;										//trace( "projectileDisplayObject.attackingGameObject: "+projectileDisplayObject.attackingGameObject );					//trace( "projectileDisplayObject.attackingGameObject.attackingGameObject: "+projectileDisplayObject.attackingGameObject.attackingGameObject );										//trace( "startPositionIn2D: "+projectileDisplayObject.positionIn2D );					//trace( "destinationPoint: "+shootTo );										_projectileDisplayObjectController.addProjectile( projectileDisplayObject );				}							/** handleCatapultEnemyFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleCatapultEnemyFired( enemyDisplayObject:EnemyDisplayObject, shootTo:Point, altitude:Number ):void				{					var projectile:Projectile = new Projectile();						projectile.upAnimationObject = enemyDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;						projectile.upAnimationObject.customPosition = enemyDisplayObject.attackingGameObject.attackUpAnimationObject.customPositions[0];						projectile.downAnimationObject = enemyDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;						projectile.downAnimationObject.customPosition = enemyDisplayObject.attackingGameObject.attackDownAnimationObject.customPositions[0];										var catapultDisplayObject:CatapultDisplayObject = new CatapultDisplayObject();						catapultDisplayObject.contentClip = new ( getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						catapultDisplayObject.init();						catapultDisplayObject.direction = enemyDisplayObject.direction;						catapultDisplayObject.projectile = projectile;						catapultDisplayObject.pathIndex = enemyDisplayObject.pathIndex;						catapultDisplayObject.positionIn2D = enemyDisplayObject.positionIn2D.clone();						catapultDisplayObject.inIsometricView = _inIsometricView;						catapultDisplayObject.setDestinationPointIn2D( shootTo, altitude );						catapultDisplayObject.attackingGameObject = enemyDisplayObject.attackingGameObject;										_projectileDisplayObjectController.addProjectile( catapultDisplayObject );				}							/** handleLaserEnemyFired			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleLaserEnemyFired( enemyDisplayObject:EnemyDisplayObject, direction:int, shootTo:Point, altitude:Number ):void				{					var projectile:Projectile = new Projectile();						projectile.upAnimationObject = enemyDisplayObject.attackingGameObject.additionalAttackUpAnimationObject;						projectile.upAnimationObject.customPosition = enemyDisplayObject.attackingGameObject.attackUpAnimationObject.customPositions[0];						projectile.downAnimationObject = enemyDisplayObject.attackingGameObject.additionalAttackDownAnimationObject;						projectile.downAnimationObject.customPosition = enemyDisplayObject.attackingGameObject.attackDownAnimationObject.customPositions[0];										//var tiles:Array = _attackingDisplayObjectController.getTilesInAttackRange( enemyDisplayObject );					var tiles:Vector.<GameboardTile> = _attackingDisplayObjectController.getTilesInAttackRangeForGameObject( enemyDisplayObject.attackingGameObject, enemyDisplayObject.currentTile, enemyDisplayObject.direction );										var destinationPointIn2D:Point = enemyDisplayObject.positionIn2D.clone();										switch( direction )					{						case GameLevelUtil.DIRECTION_UP:							destinationPointIn2D.y -= (tiles.length+1) * GameLevelUtil.TILE_2D_HEIGHT;							break;												case GameLevelUtil.DIRECTION_RIGHT:							destinationPointIn2D.x += (tiles.length+1) * GameLevelUtil.TILE_2D_WIDTH;							break;												case GameLevelUtil.DIRECTION_DOWN:							destinationPointIn2D.y += (tiles.length+1) * GameLevelUtil.TILE_2D_HEIGHT;							break;												case GameLevelUtil.DIRECTION_LEFT:							destinationPointIn2D.x -= (tiles.length+1) * GameLevelUtil.TILE_2D_WIDTH;							break;					}										var laserDisplayObject:LaserDisplayObject = new LaserDisplayObject();						laserDisplayObject.contentClip = new (getDefinitionByName("ProjectileDisplayObjectLibrary") as Class)();						laserDisplayObject.init();						laserDisplayObject.direction = direction;						laserDisplayObject.projectile = projectile;						laserDisplayObject.pathIndex = enemyDisplayObject.pathIndex;						laserDisplayObject.positionIn2D = enemyDisplayObject.positionIn2D.clone();						laserDisplayObject.inIsometricView = _inIsometricView;						laserDisplayObject.setDestinationPointIn2D( tiles[tiles.length-1].positionIn2D.clone(), altitude );						laserDisplayObject.attackingGameObject = enemyDisplayObject.attackingGameObject;										//ConsoleBroadcaster.broadcast( "GameboardController", "laser display object direction: "+direction );										_projectileDisplayObjectController.addProjectile( laserDisplayObject );										enemyDisplayObject.laserDisplayObject = laserDisplayObject;										_attackingDisplayObjectController.hitWeaponsByLaserEnemy( enemyDisplayObject );				}							/** handleLaserEnemyHit			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleLaserEnemyHit( enemyDisplayObject:EnemyDisplayObject ):void				{					_attackingDisplayObjectController.hitWeaponsByLaserEnemy( enemyDisplayObject );				}							/** handleLaserEnemyStopped			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleLaserEnemyStopped( enemyDisplayObject:EnemyDisplayObject, laserDisplayObject:LaserDisplayObject ):void				{					_projectileDisplayObjectController.removeProjectile( laserDisplayObject );					_attackingDisplayObjectController.resetDisplayObjectsHitFlagBy( enemyDisplayObject );					//_weaponDisplayObjectController.unflagHitByLaserAttack();					//_gateDisplayObjectController.unflagHitByLaserAttack();				}							/** handleEggLayerEnemyLaidEgg			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleEggLayerEnemyLaidEgg( enemyDisplayObject:EnemyDisplayObject, positionIn2D:Point, hatchlingId:int, pathIndex:int, currentIndexInPath:int, path:Vector.<GameboardTile> ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "handleEggLayerEnemyLaidEgg();" );										//trace( "hatchlingId: "+hatchlingId );					//trace( "pathIndex: "+pathIndex );					//trace( "currentTile: "+currentTile );					//trace( "currentIndexInPath: "+currentIndexInPath );					//trace( "path: "+path );										var enemy:Enemy = GameLevelDataIndex.getInstance().getEnemy( hatchlingId );										var enemyDisplayObject:EnemyDisplayObject = EnemyDisplayObjectFactory.createEnemyDisplayObject( enemy );						enemyDisplayObject.inIsometricView = _inIsometricView;						enemyDisplayObject.path = path;						enemyDisplayObject.pathIndex = pathIndex;						enemyDisplayObject.currentIndexInPath = currentIndexInPath;						enemyDisplayObject.positionIn2D.x = positionIn2D.x;						enemyDisplayObject.positionIn2D.y = positionIn2D.y;										_enemyDisplayObjectController.addEnemy( enemyDisplayObject );					_attackingDisplayObjectController.addEnemy( enemyDisplayObject );				}							/** handleEggEnemyHatched			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function handleEggEnemyHatched( enemyDisplayObject:EnemyDisplayObject, positionIn2D:Point, hatchlingId:int, pathIndex:int, currentIndexInPath:int, path:Vector.<GameboardTile> ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "handleEggEnemyHatched();" );										//trace( "hatchlingId: "+hatchlingId );					//trace( "pathIndex: "+pathIndex );					//trace( "currentTile: "+currentTile );					//trace( "currentIndexInPath: "+currentIndexInPath );					//trace( "path: "+path );										var enemy:Enemy = GameLevelDataIndex.getInstance().getEnemy( hatchlingId );										var enemyDisplayObject:EnemyDisplayObject = EnemyDisplayObjectFactory.createEnemyDisplayObject( enemy );						enemyDisplayObject.inIsometricView = _inIsometricView;						enemyDisplayObject.path = path;						enemyDisplayObject.pathIndex = pathIndex;						enemyDisplayObject.currentIndexInPath = currentIndexInPath;						enemyDisplayObject.positionIn2D.x = positionIn2D.x;						enemyDisplayObject.positionIn2D.y = positionIn2D.y;										//if( _isTricksterGodInPlay )						//enemyDisplayObject.reversed = false;										_enemyDisplayObjectController.addEnemy( enemyDisplayObject, true );										_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_WORRIED_ANIMATION );				}							/** handleEnemyJumpingLanded			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 			 	protected function handleJumpingEnemyLanded( event:GameLevelEvent ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "handleJumpingEnemyLanded();" );										//trace( "enemyDisplayObject: "+event.customParameters.enemyDisplayObject );										_attackingDisplayObjectController.checkForTargets( event.customParameters.enemyDisplayObject );				}*/											/**	******************************************* *			  * ProjectileDisplayObjectCotroller Events			  *	******************************************* */			 					protected function handleCatapultAmmoHit( projectileDisplayObject:ProjectileDisplayObject, range:Number ):void				{					if( projectileDisplayObject.attackingGameObject is Weapon )					{						//trace( "attackingGameObject of the projectile is Weapon" );						//trace( "positionIn2D: "+projectileDisplayObject.positionIn2D );						//trace( "range: "+range );												//var globalPosition:Point = (weaponDisplayObject as WeaponDisplayObject).contentClip.parent.localToGlobal( new Point(weaponDisplayObject.contentClip.x, weaponDisplayObject.contentClip.y) );						//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticle", this, {gameLevelDisplayObject:WeaponDisplayObject(weaponDisplayObject), particleId:"tntexplosion", globalPosition:globalPosition} );												var i:int, j:int;						var tilesRange:int = projectileDisplayObject.attackingGameObject.projectileEffectRange;						var counter1:int, counter2:int;						counter1 = tilesRange * 2 + 1;						counter2 = 1;						var offsetX:int = 0;						var offsetY:int = -tilesRange;						var position:Point = new Point();						var globalPosition:Point;						var animationObject:AnimationObject;						var pathTile:GameboardTile;												if( CatapultDisplayObject(projectileDisplayObject).attackingGameObject.projectileParticleEffect != "0" )						{							for( i=0; i<counter1; ++i )							{								for( j=0; j<counter2; ++j )								{									//position.x = globalPosition;									position.x = projectileDisplayObject.positionIn2D.x + (offsetX+j)*90;									position.y = projectileDisplayObject.positionIn2D.y + offsetY*90;																		pathTile = isPointInPathTile(position);									//position.x = pathTile.positionIn2D.x;									//position.y = pathTile.positionIn2D.y;																		if( pathTile != null )									{										position = GameLevelUtil.getPositionInIsometric( position );																				//trace( 'tile row: '+pathTile.row );										//trace( 'tile column: '+pathTile.column );										//trace( position.x/90 );										//trace( position.y/90 );																				globalPosition = projectileDisplayObject.contentClip.parent.localToGlobal( position );																				if( int(projectileDisplayObject.attackingGameObject.projectileParticleEffect) > 0 )										{											//trace( 'playing particle animation' );											animationObject = GameLevelDataIndex.getInstance().getAnimationObject( int(projectileDisplayObject.attackingGameObject.projectileParticleEffect) );											//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticleAnimation", this, {particleCacheId:animationObject.cacheId, globalPosition:globalPosition, tileRow:pathTile.row, tileColumn:pathTile.column} );											EventNotificationCenter.getInstance().sendSignal( "onPlayParticleAnimation", this, {particleCacheId:animationObject.cacheId, globalPosition:globalPosition, tileRow:pathTile.row, tileColumn:pathTile.column} );										}										else// if( CatapultDisplayObject(projectileDisplayObject).attackingGameObject.projectileParticleEffect != "" )										{											//var globalPosition:Point = projectileDisplayObject.contentClip.parent.localToGlobal( new Point(projectileDisplayObject.contentClip.x, projectileDisplayObject.contentClip.y) );											//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticle", this, {gameLevelDisplayObject:projectileDisplayObject, particleId:"bee2", globalPosition:globalPosition} );											//EventNotificationCenter.getInstance().sendNotificationWithParameters( "onPlayParticle", this, {gameLevelDisplayObject:projectileDisplayObject, particleId:projectileDisplayObject.attackingGameObject.projectileParticleEffect, globalPosition:globalPosition} );											EventNotificationCenter.getInstance().sendSignal( "onPlayParticle", this, {gameLevelDisplayObject:projectileDisplayObject, particleId:projectileDisplayObject.attackingGameObject.projectileParticleEffect, globalPosition:globalPosition} );										}																				pathTile = null;									}								}																++offsetY;																if( i < tilesRange )								{									counter2 += 2;									--offsetX;								}								else								{									counter2 -= 2;									++offsetX;								}							}													}						else						{							trace( "no particle effect assigned for projectile hit" );						}												//_enemyDisplayObjectController.attackEnemiesInARange( projectileDisplayObject.positionIn2D, range, projectileDisplayObject, projectileDisplayObject.attackingGameObject.power );					}					else if( projectileDisplayObject.attackingGameObject is Enemy )					{						//trace( "attackingGameObject of the projectile is Enemy" );					}				}											/**	******************************************* *			  * GodDisplayObjectCotroller Events			  *	******************************************* */			 				/** handleGodAttacked			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleGodAttacked( event:GameLevelEvent ):void				protected function handleGodAttacked( godDisplayObject:GodDisplayObject ):void				{					//TODO:					//	Need to code the god attacks by special gods ( Trickster God, Warrior God, etc );										_enemyDisplayObjectController.hitEnemiesByGodAttack( godDisplayObject.god );				}								//protected function handleGodAttackEnded( event:GameLevelEvent ):void				protected function handleGodAttackEnded( godDisplayObject:GodDisplayObject ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameboardController", "handleGodAttackEnded();" );										_enemyDisplayObjectController.hitEnemiesByGodAttack( godDisplayObject.god );					_enemyDisplayObjectController.unflagEnemiesHitByGodAttack();										if( godDisplayObject.god.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ONE_HIT_KILL_INDEX) )					{						setDeathGodOutOfPlay();					}										_godDisplayObjectController.removeGod( godDisplayObject );				}							/**	******************************************* *			  * GateDisplayObjectCotroller Events			  *	******************************************* */			 					//protected function handleGateHit( event:GameLevelEvent ):void				protected function handleGateHit():void				{					_villagerDisplayObjectController.showVillagerAnimation( Villager.VILLAGER_SCARED_ANIMATION );				}							/** handleGateDied			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleGateDied( event:GameLevelEvent ):void				protected function handleGateDied( gateDisplayObject:GateDisplayObject ):void				{					_attackingDisplayObjectController.removeGate( gateDisplayObject );					//_gateDisplayObjectController.removeGate( gateDisplayObject );				}							/** handleGateRevived			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	//protected function handleGateRevived( event:GameLevelEvent ):void				protected function handleGateRevived( gateDisplayObject:GateDisplayObject ):void				{					_attackingDisplayObjectController.addGate( gateDisplayObject );				}							/** isPointInPathTile			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	protected function isPointInPathTile( point:Point ):GameboardTile				{					var i:int, j:int;					for( i=0; i<_tilePaths.length; ++i )					{						for( j=0; j<_tilePaths[i].length; ++j )						{							if( point.x < _tilePaths[i][j].positionIn2D.x+45 && point.x > _tilePaths[i][j].positionIn2D.x-45 && point.y > _tilePaths[i][j].positionIn2D.y-45 && point.y < _tilePaths[i][j].positionIn2D.y+45 )							{								return _tilePaths[i][j];							}						}					}										return null;				}							/** canPlaceNewWeaponInTile			  *	---------------------------------------------------------------------------- *			  *	Checks if you can place a new weapon on the tile.			  *	If it's a shield weapon, the tile has to have a weapon			  *	If it's an addition weapon, check if there's no addition weapon on the tile yet.			  *	Otherwise, check if we can place the weapon on the tile based on the weapon			  *	property. If it's a Fire weapon, we can't place it on this tile unless			  *	the tile has a Fire protection weapon.			  *	---------------------------------------------------------------------------- */			 	public function canPlaceNewWeaponInTile( item:AbstractGameObject, tile:GameboardTile ):Boolean				{					var i:int, j:int;										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SHIELD_INDEX) )					{						/*						if( tile.occupiedByWeapon && !tile.occupiedByShield )						{							for( i=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )							{								if( _weaponDisplayObjectController.weaponDisplayObjects[i].currentTile.isTheSameAsTile(tile) )								{									return (_weaponDisplayObjectController.weaponDisplayObjects[i].shield == null);								}							}						}						else						{							return false;						}						*/												//trace( "tile: "+tile );						//trace( 'tile.occupiedByWeapon: '+tile.occupiedByWeapon );						//trace( 'tile.occupiedByShield: '+tile.occupiedByShield );						//trace( 'can placce shield? '+(tile.occupiedByWeapon && !tile.occupiedByShield) );												return (tile.occupiedByWeapon && !tile.occupiedByShield);					}					else if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ADDITION_INDEX) )					{						return !tile.occupiedByAddition;					}					else					{						if( tile.occupiedByWeapon )							return false;												//var element:ElementCompatibility = GameLevelUtil.checkForElement( _gameLevel );												if( _gameLevelElement != null )						{							if( item.hasAttackProperty(_gameLevelElement.against) )							{								if( item.hasAttackProperty(_gameLevelElement.protection) )									return true;																for( i=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )								{									if( _weaponDisplayObjectController.weaponDisplayObjects[i].currentTile.isTheSameAsTile(tile) &&										_weaponDisplayObjectController.weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ADDITION_INDEX) &&										_weaponDisplayObjectController.weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(_gameLevelElement.protection) )									{										return true;									}								}																return false;							}						}						/*						if( _gameLevel.hasProperty(GameLevelUtil.ATTACK_PROPERTY_FIRE_INDEX) && item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ICE_INDEX) )						{							//fire level, ice weapons dont work here							for( i=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )							{								if( _weaponDisplayObjectController.weaponDisplayObjects[i].currentTile.isTheSameAsTile(tile) && 									_weaponDisplayObjectController.weaponDisplayObjects[i] is AdditionWeaponDisplayObject &&									_weaponDisplayObjectController.weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_PROTECTION_FROM_FIRE_INDEX) )								{									return true;								}							}														return false;						}						else if( _gameLevel.hasProperty(GameLevelUtil.ATTACK_PROPERTY_ICE_INDEX) && item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FIRE_INDEX) )						{							//ice level, certain weapons dont work							for( i=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )							{								if( _weaponDisplayObjectController.weaponDisplayObjects[i].currentTile.isTheSameAsTile(tile) && 									_weaponDisplayObjectController.weaponDisplayObjects[i] is AdditionWeaponDisplayObject &&									_weaponDisplayObjectController.weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_PROTECTION_FROM_ICE_INDEX) )								{									return true;								}							}														return false;						}						else if( _gameLevel.hasProperty(GameLevelUtil.ATTACK_PROPERTY_RAIN_INDEX) && item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FIRE_INDEX) )						{							//rain level, fire weapons dont work							for( i=0; i<_weaponDisplayObjectController.weaponDisplayObjectsLength; ++i )							{								if( _weaponDisplayObjectController.weaponDisplayObjects[i].currentTile.isTheSameAsTile(tile) && 									_weaponDisplayObjectController.weaponDisplayObjects[i] is AdditionWeaponDisplayObject &&									_weaponDisplayObjectController.weaponDisplayObjects[i].attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_PROTECTION_FROM_RAIN_INDEX) )								{									return true;								}							}														return false;						}						*/						return true;					}										return false;				}							/** findWeaponDirectionOnATilePath			  *	---------------------------------------------------------------------------- *			  *	Returns the weapon direction if it were about to be placed on a tile.			  *	---------------------------------------------------------------------------- */			 	public function findWeaponDirectionOnATilePath( tile:GameboardTile ):int				{					var i:int, j:int;										for( i=0; i<_tilePaths.length; ++i )					{						for( j=0; j<_tilePaths[i].length; ++j )						{							if( _tilePaths[i][j].row == tile.row && _tilePaths[i][j].column == tile.column )							{								if( j == 0 )									return GameLevelUtil.directionFromTileAToTileB( _tilePaths[i][j], null );								else									return GameLevelUtil.directionFromTileAToTileB( _tilePaths[i][j], _tilePaths[i][j-1] );							}						}											}										return -1;				}							/** handlePerformanceItemsToggled			  *	---------------------------------------------------------------------------- *			  *	Listens to the settings index to see when the engine improves the performance			  *	---------------------------------------------------------------------------- */			 	protected function handlePerformanceItemsToggled():void				{					if( _enemyDisplayObjectController != null )					{						_enemyDisplayObjectController.turnOffShadow();					}				}							/** handleCheatDetected			  *	---------------------------------------------------------------------------- *			  *	If cheats are enabled, this will check for any cheats that are entered.			  *	---------------------------------------------------------------------------- */			 	protected function handleCheatDetected( customParameters:Object ):void				{					ConsoleBroadcaster.broadcast( "GameboardController", "handleCheatDected("+customParameters.keywordIndex+");" );										if( customParameters.keywordIndex == 0 )					{						if( _isPlaying )						{							end( true );						}					}					else if( customParameters.keywordIndex == 1 )					{						if( _isPlaying )						{							end( false );						}					}					else if( customParameters.keywordIndex == 3 )					{						if( _isPlaying )						{							if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_SHADOW) )							{								for( var i:int=0; i<_enemyDisplayObjectController.enemyDisplayObjectsLength; ++i )								{									if( _enemyDisplayObjectController.enemyDisplayObjects[i].shadowDisplayObject != null )									{										//trace( "enemy has shadow" );										//trace( "turning shadow off" );										_enemyDisplayObjectController.enemyDisplayObjects[i].shadowDisplayObject.contentClip.stop();										_enemyDisplayObjectController.enemyDisplayObjects[i].shadowDisplayObject.contentClip.visible = false;									}								}							}						}					}					else if( customParameters.keywordIndex == 4 )					{											}					else if( customParameters.keywordIndex == 13 )					{						SettingsIndex.getInstance().improvePerformance( 20 );					}				}								protected function handleSpacePressed( event:CustomEvent ):void				{					if( _isPlaying )					{						pause();					}				}						}	}