/** GameLevelUtil  *	---------------------------------------------------------------------------- *  *	@desc:  *		Util class for GameLevel  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.utils	{		import flash.display.MovieClip;		import flash.events.EventDispatcher;		import flash.filters.ColorMatrixFilter;		import flash.geom.Point;				import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.cache.HashTable;		import com.avatarlabs.utils.cache.BitmapDataManager;		import com.boogabooga.data.SoundsIndex;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.AnimationObject;		import com.boogabooga.data.gamelevel.DiggingMap;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.EnvironmentObject;		import com.boogabooga.data.gamelevel.GameLevel;		import com.boogabooga.data.gamelevel.GameLevelDataIndex;		import com.boogabooga.data.gamelevel.God;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.data.gamelevel.Villager;		import com.boogabooga.data.maingame.*;		import com.boogabooga.ui.gamelevel.GameboardTile;				public class GameLevelUtil extends EventDispatcher		{			protected static var _isometricMatrixInitialized:Boolean = false;			protected static var _isometricMatrix:Array;						protected static var _elements:Array;						public static const DESATURATED_COLOR_MATRIX_FILTER:ColorMatrixFilter = new ColorMatrixFilter([0.3086,0.6094,0.0820,0,0,0.3086,0.6094,0.0820,0,0,0.3086,0.6094,0.0820,0,0,0,0,0,1,0]);						public static const DIRECTION_UP:uint = 0;			public static const DIRECTION_RIGHT:uint = 1;			public static const DIRECTION_DOWN:uint = 2;			public static const DIRECTION_LEFT:uint = 3;						public static const TILE_2D_WIDTH:Number = 90;			public static const TILE_2D_HEIGHT:Number = 90;						public static const ATTACK_PROPERTY_WOOD:String = "Wood";			public static const ATTACK_PROPERTY_STONE:String = "Stone";						public static const ATTACK_PROPERTY_FIRE:String = "Fire";			public static const ATTACK_PROPERTY_ICE:String = "Ice";			public static const ATTACK_PROPERTY_LIGHTNING:String = "Lightning";			public static const ATTACK_PROPERTY_POISON:String = "Poison";			public static const ATTACK_PROPERTY_RAIN:String = "Rain";			public static const ATTACK_PROPERTY_AREA_OF_EFFECT:String = "Area of Effect";			public static const ATTACK_PROPERTY_ENCHANTED:String = "Enchanted";			public static const ATTACK_PROPERTY_TRICKSTER:String = "Trickster";			public static const ATTACK_PROPERTY_WIND:String = "Wind";			public static const ATTACK_PROPERTY_WARRIOR:String = "Warrior";			public static const ATTACK_PROPERTY_GHOST:String = "Ghost";						public static const ATTACK_PROPERTY_FLYER:String = "Flyer";			public static const ATTACK_PROPERTY_BLOCKING:String = "Blocking";			public static const ATTACK_PROPERTY_HIGH_BLOCKING:String = "High Blocking";			//public static const ATTACK_PROPERTY_BLOCKING_DAMAGE:String = "Blocking Damage";			//public static const ATTACK_PROPERTY_HIGH_WALL:String = "High Wall";			public static const ATTACK_PROPERTY_EGG_LAYER:String = "Egg Layer";			public static const ATTACK_PROPERTY_EGG:String = "Egg";			public static const ATTACK_PROPERTY_HATCHLING:String = "Hatchling";			public static const ATTACK_PROPERTY_JUMPER:String = "Jumper";			public static const ATTACK_PROPERTY_SUPER_JUMPER:String = "Super Jumper";						public static const ATTACK_PROPERTY_BOMB:String = "Bomb";			public static const ATTACK_PROPERTY_CATAPULT:String = "Catapult";			public static const ATTACK_PROPERTY_LASER:String = "Laser";			public static const ATTACK_PROPERTY_PROJECTILE:String = "Projectile";			public static const ATTACK_PROPERTY_PUNCHER:String = "Puncher";			public static const ATTACK_PROPERTY_TRAP:String = "Trap";			public static const ATTACK_PROPERTY_SPRING_TRAP:String = "Spring Trap";			public static const ATTACK_PROPERTY_FULL_LANE:String = "Full Lane";			public static const ATTACK_PROPERTY_MULTIPLE_DIRECTIONS_PROJECTILE:String = "Multiple Directions Projectile";			public static const ATTACK_PROPERTY_MULTIPLE_WEAPONS:String = "Multiple Weapons";			public static const ATTACK_PROPERTY_HEALING:String = "Healing";			public static const ATTACK_PROPERTY_ADDITION:String = "Addition";			public static const ATTACK_PROPERTY_SHIELD:String = "Shield";			public static const ATTACK_PROPERTY_NO_JUMPING:String = "No Jumping";						public static const ATTACK_PROPERTY_PROTECTION_FROM_FIRE:String = "Protection From Fire";			public static const ATTACK_PROPERTY_PROTECTION_FROM_RAIN:String = "Protection From Rain";			public static const ATTACK_PROPERTY_PROTECTION_FROM_ICE:String = "Protection From Ice";						public static const ATTACK_PROPERTY_STRONG_AGAINST_FIRE:String = "Strong Against Fire";			public static const ATTACK_PROPERTY_STRONG_AGAINST_ICE:String = "Strong Against Ice";			public static const ATTACK_PROPERTY_STRONG_AGAINST_ENCHANTED:String = "Strong Against Enchanted";			public static const ATTACK_PROPERTY_WEAK_AGAINST_FIRE:String = "Weak Against Fire";			public static const ATTACK_PROPERTY_WEAK_AGAINST_ICE:String = "Weak Against Ice";			public static const ATTACK_PROPERTY_WEAK_AGAINST_ENCHANTED:String = "Weak Against Enchanted";						public static const ATTACK_PROPERTY_PATH:String = "Path";			public static const ATTACK_PROPERTY_DIRECT:String = "Direct";			public static const ATTACK_PROPERTY_LINE:String = "Line";						public static const ATTACK_PROPERTY_ONE_HIT_KILL:String = "One Hit Kill";						public static const ATTACK_PROPERTY_SINGLE_LANE:String = "Single Lane";			public static const ATTACK_PROPERTY_MULTIPLE_LANES:String = "Multiple Lanes";						public static var ATTACK_PROPERTY_WOOD_INDEX:int;			public static var ATTACK_PROPERTY_STONE_INDEX:int;						public static var ATTACK_PROPERTY_FIRE_INDEX:int;			public static var ATTACK_PROPERTY_ICE_INDEX:int;			public static var ATTACK_PROPERTY_LIGHTNING_INDEX:int;			public static var ATTACK_PROPERTY_POISON_INDEX:int;			public static var ATTACK_PROPERTY_RAIN_INDEX:int;			public static var ATTACK_PROPERTY_AREA_OF_EFFECT_INDEX:int;			public static var ATTACK_PROPERTY_ENCHANTED_INDEX:int;			public static var ATTACK_PROPERTY_TRICKSTER_INDEX:int;			public static var ATTACK_PROPERTY_WIND_INDEX:int;			public static var ATTACK_PROPERTY_WARRIOR_INDEX:int;			public static var ATTACK_PROPERTY_GHOST_INDEX:int;						public static var ATTACK_PROPERTY_FLYER_INDEX:int;			public static var ATTACK_PROPERTY_BLOCKING_INDEX:int;			public static var ATTACK_PROPERTY_HIGH_BLOCKING_INDEX:int;			//public static var ATTACK_PROPERTY_HIGH_WALL_INDEX:int;			//public static var ATTACK_PROPERTY_BLOCKING_DAMAGE_INDEX:int;			public static var ATTACK_PROPERTY_EGG_LAYER_INDEX:int;			public static var ATTACK_PROPERTY_EGG_INDEX:int;			public static var ATTACK_PROPERTY_HATCHLING_INDEX:int;			public static var ATTACK_PROPERTY_JUMPER_INDEX:int;			public static var ATTACK_PROPERTY_SUPER_JUMPER_INDEX:int;						public static var ATTACK_PROPERTY_BOMB_INDEX:int;			public static var ATTACK_PROPERTY_CATAPULT_INDEX:int;			public static var ATTACK_PROPERTY_LASER_INDEX:int;			public static var ATTACK_PROPERTY_PROJECTILE_INDEX:int;			public static var ATTACK_PROPERTY_PUNCHER_INDEX:int;			public static var ATTACK_PROPERTY_TRAP_INDEX:int;			public static var ATTACK_PROPERTY_SPRING_TRAP_INDEX:int;			public static var ATTACK_PROPERTY_FULL_LANE_INDEX:int;			public static var ATTACK_PROPERTY_MULTIPLE_DIRECTIONS_PROJECTILE_INDEX:int;			public static var ATTACK_PROPERTY_MULTIPLE_WEAPONS_INDEX:int;			public static var ATTACK_PROPERTY_HEALING_INDEX:int;			public static var ATTACK_PROPERTY_ADDITION_INDEX:int;			public static var ATTACK_PROPERTY_SHIELD_INDEX:int;			public static var ATTACK_PROPERTY_NO_JUMPING_INDEX:int;						public static var ATTACK_PROPERTY_PROTECTION_FROM_FIRE_INDEX:int;			public static var ATTACK_PROPERTY_PROTECTION_FROM_RAIN_INDEX:int;			public static var ATTACK_PROPERTY_PROTECTION_FROM_ICE_INDEX:int;						public static var ATTACK_PROPERTY_STRONG_AGAINST_FIRE_INDEX:int;			public static var ATTACK_PROPERTY_STRONG_AGAINST_ICE_INDEX:int;			public static var ATTACK_PROPERTY_STRONG_AGAINST_ENCHANTED_INDEX:int;			public static var ATTACK_PROPERTY_WEAK_AGAINST_FIRE_INDEX:int;			public static var ATTACK_PROPERTY_WEAK_AGAINST_ICE_INDEX:int;			public static var ATTACK_PROPERTY_WEAK_AGAINST_ENCHANTED_INDEX:int;						public static var ATTACK_PROPERTY_PATH_INDEX:int;			public static var ATTACK_PROPERTY_DIRECT_INDEX:int;			public static var ATTACK_PROPERTY_LINE_INDEX:int;						public static var ATTACK_PROPERTY_ONE_HIT_KILL_INDEX:int;						public static var ATTACK_PROPERTY_SINGLE_LANE_INDEX:int;			public static var ATTACK_PROPERTY_MULTIPLE_LANES_INDEX:int;						/** Constructor			  *	---------------------------------------------------------------------------- */				public function GameLevelUtil()				{									}							/** hash			  *	---------------------------------------------------------------------------- *			  *	Hash these strings so that we can compare these faster, easier.			  *	---------------------------------------------------------------------------- */				public static function hash():void				{					ATTACK_PROPERTY_WOOD_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_WOOD );					ATTACK_PROPERTY_STONE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_STONE );										ATTACK_PROPERTY_FIRE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_FIRE );					ATTACK_PROPERTY_ICE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_ICE );					ATTACK_PROPERTY_LIGHTNING_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_LIGHTNING );					ATTACK_PROPERTY_POISON_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_POISON );					ATTACK_PROPERTY_RAIN_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_RAIN );					ATTACK_PROPERTY_AREA_OF_EFFECT_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_AREA_OF_EFFECT );					ATTACK_PROPERTY_ENCHANTED_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_ENCHANTED );					ATTACK_PROPERTY_TRICKSTER_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_TRICKSTER );					ATTACK_PROPERTY_WIND_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_WIND );					ATTACK_PROPERTY_WARRIOR_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_WARRIOR );					ATTACK_PROPERTY_GHOST_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_GHOST );										ATTACK_PROPERTY_FLYER_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_FLYER );					ATTACK_PROPERTY_BLOCKING_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_BLOCKING );					ATTACK_PROPERTY_HIGH_BLOCKING_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_HIGH_BLOCKING );					//ATTACK_PROPERTY_BLOCKING_DAMAGE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_BLOCKING_DAMAGE );					//ATTACK_PROPERTY_HIGH_WALL_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_HIGH_WALL );					ATTACK_PROPERTY_EGG_LAYER_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_EGG_LAYER );					ATTACK_PROPERTY_EGG_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_EGG );					ATTACK_PROPERTY_HATCHLING_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_HATCHLING );					ATTACK_PROPERTY_JUMPER_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_JUMPER );					ATTACK_PROPERTY_SUPER_JUMPER_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_SUPER_JUMPER );										ATTACK_PROPERTY_BOMB_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_BOMB );					ATTACK_PROPERTY_CATAPULT_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_CATAPULT );					ATTACK_PROPERTY_LASER_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_LASER );					ATTACK_PROPERTY_PROJECTILE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_PROJECTILE );					ATTACK_PROPERTY_PUNCHER_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_PUNCHER );					ATTACK_PROPERTY_TRAP_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_TRAP );					ATTACK_PROPERTY_SPRING_TRAP_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_SPRING_TRAP );					ATTACK_PROPERTY_FULL_LANE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_FULL_LANE );					ATTACK_PROPERTY_MULTIPLE_DIRECTIONS_PROJECTILE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_MULTIPLE_DIRECTIONS_PROJECTILE );					ATTACK_PROPERTY_MULTIPLE_WEAPONS_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_MULTIPLE_WEAPONS );					ATTACK_PROPERTY_HEALING_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_HEALING );					ATTACK_PROPERTY_ADDITION_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_ADDITION );					ATTACK_PROPERTY_SHIELD_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_SHIELD );					ATTACK_PROPERTY_NO_JUMPING_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_NO_JUMPING );										ATTACK_PROPERTY_PROTECTION_FROM_FIRE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_PROTECTION_FROM_FIRE );					ATTACK_PROPERTY_PROTECTION_FROM_RAIN_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_PROTECTION_FROM_RAIN );					ATTACK_PROPERTY_PROTECTION_FROM_ICE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_PROTECTION_FROM_ICE );										ATTACK_PROPERTY_STRONG_AGAINST_FIRE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_STRONG_AGAINST_FIRE );					ATTACK_PROPERTY_STRONG_AGAINST_ICE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_STRONG_AGAINST_ICE );					ATTACK_PROPERTY_STRONG_AGAINST_ENCHANTED_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_STRONG_AGAINST_ENCHANTED );					ATTACK_PROPERTY_WEAK_AGAINST_FIRE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_WEAK_AGAINST_FIRE );					ATTACK_PROPERTY_WEAK_AGAINST_ICE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_WEAK_AGAINST_ICE );					ATTACK_PROPERTY_WEAK_AGAINST_ENCHANTED_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_WEAK_AGAINST_ENCHANTED );										ATTACK_PROPERTY_LINE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_LINE );					ATTACK_PROPERTY_PATH_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_PATH );					ATTACK_PROPERTY_DIRECT_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_DIRECT );										ATTACK_PROPERTY_ONE_HIT_KILL_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_ONE_HIT_KILL );										ATTACK_PROPERTY_SINGLE_LANE_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_SINGLE_LANE );					ATTACK_PROPERTY_MULTIPLE_LANES_INDEX = HashTable.getInstance().addHash( ATTACK_PROPERTY_MULTIPLE_LANES );				}							/** directionFromTileAToTileB			  *	---------------------------------------------------------------------------- *			  *	We find the direction from tileA to tileB, but we need to reverse it			  *	for edge tiles because the enemy is facing the other way compared to weapons.			  *	---------------------------------------------------------------------------- */				public static function directionFromTileAToTileB( tileA:GameboardTile, tileB:GameboardTile=null, reverse:Boolean=false ):int				{					if( tileB == null )					{						if( tileA.row == 0 )						{							return ( reverse ? GameLevelUtil.DIRECTION_UP : GameLevelUtil.DIRECTION_DOWN );						}						else if( tileA.column == GameLevelDataIndex.getInstance().boardMaxColumns-1 )						{							return ( reverse ? GameLevelUtil.DIRECTION_LEFT : GameLevelUtil.DIRECTION_RIGHT );						}						else if( tileA.row == GameLevelDataIndex.getInstance().boardMaxRows-1 )						{							return ( reverse ? GameLevelUtil.DIRECTION_UP : GameLevelUtil.DIRECTION_DOWN );						}						else if ( tileA.column == 0 )						{							return ( reverse ? GameLevelUtil.DIRECTION_RIGHT : GameLevelUtil.DIRECTION_LEFT );						}					}					else					{						if( tileA.row == tileB.row )						{							//if( tileA.column < tileB.column							return ( tileA.column < tileB.column ? GameLevelUtil.DIRECTION_RIGHT : GameLevelUtil.DIRECTION_LEFT );						}						else if( tileA.column == tileB.column )						{							return ( tileA.row < tileB.row ? GameLevelUtil.DIRECTION_DOWN : GameLevelUtil.DIRECTION_UP );						}					}										return -1;									}							/** directionGameLevelPathFromAToB			  *	---------------------------------------------------------------------------- *			  *	We find the direction from tileA to tileB, but we need to reverse it			  *	for edge tiles because the enemy is facing the other way compared to weapons.			  *	---------------------------------------------------------------------------- */				public static function directionGameLevelPathFromAToB( a:Object, b:Object=null ):int				{					if( b == null )					{						if( a.r == 0 )							return GameLevelUtil.DIRECTION_UP;						else if( a.c == GameLevelDataIndex.getInstance().boardMaxColumns-1 )							return GameLevelUtil.DIRECTION_LEFT;						else if( a.r == GameLevelDataIndex.getInstance().boardMaxRows-1 )							return GameLevelUtil.DIRECTION_UP;						else if( a.c == 0 )							return GameLevelUtil.DIRECTION_RIGHT;					}					else					{						if( a.r == b.r )							return ( a.c < b.c ? GameLevelUtil.DIRECTION_LEFT : GameLevelUtil.DIRECTION_RIGHT );						else if ( a.c == b.c )							return ( a.r < b.r ? GameLevelUtil.DIRECTION_UP : GameLevelUtil.DIRECTION_DOWN );					}										return -1;				}							/** getPositionInIsometric			  *	---------------------------------------------------------------------------- *			  *	Turns an isometric point into a 2D point.			  *	---------------------------------------------------------------------------- */			 	public static function getPositionInIsometric( position:Point, altitude:Number=0, round:Boolean=true ):Point				{					if( !_isometricMatrixInitialized )					{						var rotationDegreeRadian = -45 * Math.PI/180;						var elevationDegreeRadian = 54.5 * Math.PI/180;						var spinDegreeRadian = -90 * Math.PI/180;						var scale = 0.707214;						var rightX = Math.cos(rotationDegreeRadian) * scale;						var rightY = Math.sin(rotationDegreeRadian) * Math.cos(elevationDegreeRadian) * scale;						var frontX = -Math.sin(rotationDegreeRadian) * scale;						var frontY = Math.cos(rotationDegreeRadian) * Math.cos(elevationDegreeRadian) * scale;						var upX = 0;						var upY = Math.sin(elevationDegreeRadian);												_isometricMatrix = new Array( [rightX, rightY], [frontX, frontY], [upX, upY] );												_isometricMatrixInitialized = true;					}										var isometricPosition:Point = new Point();										isometricPosition.x = (position.x * _isometricMatrix[0][0]) + (position.y * _isometricMatrix[1][0]);					isometricPosition.y = (position.x * _isometricMatrix[0][1]) + (position.y * _isometricMatrix[1][1]) + (altitude * _isometricMatrix[2][1]);										if( round )					{						isometricPosition.x = Math.round( isometricPosition.x );						isometricPosition.y = Math.round( isometricPosition.y );					}										return isometricPosition;				}							/** getPositionInIsometric			  *	---------------------------------------------------------------------------- *			  *	Turns a 2D point into an isometric position.			  *	---------------------------------------------------------------------------- */			 	public static function getPositionIn2D( isometricPosition:Point, altitude:Number=0 ):Point				{					if( !_isometricMatrixInitialized )					{						var rotationDegreeRadian = -45 * Math.PI/180;						var elevationDegreeRadian = 54.5 * Math.PI/180;						var spinDegreeRadian = -90 * Math.PI/180;						var scale = 0.707214;						var rightX = Math.cos(rotationDegreeRadian) * scale;						var rightY = Math.sin(rotationDegreeRadian) * Math.cos(elevationDegreeRadian) * scale;						var frontX = -Math.sin(rotationDegreeRadian) * scale;						var frontY = Math.cos(rotationDegreeRadian) * Math.cos(elevationDegreeRadian) * scale;						var upX = 0;						var upY = Math.sin(elevationDegreeRadian);												_isometricMatrix = new Array( [rightX, rightY], [frontX, frontY], [upX, upY] );												_isometricMatrixInitialized = true;					}										var position:Point = new Point();						position.x = Math.round( ((isometricPosition.x * _isometricMatrix[1][1]) - (isometricPosition.y * _isometricMatrix[1][0]) + (altitude * _isometricMatrix[2][1] * _isometricMatrix[1][0])) / ((_isometricMatrix[0][0] * _isometricMatrix[1][1]) - (_isometricMatrix[0][1] * _isometricMatrix[1][0])) );						position.y = Math.round( (isometricPosition.y - (position.x * _isometricMatrix[0][1]) - (altitude * _isometricMatrix[2][1])) / _isometricMatrix[1][1] );										return position;				}							/** getAttackAssets			  *	---------------------------------------------------------------------------- *			  *	Returns the attack assets for weapon/gods specified in the array.			  *	It includes all the animation objects for the these items.			  *	---------------------------------------------------------------------------- */			 	public static function getAttackAssets( attacks:Array ):Array				{					var assets:Array = new Array();					var weapon:Weapon;					var god:God;					var j:int=0;					var animationObject:AnimationObject;										for( var i:int=0; i<attacks.length; ++i )					{						if( attacks[i] is Weapon )						{							weapon = attacks[i];														if( BitmapDataManager.getInstance().getBitmapData(weapon.upAnimationObject.cacheId) == null ) assets.push( {id:weapon.upAnimationObject.cacheId, url:weapon.upAnimationObject.assetURL} );							if( BitmapDataManager.getInstance().getBitmapData(weapon.downAnimationObject.cacheId) == null ) assets.push( {id:weapon.downAnimationObject.cacheId, url:weapon.downAnimationObject.assetURL} );							if( weapon.deathAnimationObject && BitmapDataManager.getInstance().getBitmapData(weapon.deathAnimationObject.cacheId) == null ) assets.push( {id:weapon.deathAnimationObject.cacheId, url:weapon.deathAnimationObject.assetURL} );							if( weapon.additionalAttackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(weapon.additionalAttackUpAnimationObject.cacheId) == null ) assets.push( {id:weapon.additionalAttackUpAnimationObject.cacheId, url:weapon.additionalAttackUpAnimationObject.assetURL} );							if( weapon.additionalAttackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(weapon.additionalAttackDownAnimationObject.cacheId) == null ) assets.push( {id:weapon.additionalAttackDownAnimationObject.cacheId, url:weapon.additionalAttackDownAnimationObject.assetURL} );							if( weapon.switchWeaponOneAnimationObject && BitmapDataManager.getInstance().getBitmapData(weapon.switchWeaponOneAnimationObject.cacheId) == null ) assets.push( {id:weapon.switchWeaponOneAnimationObject.cacheId, url:weapon.switchWeaponOneAnimationObject.assetURL} );							if( weapon.switchWeaponTwoAnimationObject && BitmapDataManager.getInstance().getBitmapData(weapon.switchWeaponTwoAnimationObject.cacheId) == null ) assets.push( {id:weapon.switchWeaponTwoAnimationObject.cacheId, url:weapon.switchWeaponTwoAnimationObject.assetURL} );							if( BitmapDataManager.getInstance().getBitmapData(weapon.cacheIconId) == null ) assets.push( {id:weapon.cacheIconId, url:weapon.iconURL} );														if( int(weapon.projectileParticleEffect) > 0 )							{								animationObject = GameLevelDataIndex.getInstance().getAnimationObject(int(weapon.projectileParticleEffect));								assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );							}														if( weapon.otherWeaponId != 0 )							{								weapon = GameLevelDataIndex.getInstance().getWeapon( weapon.otherWeaponId );								if( weapon != null )								{									if( BitmapDataManager.getInstance().getBitmapData(weapon.upAnimationObject.cacheId) == null ) assets.push( {id:weapon.upAnimationObject.cacheId, url:weapon.upAnimationObject.assetURL} );									if( BitmapDataManager.getInstance().getBitmapData(weapon.downAnimationObject.cacheId) == null ) assets.push( {id:weapon.downAnimationObject.cacheId, url:weapon.downAnimationObject.assetURL} );									if( weapon.additionalAttackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(weapon.additionalAttackUpAnimationObject.cacheId) == null ) assets.push( {id:weapon.additionalAttackUpAnimationObject.cacheId, url:weapon.additionalAttackUpAnimationObject.assetURL} );									if( weapon.additionalAttackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(weapon.additionalAttackDownAnimationObject.cacheId) == null ) assets.push( {id:weapon.additionalAttackDownAnimationObject.cacheId, url:weapon.additionalAttackDownAnimationObject.assetURL} );																		if( int(weapon.projectileParticleEffect) > 0 )									{										animationObject = GameLevelDataIndex.getInstance().getAnimationObject(int(weapon.projectileParticleEffect));										assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );									}																	}							}														for( j=0; j<weapon.uniqueSoundDataIds.length; ++j )							{								//trace( "weapon.uniqueSoundDataIds["+j+"]: "+weapon.uniqueSoundDataIds[j] );								assets.push( {id:SoundsIndex.getInstance().getSoundById(weapon.uniqueSoundDataIds[j]).assetURL, url:SoundsIndex.getInstance().getSoundById(weapon.uniqueSoundDataIds[j]).assetURL} );							}						}						else if( attacks[i] is God )						{							god = attacks[i];														if( BitmapDataManager.getInstance().getBitmapData(god.cacheIconId) == null ) assets.push( {id:god.cacheIconId, url:god.iconURL} );							if( BitmapDataManager.getInstance().getBitmapData(god.animationObject.cacheId) == null ) assets.push( {id:god.animationObject.cacheId, url:god.animationObject.assetURL} );														for( j=0; j<god.uniqueSoundDataIds.length; ++j )							{								//trace( "god.uniqueSoundDataIds["+j+"]: "+god.uniqueSoundDataIds[j] );								assets.push( {id:SoundsIndex.getInstance().getSoundById(god.uniqueSoundDataIds[j]).assetURL, url:SoundsIndex.getInstance().getSoundById(god.uniqueSoundDataIds[j]).assetURL} );							}														//addBitmapToLoad( god.cacheIconId, god.iconURL );							animationObject = GameLevelDataIndex.getInstance().getAnimationObject(god.attackParticleAnimationObjectId);							assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );						}					}										weapon = null;					god = null;										return assets;				}							/** getGameLevelAssets			  *	---------------------------------------------------------------------------- *			  *	Returns the assets for the game levels. It includes enemy's animations,			  *	chickens, gates, and environment objects used in the game.			  *	---------------------------------------------------------------------------- */			 	public static function getGameLevelAssets( gameLevel:GameLevel ):Array				{					var assets:Array = new Array();					var distinctEnemiesInLevel:Array = gameLevel.distinctEnemiesInLevel;					var enemy:Enemy;					var j:int;										for( var i:int=0; i<distinctEnemiesInLevel.length; ++i )					{						enemy = GameLevelDataIndex.getInstance().getEnemy( gameLevel.distinctEnemiesInLevel[i].enemy );												if( enemy != null )						{							if( BitmapDataManager.getInstance().getBitmapData(enemy.cacheIconId) == null ) assets.push( {id:enemy.cacheIconId, url:enemy.iconURL} );							if( BitmapDataManager.getInstance().getBitmapData(enemy.walkUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.walkUpAnimationObject.cacheId, url:enemy.walkUpAnimationObject.assetURL} );							if( BitmapDataManager.getInstance().getBitmapData(enemy.walkDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.walkDownAnimationObject.cacheId, url:enemy.walkDownAnimationObject.assetURL} );							if( enemy.attackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.attackUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.attackUpAnimationObject.cacheId, url:enemy.attackUpAnimationObject.assetURL} );							if( enemy.attackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.attackDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.attackDownAnimationObject.cacheId, url:enemy.attackDownAnimationObject.assetURL} );							if( enemy.deathUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.deathUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.deathUpAnimationObject.cacheId, url:enemy.deathUpAnimationObject.assetURL} );							if( enemy.deathDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.deathDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.deathDownAnimationObject.cacheId, url:enemy.deathDownAnimationObject.assetURL} );							if( enemy.additionalAttackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.additionalAttackUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.additionalAttackUpAnimationObject.cacheId, url:enemy.additionalAttackUpAnimationObject.assetURL} );							if( enemy.additionalAttackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.additionalAttackDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.additionalAttackDownAnimationObject.cacheId, url:enemy.additionalAttackDownAnimationObject.assetURL} );														if( enemy.hatchlingId > 0 )							{								enemy = GameLevelDataIndex.getInstance().getEnemy( enemy.hatchlingId );																if( enemy != null )								{									if( BitmapDataManager.getInstance().getBitmapData(enemy.cacheIconId) == null ) assets.push( {id:enemy.cacheIconId, url:enemy.iconURL} );									if( BitmapDataManager.getInstance().getBitmapData(enemy.walkUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.walkUpAnimationObject.cacheId, url:enemy.walkUpAnimationObject.assetURL} );									if( BitmapDataManager.getInstance().getBitmapData(enemy.walkDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.walkDownAnimationObject.cacheId, url:enemy.walkDownAnimationObject.assetURL} );									if( enemy.attackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.attackUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.attackUpAnimationObject.cacheId, url:enemy.attackUpAnimationObject.assetURL} );									if( enemy.attackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.attackDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.attackDownAnimationObject.cacheId, url:enemy.attackDownAnimationObject.assetURL} );									if( enemy.deathUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.deathUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.deathUpAnimationObject.cacheId, url:enemy.deathUpAnimationObject.assetURL} );									if( enemy.deathDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.deathDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.deathDownAnimationObject.cacheId, url:enemy.deathDownAnimationObject.assetURL} );									if( enemy.additionalAttackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.additionalAttackUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.additionalAttackUpAnimationObject.cacheId, url:enemy.additionalAttackUpAnimationObject.assetURL} );									if( enemy.additionalAttackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.additionalAttackDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.additionalAttackDownAnimationObject.cacheId, url:enemy.additionalAttackDownAnimationObject.assetURL} );																		if( enemy.hatchlingId > 0 )									{										enemy = GameLevelDataIndex.getInstance().getEnemy( enemy.hatchlingId );																				if( enemy != null )										{											if( BitmapDataManager.getInstance().getBitmapData(enemy.cacheIconId) == null ) assets.push( {id:enemy.cacheIconId, url:enemy.iconURL} );											if( BitmapDataManager.getInstance().getBitmapData(enemy.walkUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.walkUpAnimationObject.cacheId, url:enemy.walkUpAnimationObject.assetURL} );											if( BitmapDataManager.getInstance().getBitmapData(enemy.walkDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.walkDownAnimationObject.cacheId, url:enemy.walkDownAnimationObject.assetURL} );											if( enemy.attackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.attackUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.attackUpAnimationObject.cacheId, url:enemy.attackUpAnimationObject.assetURL} );											if( enemy.attackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.attackDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.attackDownAnimationObject.cacheId, url:enemy.attackDownAnimationObject.assetURL} );											if( enemy.deathUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.deathUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.deathUpAnimationObject.cacheId, url:enemy.deathUpAnimationObject.assetURL} );											if( enemy.deathDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.deathDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.deathDownAnimationObject.cacheId, url:enemy.deathDownAnimationObject.assetURL} );											if( enemy.additionalAttackUpAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.additionalAttackUpAnimationObject.cacheId) == null ) assets.push( {id:enemy.additionalAttackUpAnimationObject.cacheId, url:enemy.additionalAttackUpAnimationObject.assetURL} );											if( enemy.additionalAttackDownAnimationObject && BitmapDataManager.getInstance().getBitmapData(enemy.additionalAttackDownAnimationObject.cacheId) == null ) assets.push( {id:enemy.additionalAttackDownAnimationObject.cacheId, url:enemy.additionalAttackDownAnimationObject.assetURL} );										}									}								}							}														for( j=0; j<enemy.uniqueSoundDataIds.length; ++j )							{								assets.push( {id:SoundsIndex.getInstance().getSoundById(enemy.uniqueSoundDataIds[j]).assetURL, url:SoundsIndex.getInstance().getSoundById(enemy.uniqueSoundDataIds[j]).assetURL} );							}						}					}										enemy = null;										var villager:Villager;					for( i=0; i<GameLevelDataIndex.getInstance().villagersCount; ++i )					{						villager = GameLevelDataIndex.getInstance().villagers[i];						if( villager.regularAnimationObject != null && BitmapDataManager.getInstance().getBitmapData(villager.regularAnimationObject.cacheId) == null ) assets.push( {id:villager.regularAnimationObject.cacheId, url:villager.regularAnimationObject.assetURL} );						if( villager.happyAnimationObject != null && BitmapDataManager.getInstance().getBitmapData(villager.happyAnimationObject.cacheId) == null ) assets.push( {id:villager.happyAnimationObject.cacheId, url:villager.happyAnimationObject.assetURL} );						if( villager.prayAnimationObject != null && BitmapDataManager.getInstance().getBitmapData(villager.prayAnimationObject.cacheId) == null ) assets.push( {id:villager.prayAnimationObject.cacheId, url:villager.prayAnimationObject.assetURL} );						if( villager.scaredAnimationObject != null && BitmapDataManager.getInstance().getBitmapData(villager.scaredAnimationObject.cacheId) == null ) assets.push( {id:villager.scaredAnimationObject.cacheId, url:villager.scaredAnimationObject.assetURL} );						if( villager.worriedAnimationObject != null && BitmapDataManager.getInstance().getBitmapData(villager.worriedAnimationObject.cacheId) == null ) assets.push( {id:villager.worriedAnimationObject.cacheId, url:villager.worriedAnimationObject.assetURL} );					}										var animationObject:AnimationObject;					/*					for( i=0; i<GameLevelDataIndex.getInstance().animationObjects.length; ++i )					{						animationObject = GameLevelDataIndex.getInstance().animationObjects[i];						assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					}					*/					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_LeftDoor');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_RightDoor');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_Piece1');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_Piece2');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_PostFire');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('WoodChip_Effect');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('RockChip_Effect');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('ChickenBounce');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('ChickenPeck');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('GoldenGlow');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('TakeawayPoof');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('PlacementPoof');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('ChickenCollect1');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );										var environment:EnvironmentObject;					for( i=0; i<gameLevel.environmentObjects.length; ++i )					{						environment = GameLevelDataIndex.getInstance().getEnvironmentObject( gameLevel.environmentObjects[i].environmentObjectId );						assets.push( {id:environment.name, url:environment.assetURL} );					}										for( i=0; i<gameLevel.villageObjects.length; ++i )					{						environment = GameLevelDataIndex.getInstance().getEnvironmentObject( gameLevel.villageObjects[i].environmentObjectId );						assets.push( {id:environment.name, url:environment.assetURL} );					}										//assets.push({ id:gameLevel.gameLevelBackgroundLinkageId, url:gameLevel.gameLevelBackgroundAssetURL });										return assets;				}							/** getVillageAssets			  *	---------------------------------------------------------------------------- *			  *	Returns the assets			  *	---------------------------------------------------------------------------- */			 	public static function getVillageAssets( gameLevel:GameLevel ):Array				{					var assets:Array = new Array();					var i:int;										var animationObject:AnimationObject;					//for( i=0; i<GameLevelDataIndex.getInstance().animationObjects.length; ++i )					//{						//animationObject = GameLevelDataIndex.getInstance().animationObjects[i];						//assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					//}					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_LeftDoor');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_RightDoor');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_Piece1');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_Piece2');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );					animationObject = GameLevelDataIndex.getInstance().getAnimationObjectByCacheId('Fence_PostFire');					assets.push( {id:animationObject.cacheId, url:animationObject.assetURL} );										var environment:EnvironmentObject;					for( i=0; i<gameLevel.environmentObjects.length; ++i )					{						environment = GameLevelDataIndex.getInstance().getEnvironmentObject( gameLevel.environmentObjects[i].environmentObjectId );						trace( "environmentObjects[i]: "+environment.name );						assets.push( {id:environment.name, url:environment.assetURL} );					}										for( i=0; i<gameLevel.villageObjects.length; ++i )					{						environment = GameLevelDataIndex.getInstance().getEnvironmentObject( gameLevel.villageObjects[i].environmentObjectId );						trace( "villageObjects[i]: "+environment.name );						assets.push( {id:environment.name, url:environment.assetURL} );					}										return assets;				}							/** sortGameObjectsOnLevelAvailability			  *	---------------------------------------------------------------------------- *			  *	Sorts the game objects according to the level availability ascending.			  *	---------------------------------------------------------------------------- */			 	public static function sortGameObjectsOnLevelAvailability( a:AbstractGameObject, b:AbstractGameObject ):int				{					if( a.availableOnLevel < b.availableOnLevel )						return -1;					else if( a.availableOnLevel > b.availableOnLevel )						return 1;										return 0;				}							/** findSpawnPath			  *	---------------------------------------------------------------------------- *			  *	Finds the spawn path			  *	---------------------------------------------------------------------------- */			 	public static function findSpawnPath( fromTile:Object, toTile:Object, horizontal:Boolean ):Array				{					var path:Array = new Array();					var i:int;					var currentRow:int = fromTile.r;					var currentColumn:int = fromTile.c;										path.push( {r:currentRow, c:currentColumn} );										if( horizontal )					{						if( currentColumn > toTile.c && currentColumn - toTile.c >= 2 )						{							--currentColumn;							path.push( {r:currentRow, c:currentColumn} );						}						else if( currentColumn < toTile.c && toTile.c - currentColumn >= 2 )						{							++currentColumn;							path.push( {r:currentRow, c:currentColumn} );						}					}					else					{						if( currentRow > toTile.r && currentRow - toTile.r >= 2 )						{							--currentRow;							path.push( {r:currentRow, c:currentColumn} );						}						else if( currentRow < toTile.r && toTile.r - currentRow >= 2 )						{							++currentRow;							path.push( {r:currentRow, c:currentColumn} );						}					}										while( currentRow != toTile.r || currentColumn != toTile.c )					{						if( horizontal )						{							if( currentColumn >= toTile.c+1 )							{								//move from right to left								//trace( "move left" );								--currentColumn;							}							else if( currentColumn <= toTile.c-1 )							{								//move from left to right								//trace( "move right" );								++currentColumn;							}							else if( currentRow > toTile.r )							{								//move from bottom to top								//trace( "move up" );								--currentRow;							}							else if( currentRow < toTile.r )							{								//move from top to bottom								//trace( "move down" );								++currentRow;							}							else if( currentColumn > toTile.c )							{								//trace( "move left" );								--currentColumn;							}							else if( currentColumn < toTile.c )							{								//trace( "move right" );								++currentColumn;							}							else							{								//trace( "there shouldn't be any more steps left" );								break;							}						}						else						{							if( currentRow >= toTile.r+1 )							{								//trace( "move up" );								--currentRow;							}							else if( currentRow <= toTile.r-1 )							{								//trace( "move down" );								++currentRow;							}							else if( currentColumn > toTile.c )							{								//trace( "move left" );								--currentColumn;							}							else if( currentColumn < toTile.c )							{								//trace( "move right" );								++currentColumn;							}							else if( currentRow > toTile.r )							{								//trace( "move up" );								--currentRow;							}							else if( currentRow < toTile.r )							{								//trace( "move down" );								++currentRow;							}							else							{								//trace( "there shouldn't be any more steps left" );								break;							}						}												path.push( {r:currentRow, c:currentColumn} );					}					/*					for( i=0; i<path.length; ++i )					{						trace( "r: "+path[i].r+", c:"+path[i].c );					}					*/					return path;				}											/** addDesaturatedFilterToMovieClip			  *	---------------------------------------------------------------------------- *			  *	Adds the desaturated filter to a movie clip.			  *	---------------------------------------------------------------------------- */			 	public static function addDesaturatedFilterToMovieClip( m:MovieClip ):void				{					var filters:Array = m.filters;					var filtersLength:int = filters.length;					var found:Boolean = false;										for( var i:int=0; i<filtersLength; ++i )					{						if( filters[i] is ColorMatrixFilter && ArrayUtil.areEqual( filters[i].matrix, DESATURATED_COLOR_MATRIX_FILTER.matrix ) )						{							found = true;							break;						}					}										if( !found )					{						filters[filtersLength] = DESATURATED_COLOR_MATRIX_FILTER;						m.filters = filters;						//m.alpha = .3;					}				}							/** removeDesaturatedFilterFromMovieClip			  *	---------------------------------------------------------------------------- *			  *	Removes the desaturated filter from a movie clip.			  *	---------------------------------------------------------------------------- */			 	public static function removeDesaturatedFilterFromMovieClip( m:MovieClip ):void				{					var filters:Array = m.filters;					var filtersLength:int = filters.length;										for( var i:int=0; i<filtersLength; ++i )					{						if( filters[i] is ColorMatrixFilter && ArrayUtil.areEqual( filters[i].matrix, DESATURATED_COLOR_MATRIX_FILTER.matrix ) )						{							filters.splice( i, 1 );							m.filters = filters;							//m.alpha = 1;							return;						}					}				}							/** checkForElement			  *	---------------------------------------------------------------------------- *			  *	Returns the element compatibility of a certain element.			  *	---------------------------------------------------------------------------- */			 	public static function checkForElement( object:* ):ElementCompatibility				{					if( _elements == null )					{						_elements = new Array();												//fire element						_elements.push( new ElementCompatibility(ATTACK_PROPERTY_FIRE_INDEX, ATTACK_PROPERTY_ICE_INDEX, ATTACK_PROPERTY_PROTECTION_FROM_FIRE_INDEX, ATTACK_PROPERTY_WEAK_AGAINST_FIRE_INDEX, ATTACK_PROPERTY_STRONG_AGAINST_FIRE_INDEX) );						//ice element						_elements.push( new ElementCompatibility(ATTACK_PROPERTY_ICE_INDEX, ATTACK_PROPERTY_FIRE_INDEX, ATTACK_PROPERTY_PROTECTION_FROM_ICE_INDEX, ATTACK_PROPERTY_WEAK_AGAINST_ICE_INDEX, ATTACK_PROPERTY_STRONG_AGAINST_ICE_INDEX) );						//rain element						_elements.push( new ElementCompatibility(ATTACK_PROPERTY_RAIN_INDEX, ATTACK_PROPERTY_FIRE_INDEX, ATTACK_PROPERTY_PROTECTION_FROM_RAIN_INDEX, -1, -1) );						_elements.push( new ElementCompatibility(ATTACK_PROPERTY_ENCHANTED_INDEX, -1, -1, ATTACK_PROPERTY_WEAK_AGAINST_ENCHANTED_INDEX, -1, 4) );						//_elements.push( {element:ATTACK_PROPERTY_FIRE_INDEX, elementAgainst:ATTACK_PROPERTY_ICE_INDEX, protection:ATTACK_PROPERTY_PROTECTION_FROM_FIRE_INDEX, strongAgainst:ATTACK_PROPERTY_STRONG_AGAINST_FIRE_INDEX, weakAgainst:ATTACK_PROPERTY_WEAK_AGAINST_ICE_INDEX} );						//_elements.push( {element:ATTACK_PROPERTY_ICE_INDEX, elementAgainst:ATTACK_PROPERTY_FIRE_INDEX, protection:ATTACK_PROPERTY_PROTECTION_FROM_ICE_INDEX, strongAgainst:ATTACK_PROPERTY_STRONG_AGAINST_ICE_INDEX, weakAgainst:ATTACK_PROPERTY_WEAK_AGAINST_FIRE_INDEX} );						//_elements.push( {element:ATTACK_PROPERTY_RAIN_INDEX, elementAgainst:ATTACK_PROPERTY_FIRE_INDEX, protection:ATTACK_PROPERTY_PROTECTION_FROM_RAIN_INDEX, strongAgainst:-1, weakAgainst:-1} );					}										//trace( "_elements.length: "+_elements.length );					//trace( "object: "+object );										var returnedObject:Object = new Object();					var i:int;										if( object is GameLevel )					{						//trace( "object is GameLevel" );						for( i=0; i<_elements.length; ++i )						{							//trace( "object has property of "+_elements[i].element+" ? "+object.hasProperty(_elements[i].element) );							if( object.hasProperty(_elements[i].element) )							{								return _elements[i];							}						}					}					else if( object is AbstractGameObject )					{						for( i=0; i<_elements.length; ++i )						{							//trace( "object has property of "+_elements[i].element+" ? "+object.hasAttackProperty(_elements[i].element) );							if( object.hasAttackProperty(_elements[i].element) )							{								return _elements[i];							}						}					}										return null;				}							/** getItemElements			  *	---------------------------------------------------------------------------- *			  *	Returns all the elements that an item has. This is usually used to			  *	determine which element icons to put on the description.			  *	---------------------------------------------------------------------------- */			 	public static function getItemElements( item:AbstractGameObject ):Array				{					var elements:Array = [];										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FIRE_INDEX) )					{						elements.push( "Element.Fire" );					}										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ICE_INDEX) )					{						elements.push("Element.Ice");					}										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_POISON_INDEX) )					{						elements.push("Element.Poison");					}										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ENCHANTED_INDEX) )					{						elements.push("Element.Enchanted");					}										if( item is Weapon && item.otherWeaponId != 0 )					{						var weapon2:Weapon = GameLevelDataIndex.getInstance().getWeapon( item.otherWeaponId );						if( weapon2.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FIRE_INDEX) )						{							elements.push( "Element.Fire" );						}												if( weapon2.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ICE_INDEX) )						{							elements.push("Element.Ice");						}												if( weapon2.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_POISON_INDEX) )						{							elements.push("Element.Poison");						}												if( weapon2.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ENCHANTED_INDEX) )						{							elements.push("Element.Enchanted");						}					}										return elements;				}							/** getItemStrongElements			  *	---------------------------------------------------------------------------- *			  *	Returns the strong elements from an item.			  *	---------------------------------------------------------------------------- */			 	public static function getItemStrongElements( item:AbstractGameObject ):Array				{					var elements:Array = [];										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_STRONG_AGAINST_FIRE_INDEX) )					{						elements.push("Element.NoFire");					}										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_STRONG_AGAINST_ICE_INDEX) )					{						elements.push("Element.NoIce");					}										if( item.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_STRONG_AGAINST_ENCHANTED_INDEX) )					{						elements.push("Element.NoEnchanted");					}										return elements;				}		}			}