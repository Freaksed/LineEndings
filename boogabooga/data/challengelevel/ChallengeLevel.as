/** ChallengeLevel  *	---------------------------------------------------------------------------- *  *	@desc:  *		ChallengeLevel data class  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */	package com.boogabooga.data.challengelevel	{		import flash.events.Event;		import flash.events.EventDispatcher;		import flash.events.IOErrorEvent;		import flash.events.FullScreenEvent;		import flash.events.ProgressEvent;		import flash.external.ExternalInterface;		import flash.net.URLLoader;		import flash.net.URLRequest;		import flash.net.URLRequestMethod;		import flash.net.URLVariables;				import com.adobe.serialization.json.JSONDecoder;		import com.adobe.serialization.json.JSONEncoder;		import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.console.ConsoleBroadcaster;				import com.boogabooga.data.challengelevel.ChallengeLevelWaveZone;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.ChickenMovementAreaData;		import com.boogabooga.data.gamelevel.GameLevelEnvironmentObject;		import com.boogabooga.data.gamelevel.GameLevelVillagerObject;		import com.boogabooga.data.gamelevel.WaveZone;		import com.boogabooga.data.maingame.*;		import com.boogabooga.utils.GameLevelUtil;				public class ChallengeLevel extends Object		{			protected var _id:uint;			protected var _name:int;			protected var _description:int;			protected var _paths:Array;			protected var _spawnPaths:Array;			protected var _waveZones:Vector.<ChallengeLevelWaveZone>;			protected var _buyChickenEnabled:Boolean;			protected var _slotEnabled:Boolean;			protected var _slotWinningProbability:uint;			protected var _startingChicken:uint;			protected var _chickenSpawnRateMin:uint;  // how many second it takes for a chicken to spawn			protected var _chickenSpawnRateMax:uint;			protected var _gateHealth:uint;			protected var _properties:Vector.<int>;			protected var _availableWeapons:Vector.<Object>;			protected var _availableGods:Vector.<Object>;			protected var _createdBy:String;			protected var _gameLevelBackgroundId:int;			protected var _gameLevelBackgroundAssetURL:String;			protected var _gameLevelBackgroundLinkageId:String;						protected var _environmentObjects:Vector.<GameLevelEnvironmentObject>;			protected var _villageObjects:Vector.<GameLevelEnvironmentObject>;			protected var _villagerObjects:Vector.<GameLevelVillagerObject>;						protected var _spawnPoints:Vector.<Vector.<Object>>; // [{r:3, c:3}, {r:5, c:3}, {r:4, c:6}]			protected var _chickenMovementAreaDatas:Vector.<ChickenMovementAreaData>;						/** Constructor			  *	---------------------------------------------------------------------- */				public function ChallengeLevel()				{					init();				}							/** init			  *	---------------------------------------------------------------------- */				public function init():void				{					_paths = new Array();					_spawnPaths = new Array();					_waveZones = new Vector.<ChallengeLevelWaveZone>;					_properties = new Vector.<int>;					_availableWeapons = new Vector.<Object>;					_availableGods = new Vector.<Object>;										_buyChickenEnabled = false;					_slotEnabled = false;										_startingChicken = 0;					_chickenSpawnRateMin = 1000;					_chickenSpawnRateMax = 2000;					_gateHealth = 100;										_name = 0;					_description = 0;					_createdBy = "";										_environmentObjects = new Vector.<GameLevelEnvironmentObject>;					_villageObjects = new Vector.<GameLevelEnvironmentObject>;					_villagerObjects = new Vector.<GameLevelVillagerObject>;										_spawnPoints = new Vector.<Vector.<Object>>;					_spawnPoints[0] = new Vector.<Object>;					_spawnPoints[1] = new Vector.<Object>;					_spawnPoints[2] = new Vector.<Object>;					_chickenMovementAreaDatas = new Vector.<ChickenMovementAreaData>;					_chickenMovementAreaDatas.push( new ChickenMovementAreaData() );					_chickenMovementAreaDatas.push( new ChickenMovementAreaData() );					_chickenMovementAreaDatas.push( new ChickenMovementAreaData() );				}							/** set/get id			  *	---------------------------------------------------------------------- */				public function set id( u:uint ):void { _id = u; }				public function get id():uint { return _id; }							/** set/get name			  *	---------------------------------------------------------------------- */				public function set name( i:int ):void { _name = i; }				public function get name():int { return _name; }							/** set/get description			  *	---------------------------------------------------------------------- */				public function set description( i:int ):void { _description = i; }				public function get description():int { return _description; }								public function set level( i:int ):void { _level = i; }				public function get level():int { return _level; }							/** paths			  *	---------------------------------------------------------------------- */			  	public function set paths( a:Array ):void { _paths = a; }				public function get paths():Array { return _paths; }								public function set spawnPaths( a:Array ):void { _spawnPaths = a; }				public function get spawnPaths():Array { return _spawnPaths; }							/** waveZones			  *	---------------------------------------------------------------------- */				public function addWaveZone( waveZone:ChallengeLevelWaveZone ):void				{					_waveZones.push( waveZone );				}				public function set waveZones( v:Vector.<ChallengeLevelWaveZone> ) { _waveZones = v; }				public function get waveZones():Vector.<ChallengeLevelWaveZone> { return _waveZones; }							/** set/get buyChickenEnabled			  *	---------------------------------------------------------------------- */				public function set buyChickenEnabled( b:Boolean ):void { _buyChickenEnabled = b; }				public function get buyChickenEnabled():Boolean { return _buyChickenEnabled; }							/** set/get slotEnabled			  *	---------------------------------------------------------------------- */				public function set slotEnabled( b:Boolean ):void { _slotEnabled = b; }				public function get slotEnabled():Boolean { return _slotEnabled; }							/** set/get slotWinningProbability			  *	---------------------------------------------------------------------- */				public function set slotWinningProbability( u:uint ):void { _slotWinningProbability = u; }				public function get slotWinningProbability():uint { return _slotWinningProbability; }							/** set/get startingChicken			  *	---------------------------------------------------------------------- */				public function set startingChicken( u:uint ):void { _startingChicken = u; }				public function get startingChicken():uint { return _startingChicken; }							/** set/get chickenSpawnRateMin			  *	---------------------------------------------------------------------- */				public function set chickenSpawnRateMin( u:uint ):void { _chickenSpawnRateMin = u; }				public function get chickenSpawnRateMin():uint { return _chickenSpawnRateMin; }								public function set chickenSpawnRateMax( u:uint ):void { _chickenSpawnRateMax = u; }				public function get chickenSpawnRateMax():uint { return _chickenSpawnRateMax; }							/** set/get gateHealth			  *	---------------------------------------------------------------------- */				public function set gateHealth( u:uint ):void { _gateHealth = u; }				public function get gateHealth():uint { return _gateHealth; }								public function set createdBy( s:String ):void { _createdBy = s; }				public function get createdBy():String { return _createdBy; }								public function set properties( v:Vector.<int> ):void { _properties = v; }				public function get properties():Vector.<int> { return _properties; }								public function set availableWeapons( v:Vector.<Object> ):void { _availableWeapons = v; }				public function get availableWeapons():Vector.<Object> { return _availableWeapons; }								public function set availableGods( v:Vector.<Object> ):void { _availableGods = v; }				public function get availableGods():Vector.<Object> { return _availableGods; }							/** set/get gameLevelBackgroundAssetURL			  *	---------------------------------------------------------------------- */				public function set gameLevelBackgroundAssetURL( s:String ):void { _gameLevelBackgroundAssetURL = s; }				public function get gameLevelBackgroundAssetURL():String { return _gameLevelBackgroundAssetURL; }								public function set gameLevelBackgroundLinkageId( s:String ):void { _gameLevelBackgroundLinkageId = s; }				public function get gameLevelBackgroundLinkageId():String { return _gameLevelBackgroundLinkageId; }								public function set gameLevelBackgroundId( i:int ):void { _gameLevelBackgroundId = i; }				public function get gameLevelBackgroundId():int { return _gameLevelBackgroundId; }								public function set environmentObjects( v:Vector.<GameLevelEnvironmentObject> ):void { _environmentObjects = v; }				public function get environmentObjects():Vector.<GameLevelEnvironmentObject> { return _environmentObjects; }								public function set villageObjects( v:Vector.<GameLevelEnvironmentObject> ):void { _villageObjects = v; }				public function get villageObjects():Vector.<GameLevelEnvironmentObject> { return _villageObjects; }								public function set villagerObjects( v:Vector.<GameLevelVillagerObject> ):void { _villagerObjects = v; }				public function get villagerObjects():Vector.<GameLevelVillagerObject> { return _villagerObjects; }								public function set spawnPoints( v:Vector.<Vector.<Object>> ):void { _spawnPoints = v; }				public function get spawnPoints():Vector.<Vector.<Object>> { return _spawnPoints; }								public function set chickenMovementAreaDatas( v:Vector.<ChickenMovementAreaData> ):void { _chickenMovementAreaDatas = v; }				public function get chickenMovementAreaDatas():Vector.<ChickenMovementAreaData> { return _chickenMovementAreaDatas; }							/** get distinctEnemiesInLevel			  *	---------------------------------------------------------------------- 				public function get distinctEnemiesInLevel():Array				{					var enemies:Array = new Array();					var tempEnemies:Array;					var enemyObject:Object;										var i:uint, j:uint;										for( i=0; i<_waveZones.length; ++i )					{						tempEnemies = _waveZones[i].distinctEnemiesInWaveZone;												for( j=0; j<tempEnemies.length; ++j )						{							enemyObject = ArrayUtil.find( enemies, tempEnemies[j], "enemy" );							if( enemyObject == null )								enemies.push( {enemy:tempEnemies[j].enemy, quantity:tempEnemies[j].quantity} );							else								enemyObject.quantity += tempEnemies[j].quantity;						}					}										//trace( "enemiesInLevel: "+enemies );										return enemies;				}*/								public function addProperty( i:int ):void				{					_properties.push( i );				}				public function hasProperty( i:int ):Boolean				{					return (VectorUtil.find(_properties, i) != null );				}							/** isPath			  *	---------------------------------------------------------------------- *			  *	Checks to see if the certain column is end of a path.			  *	---------------------------------------------------------------------- */				public function isPath( column:int ):Boolean				{					for( var i:int=0; i<_paths.length; ++i )					{						//trace( _paths[i][0].r );												if( _paths[i][_paths[i].length-1].c == column )						{							return true;						}					}										return false;				}							/** serialize			  *	---------------------------------------------------------------------- */				public function serialize():String				{					var returnedObj:Object = new Object();						returnedObj.id = _id;						returnedObj.name = _name;						returnedObj.created_by = _createdBy;						returnedObj.starting_chicken = _startingChicken;						returnedObj.chicken_spawn_rate = _chickenSpawnRateMin+","+_chickenSpawnRateMax;						returnedObj.slot_winning_probability = _slotWinningProbability;						returnedObj.slot_enabled = _slotEnabled;						returnedObj.gate_health = _gateHealth;						returnedObj.paths = new JSONEncoder(_paths).getString();											var i:int, j:int;										var wavezones:Array = new Array();					for( i=0; i<_waveZones.length; ++i )					{						wavezones[i] = _waveZones[i].serialize();					}					returnedObj.wavezones = new JSONEncoder(wavezones).getString();										//returnedObj.spawn_points = new JSONEncoder(_spawnPoints).getString();					var tempSpawnPoints = new Array();					for( i=0; i<_spawnPoints.length; ++i )					{						tempSpawnPoints[i] = new Array();						for( j=0; j<_spawnPoints[i].length; ++j )						{							tempSpawnPoints[i].push( {r:_spawnPoints[i][j].r, c:_spawnPoints[i][j].c} );						}					}					returnedObj.spawn_points = new JSONEncoder(tempSpawnPoints).getString();										var tempChickenMovementAreaDatas:Array = new Array();					for( i=0; i<_chickenMovementAreaDatas.length; ++i )					{						tempChickenMovementAreaDatas[i] = {};						tempChickenMovementAreaDatas[i].tl = _chickenMovementAreaDatas[i].topLeft;						tempChickenMovementAreaDatas[i].tr = _chickenMovementAreaDatas[i].topRight;						tempChickenMovementAreaDatas[i].bl = _chickenMovementAreaDatas[i].bottomLeft;						tempChickenMovementAreaDatas[i].br = _chickenMovementAreaDatas[i].bottomRight;					}					returnedObj.chicken_movement_areas = new JSONEncoder(tempChickenMovementAreaDatas).getString();										return new JSONEncoder(returnedObj).getString();				}							/** deserialize			  *	---------------------------------------------------------------------- */				public function deserialize( serializedWaveZones:String, serializedPaths:String, serializedSpawnPoints:String, serializedChickenMovementAreas:String ):void				{					var tempWaveZones:Array = new JSONDecoder(serializedWaveZones).getValue();					var tempPaths:Array = new JSONDecoder(serializedPaths).getValue();					var i:int, j:int, k:int;					var waveZone:WaveZone;					var wave:Wave;					var enemies:Array;					var enemiesInWave:Array;					var enemy:Object;										_waveZones = new Vector.<WaveZone>;										for( i=0; i<tempWaveZones.length; ++i )					{						waveZone = new WaveZone();						waveZone.id = i;						waveZone.spawnInterval = tempWaveZones[i]["si"];						waveZone.startDelayInterval = tempWaveZones[i]["sdi"];						waveZone.waveInterval = tempWaveZones[i]["wi"];												for( j=0; j<tempWaveZones[i]["waves"].length; ++j )						{							wave = new Wave();							//wave.enemies = tempWaveZones[i]["waves"][j];														enemies = new Array();														for( k=0; k<tempWaveZones[i]["waves"][j].length; ++k )							{								enemy = {enemy:tempWaveZones[i]["waves"][j][k]["e"], quantity:tempWaveZones[i]["waves"][j][k]["q"]}								enemies.push( enemy );							}							//wave.addEnemies( enemies );							wave.enemies = enemies;							//wave.enemies.push( enemies );							//wave.enemies.push( {enemy:tempWaveZones[i]["waves"][j]["e"], quantity:tempWaveZones[i]["waves"][j]["q"]} );														waveZone.addWave( wave );						}												//trace( "waveZone.totalNumberOfEnemies: "+waveZone.totalNumberOfEnemies );												_waveZones.push( waveZone );					}										_paths = tempPaths;										tempWaveZones = null;					tempPaths = null;										//_spawnPoints = new JSONDecoder( serializedSpawnPoints ).getValue();										var tempData:Array = new JSONDecoder(serializedChickenMovementAreas).getValue();					for( i=0; i<tempData.length; ++i )					{						//trace( 'topLeft: '+tempData[i]['tl'] );						//trace( 'topRight.r: '+tempData[i]['tr'].r+', c: '+tempData[i]['tr'].c );												_chickenMovementAreaDatas[i] = new ChickenMovementAreaData();						_chickenMovementAreaDatas[i].topLeft = tempData[i]['tl'];						_chickenMovementAreaDatas[i].topRight = tempData[i]['tr'];						_chickenMovementAreaDatas[i].bottomLeft = tempData[i]['bl'];						_chickenMovementAreaDatas[i].bottomRight = tempData[i]['br'];						_chickenMovementAreaDatas[i].addTilesFromBounds();					}										tempData = new JSONDecoder( serializedSpawnPoints ).getValue();					for( i=0; i<tempData.length; ++i )					{						for( j=0; j<tempData[i].length; ++j )						{							_spawnPoints[i].push( {r:tempData[i][j].r, c:tempData[i][j].c} );						}					}										findSpawnPaths();				}							/** findSpawnPaths			  *	---------------------------------------------------------------------- */				public function findSpawnPaths():void				{					ArrayUtil.removeAll( _spawnPaths );										var randomSpawnPointIndex:int = 0;					var startingPosition:Object = new Object();					var i:int;										for( i=0; i<_paths.length; ++i )					{						if( _spawnPoints[0].length > 0 && _paths[i][0].c == GameLevelDataIndex.getInstance().boardMaxColumns-1 )						{							//trace( "_spawnPoints[0] length: "+_spawnPoints[0].length );							randomSpawnPointIndex = int(Math.random() * _spawnPoints[0].length);							//trace( "randomSpawnPointIndex: "+randomSpawnPointIndex );							startingPosition.r = _spawnPoints[0][randomSpawnPointIndex].r;							startingPosition.c = _spawnPoints[0][randomSpawnPointIndex].c;							//trace( "finding spawn path from ("+startingPosition.r+", "+startingPosition.c+") to ("+_paths[i][0].r+", "+0+")" );							_spawnPaths.push( {area:0, path:GameLevelUtil.findSpawnPath(startingPosition, {r:_paths[i][0].r, c:0}, true)} );						}						else if( _spawnPoints[1].length > 0 && _paths[i][0].r == GameLevelDataIndex.getInstance().boardMaxRows-1 )						{							randomSpawnPointIndex = int(Math.random() * _spawnPoints[1].length);							startingPosition.r = _spawnPoints[1][randomSpawnPointIndex].r;							startingPosition.c = _spawnPoints[1][randomSpawnPointIndex].c;							//trace( "finding spawn path from ("+startingPosition.r+", "+startingPosition.c+") to ("+0+", "+_paths[i][0].c+")" );							_spawnPaths.push( {area:1, path:GameLevelUtil.findSpawnPath(startingPosition, {r:0, c:_paths[i][0].c}, false)} );						}						else if( _spawnPoints[2].length > 0 && _paths[i][0].c == 0 )						{							randomSpawnPointIndex = int(Math.random() * _spawnPoints[2].length);							startingPosition.r = _spawnPoints[2][randomSpawnPointIndex].r;							startingPosition.c = _spawnPoints[2][randomSpawnPointIndex].c;							//trace( "finding spawn path from ("+startingPosition.r+", "+startingPosition.c+") to ("+_paths[i][0].r+", "+7+")" );							_spawnPaths.push( {area:2, path:GameLevelUtil.findSpawnPath(startingPosition, {r:_paths[i][0].r, c:7}, true)} );						}					}				}							/** clone			  *	---------------------------------------------------------------------- */				public function clone():ChallengeLevel				{					var clonedObject:ChallengeLevel = UtilFunctions.clone(this) as ChallengeLevel;										return clonedObject;				}							/** Reformat path so it always starts where enemies spawn			  *	---------------------------------------------------------------------- */				public static function formatPath( path:Array ):Array				{					//If first tile is on the first row, that means that it's the end of the path.					var newPath:Array = new Array();										if( path[0].r == 0 )					{						var oldPath:Array = path.concat();												while( oldPath.length > 0 )						{							newPath.push( oldPath.pop() );						}												//path = newPath;						return newPath;					}										return path;				}										}			}