/** PathWeaponDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Weapon class.  *		Weapon properties ( Create classes to represent these different weapons )  *			- single lane / multiple lane  *			- shoots one direction / all directions  *			- affect flying enemies / not  *			- affect digging enemies / not  *			- projectile / close range / blocking / trap / instant  *			- one hit kill  *			- element properties ( fire, ice, poison )  *			- modifier ( can add attributes to existing weapons )  *			- area of effect on hit  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel.weapons	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.events.Event;		import flash.events.TimerEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.utils.getDefinitionByName;				import com.greensock.TweenLite;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.cache.BitmapDataManager;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.sound.SoundEffectPlayer;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.userinterface.UILabel;		import com.desuade.partigen.emitters.Emitter;		import com.desuade.partigen.events.ParticleEvent;		import org.osflash.signals.Signal;				//import com.gamelevel.data.*;		import com.boogabooga.data.SoundData;		import com.boogabooga.data.SoundsIndex;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.events.BoogaEvent;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.AnimationDisplayObject;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.ui.gamelevel.weapons.WeaponDisplayObject;		import com.boogabooga.utils.GameLevelUtil;				public class PathWeaponDisplayObject extends WeaponDisplayObject		{			protected var _targetTile:GameboardTile;			protected var _targetPoint:Point;			protected var _currentSpeed:Number;			protected var _halfwayPoint:Point;			protected var _soundPlaying:Boolean;			protected var _currentSoundDataId:String;						protected var _oldAnimationDirection:int;			protected var _moving:Boolean;			protected var _overshootX:Boolean;			protected var _overshootY:Boolean;						public var onMovedToNextTile:Signal;			public var onMovedToNextPoint:Signal;			public var onPathEnded:Signal;						/**	Stage Instances **/			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function PathWeaponDisplayObject( contentClip:MovieClip=null )				{					super( contentClip );										//init();				}							/** set/get contentClip			  *	---------------------------------------------------------------------------- 				override public function set contentClip( m:MovieClip ):void				{					super.contentClip = m;										//upAnimation_mc.addEventListener( "onAnimationEvent", handleAnimationEventFired, false, 0, true );					//downAnimation_mc.addEventListener( "onAnimationEvent", handleAnimationEventFired, false, 0, true );				}*/							/** set/get attackingGameObject			  *	---------------------------------------------------------------------------- */				override public function set attackingGameObject( a:AbstractGameObject ):void				{					super.attackingGameObject = a;										_currentSpeed = a.additionalAttackValue;				}							/** set currentIndexInPath			  *	---------------------------------------------------------------------------- *			  *	For enemy, the directions they are facing is the other way since they are			  *	travelling from the end of the path.			  *	---------------------------------------------------------------------------- */				override public function set currentIndexInPath( i:int ):void				{					_currentIndexInPath = i;										//trace( _path );										//TODO:					//	There might be a bug with the initial direction, keep an eye on this!!!!					if( _currentIndexInPath == 0 )						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], null );					//else if( _currentIndexInPath == _pathLength-1 )						//_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], _path[_currentIndexInPath-1] );					else						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], _path[_currentIndexInPath-1] );										if( _oldDirection < 0 )						_oldDirection = _direction;										//trace( '_direction: '+_direction );									}							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					//trace( "PathWeaponDisplayObject: init();" );										super.init();										_debug = true;					_soundPlaying = false;										_attacking = false;					_moving = false;										_targetPoint = new Point();					_halfwayPoint = new Point();					_currentSpeed = 4;					_oldAnimationDirection = -1;					_oldDirection = -1;										_overshootX = false;					_overshootY = false;										onMovedToNextTile = new Signal( PathWeaponDisplayObject, GameboardTile );					onMovedToNextPoint = new Signal( PathWeaponDisplayObject );					onPathEnded = new Signal( PathWeaponDisplayObject );				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					/*					if( _moving )					{						_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );					}					else if( _attacking )					{						_attackTimer.pause();					}					*/					_currentAnimationDisplayObject.pause();				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					/*					if( _moving )					{						_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );					}					else if( _attacking )					{						_attackTimer.unpause();					}					*/					_currentAnimationDisplayObject.unpause();				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "PathWeaponDisplayObject", "kill();" );										_needToBeUpdatedOnEnterFrame = false;										if( _soundPlaying )					{						SoundEffectPlayer.getInstance().stopSound( _currentSoundDataId, _contentClip.name, _currentSoundDataId );					}										if( _moving )					{						stopMoving();					}										//upAnimation_mc.removeEventListener( "onAnimationEvent", handleAnimationEventFired );					//downAnimation_mc.removeEventListener( "onAnimationEvent", handleAnimationEventFired );										_targetTile = null;										super.kill();				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				override public function updateOnEnterFrame():void				{					if( _needToBeUpdatedOnEnterFrame )					{						if( _moving )						{							handleEnterFrameMoving(null);						}												if( _currentAnimationDisplayObject != null )							_currentAnimationDisplayObject.showNextAnimation();					}				}							/** die			  *	---------------------------------------------------------------------------- */				override public function die():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "PathWeaponDisplayObject", "die();" );										if( _alive )					{						/*						_alive = false;												stopAttacking();						stopMoving();												//TODO:						//	Play the death animation												_currentAnimationDisplayObject.stopAnimation();						_currentAnimationDisplayObject.visible = false;												dispatchEvent( new GameLevelEvent(GameLevelEvent.DIE) );						dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );						*/												stopMoving();												super.die();					}										//trace( "_tilesWatching: "+_tilesWatching );										//var i:uint;										//kill();									}							/** placedOnBoard			  *	---------------------------------------------------------------------------- *			  *	Called when WeaponDisplayObject gets added to the stage.			  *	Each weapon type is going to do different things ( either going to just stay			  *	static or actually going to start animating ).			  *	---------------------------------------------------------------------------- */				override public function placedOnBoard():void				{					//ConsoleBroadcaster.broadcast( "PathWeaponDisplayObject", "placedOnBoard();" );										//_currentAnimationDisplayObject.showAnimation( 0 );					//trace( '_direction: '+_direction );										//showAnimation( _direction );										_alive = true;										startMoving();									}								public function playHitSound():void				{					if( _attackingGameObject.hitSoundDataIds.length > 0 )					{						var randomIndex:int = int( Math.random()*_attackingGameObject.hitSoundDataIds.length );						var soundData:SoundData = SoundsIndex.getInstance().getSoundById(_attackingGameObject.hitSoundDataIds[randomIndex]);						SoundEffectPlayer.getInstance().playLibrarySound( soundData.soundId, false, soundData.soundId, soundData.soundId );					}				}								protected function startMoving():void				{					//trace( "path: "+_path );										if( !_moving && _path != null )					{						_moving = true;												showAnimation( _direction );												moveToNextTile();					}				}								protected function stopMoving():void				{					if( _moving )					{						_moving = false;						//_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );					}				}								protected function moveToNextTile():void				{					if( _currentIndexInPath >= 0 )					{						_currentTile = _path[_currentIndexInPath];												//if( _currentIndexInPath == 0 )							//_targetTile = _path[_currentIndexInPath];						//else							//_targetTile = _path[_currentIndexInPath-1];												//trace( "_direction: "+_direction );						//trace( "_oldDirection: "+_oldDirection );												_moving = true;												var tileBound:Rectangle = _currentTile.getTileBound();												if( _oldDirection != _direction )						{							showAnimation( _oldDirection <= 0 ? _direction : _oldDirection );							_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y;						}						else						{							showAnimation( _direction );														if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y + tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.bottom );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y - tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x - tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x + tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y;							}						}												//trace( "_direction: "+_direction );						//trace( "_targetPoint: "+_targetPoint );						//trace( "_halfwayPoint: "+_halfwayPoint );						//trace( "_currentIndexInPath: "+_currentIndexInPath );												//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );						//dispatchEvent( new GameLevelEvent( GameLevelEvent.MOVING_TO_NEXT_TILE, {tile:_currentTile}) );						onMovedToNextTile.dispatch( this, _currentTile );					}				}								protected function handleEnterFrameMoving( event:Event ):void				{					if( _overshootX || _overshootY )					{						if( _oldDirection == _direction )						{							_overshootX = false;							_overshootY = false;														//_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );														if( _currentIndexInPath > 0 )							{								_oldDirection = _direction;								this.currentIndexInPath -= 1;																moveToNextTile();							}							else							{								//dispatchEvent( new GameLevelEvent(GameLevelEvent.PATH_END) );								onPathEnded.dispatch( this );								die();							}						}						else						{							_overshootX = false;							_overshootY = false;														var tileBound:Rectangle = _currentTile.getTileBound();							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top );							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.bottom );							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height*0.5 );							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height*0.5 );							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );							}														_oldDirection = _direction;														showAnimation( _direction );														//trace( "moving to tile "+_path[_currentIndexInPath-1] );													}					}					else					{						moveToNextPoint();					}				}								protected function moveToNextPoint():void				{					var moveX:Number = _targetPoint.x - _positionIn2D.x;					var moveY:Number = _targetPoint.y - _positionIn2D.y;										var nextMoveX:Number;					var nextMoveY:Number;					var moveXNegative:Boolean;					var moveYNegative:Boolean;										if( moveX != 0 )					{						_overshootX = (moveX < 0 ? -moveX : moveX) < _currentSpeed;												moveXNegative = moveX < 0;						moveX = (moveX < 0 ? -moveX : moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveX;												_positionIn2D.x += moveX;					}										if( moveY != 0 )					{						_overshootY = (moveY < 0 ? -moveY : moveY) < _currentSpeed;												moveYNegative = moveY < 0;												moveY = (moveY < 0 ? -moveY : moveY) > _currentSpeed ? (moveYNegative ? -_currentSpeed : _currentSpeed) : moveY;												_positionIn2D.y += moveY;					}										//trace( "_currentSpeed: "+_currentSpeed );					//trace( "moveX: "+moveX );					//trace( "moveY: "+moveY );					//trace( "_overshootX: "+_overshootX );					//trace( "_overshootY: "+_overshootY );										if( _overshootX )					{						nextMoveX = 0;					}					else					{						nextMoveX = _targetPoint.x - _positionIn2D.x;												moveXNegative = moveX < 0;						nextMoveX = (moveX < 0 ? -moveX : moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveX;					}										if( _overshootY )					{						nextMoveY = 0;					}					else					{						nextMoveY = _targetPoint.y - _positionIn2D.y;												moveYNegative = moveY < 0;						nextMoveY = (moveY < 0 ? -moveY : moveY) > _currentSpeed ? (moveYNegative ? -_currentSpeed : _currentSpeed) : moveY;					}					/*					_nextMovementPoints[0] = new Point( _positionIn2D.x+nextMoveX, _positionIn2D.y+nextMoveY );										if( _overshootX )					{						nextMoveX = 0;					}					else					{						nextMoveX = _targetPoint.x - _nextMovementPoints[0].x;												moveXNegative = moveX < 0;						nextMoveX = Math.abs(moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveY;					}										if( _overshootY )					{						nextMoveY = 0;					}					else					{						nextMoveY = _targetPoint.x - _nextMovementPoints[0].y;												moveYNegative = moveY < 0;						nextMoveY = Math.abs(moveY) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveY;					}										_nextMovementPoints[1] = new Point( _nextMovementPoints[0].x+nextMoveX, _nextMovementPoints[0].y+nextMoveY );					*/					if( moveX == 0 && moveY == 0 )					{						_overshootX = true;						_overshootY = true;					}										//trace( "_positionIn2D: "+_positionIn2D );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING) );					onMovedToNextPoint.dispatch( this );										render();				}							/** showAnimation			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				override protected function showAnimation( direction:int ):void				{					//trace( 'showAnimation('+direction+');' );					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "showAnimation("+direction+");" );										//trace( "_oldDirection: "+_oldDirection );										if( direction != _oldDirection && _oldDirection >= 0 )						direction = _oldDirection;										//var newAnimationDisplayObject:AnimationDisplayObject;										if( _oldAnimationDirection != direction )					{						_oldAnimationDirection = direction;												if( _currentAnimationDisplayObject != null )						{							_currentAnimationDisplayObject.contentClip.visible = false;							_currentAnimationDisplayObject.stopAnimation();						}												//trace( 'switch direction: '+direction );												switch( direction )						{							case GameLevelUtil.DIRECTION_UP:								_upAnimationClip.initCanvas( false );								_currentAnimationDisplayObject = _upAnimationClip;								break;														case GameLevelUtil.DIRECTION_RIGHT:								_upAnimationClip.initCanvas( true );								_currentAnimationDisplayObject = _upAnimationClip;								break;															case GameLevelUtil.DIRECTION_DOWN:								_downAnimationClip.initCanvas( false );								_currentAnimationDisplayObject = _downAnimationClip;								break;															case GameLevelUtil.DIRECTION_LEFT:								_downAnimationClip.initCanvas( true );								_currentAnimationDisplayObject = _downAnimationClip;								break;						}												_currentAnimationDisplayObject.startAnimation( true, 0 );						_currentAnimationDisplayObject.contentClip.visible = true;												//trace( 'currentAnimationDisplayObject clip: '+_currentAnimationDisplayObject.contentClip.name );					}				}							/** handleSoundEventFired			  *	---------------------------------------------------------------------------- */				override protected function handleSoundEventFired( soundDataId:int ):void				{					//trace( "handleSoundEventFired();" );					//trace( "sound id that should play "+event.customParameters.soundDataId );										if( !_soundPlaying )					{						_soundPlaying = true;												var soundData:SoundData = SoundsIndex.getInstance().getSoundById(soundDataId);						//trace( "play sound: "+soundData.soundId );						//trace( "sound volume: "+soundData.volume );						//trace( SoundEffectPlayer.getInstance().getVolume( soundData.soundId ) );						_currentSoundDataId = soundData.soundId;						SoundEffectPlayer.getInstance().playLibrarySound( _currentSoundDataId, true, _contentClip.name, _currentSoundDataId );						soundData = null;					}				}							/** attackTargets			  *	---------------------------------------------------------------------------- *			  *	See if this object can attack one of the targets that are given.			  *	It always attacks the closest target.			  *	---------------------------------------------------------------------------- 				override public function attackTargets( targets:Vector.<GameLevelAttackingDisplayObject> ):GameLevelAttackingDisplayObject				{					if( _alive )					{						_attackedTarget = super.attackTargets( targets );												if( _attackedTarget != null )						{							if( !_attackingGameObject.oneDirectionOnly ) showAnimation( _direction );							return _attackedTarget;						}					}										return null;				}*/							/** handleAnimationEventFired			  *	---------------------------------------------------------------------------- */				override protected function handleAnimationEventFired():void				{					//ConsoleBroadcaster.broadcast( "PathWeaponDisplayObject", "handleAnimationEventFired();" );										//if( _alive && _attackedTarget != null )					//{						//TODO:						//	Depending on the type of weapons, it will either 						//_attackedTarget.hit( _attackingGameObject, _attackingGameObject.power );						//_attackedTarget = null;												//_hasFired = true;						//trace( "shootTo: "+_attackedTarget.positionIn2D );											//}				}						}			}