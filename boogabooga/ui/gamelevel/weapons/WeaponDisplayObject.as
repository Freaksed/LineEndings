/** WeaponDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Weapon class.  *		Weapon properties ( Create classes to represent these different weapons )  *			- single lane / multiple lane  *			- shoots one direction / all directions  *			- affect flying enemies / not  *			- affect digging enemies / not  *			- projectile / close range / blocking / trap / instant  *			- one hit kill  *			- element properties ( fire, ice, poison )  *			- modifier ( can add attributes to existing weapons )  *			- area of effect on hit  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel.weapons	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.display.Sprite;		import flash.events.Event;		import flash.events.MouseEvent;		import flash.events.TimerEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.utils.getDefinitionByName;				import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.cache.BitmapDataManager;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.sound.SoundEffectPlayer;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.userinterface.UILabel;		import com.desuade.partigen.emitters.Emitter;		import com.desuade.partigen.events.ParticleEvent;		//import com.greensock.TweenLite;		import org.osflash.signals.Signal;				//import com.gamelevel.data.*;		import com.boogabooga.data.SettingsIndex;		import com.boogabooga.data.SoundData;		import com.boogabooga.data.SoundsIndex;		import com.boogabooga.data.StringsIndex;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.events.BoogaEvent;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.AnimationDisplayObject;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.GameLevelAttackingDisplayObject;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.ui.gamelevel.enemies.EnemyDisplayObject;		import com.boogabooga.utils.GameLevelUtil;				public dynamic class WeaponDisplayObject extends GameLevelAttackingDisplayObject		{			//protected var _tilesWatching:Array;						//protected var _enemiesAttacked:Array;						protected var _oldDirection:int;			//protected var _canAttackFlyer:Boolean;			//protected var _canAttackDigger:Boolean;						//protected var _attackedTarget:GameLevelAttackingDisplayObject;			protected var _currentAnimationDisplayObject:AnimationDisplayObject;						//protected var _hitByLaserEnemies:Vector.<EnemyDisplayObject>;						protected var _shield:ShieldWeaponDisplayObject;			protected var _addition:AdditionWeaponDisplayObject;			protected var _additionalClipOnGameboard:AnimationDisplayObject;						protected var _upAnimationClip:AnimationDisplayObject;			protected var _downAnimationClip:AnimationDisplayObject;			protected var _deathAnimationClip:AnimationDisplayObject;						protected var _toStringOutput:String;			private var _speedUp:Boolean;						public var onRemovedFromGame:Signal;			public var onRolledOver:Signal;			public var onRolledOut:Signal;						/**	Stage Instances **/			//public var tempName_mc:UILabel;			public var upAnimation_mc:MovieClip;			//public var rightAnimation_mc:AnimationDisplayObject;			public var downAnimation_mc:MovieClip;			//public var leftAnimation_mc:AnimationDisplayObject;			public var deathAnimation_mc:MovieClip;			public var hitarea_mc:MovieClip;			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function WeaponDisplayObject( contentClip:MovieClip=null )				{					//TODO:					//	It might be better to decouple the class from the movie clip library					//	That way, we can just use the same weapon clip library for all different weapon classes (WeaponDisplayObject, ProjectileWeaponDisplayObject)										//_content = contentClip;					//upAnimation_mc = _content.upAnimation_mc;					//downAnimation_mc = _content.downAnimation_mc;									}							/** set/get attackingGameObject			  *	---------------------------------------------------------------------------- */				override public function set attackingGameObject( a:AbstractGameObject ):void				{					//_attackingGameObject = UtilFunctions.clone(a) as Weapon;					super.attackingGameObject = a;										//tempName_mc.textField = MovieClip(tempName_mc).label_txt;					//tempName_mc.fontName = "Rockwell";					//tempName_mc.embedFonts = true;										//tempName_mc.setText( _attackingGameObject.name );										_upAnimationClip.animationObject = Weapon(_attackingGameObject).upAnimationObject;					_upAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Weapon(_attackingGameObject).upAnimationObject.cacheId ).bitmapData;										_downAnimationClip.animationObject = Weapon(_attackingGameObject).downAnimationObject;					_downAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Weapon(_attackingGameObject).downAnimationObject.cacheId ).bitmapData;										if( Weapon(_attackingGameObject).deathAnimationObject != null )					{						_deathAnimationClip = new AnimationDisplayObject();						_deathAnimationClip.contentClip = deathAnimation_mc;						_deathAnimationClip.init();						//_deathAnimationClip.addEventListener( BoogaEvent.ON_ANIMATION_ENDS, handleDeathAnimationEnded, false, 0, true );						//_deathAnimationClip.addEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired, false, 0, true );						_deathAnimationClip.onAnimationEnded.add( handleDeathAnimationEnded );						_deathAnimationClip.onSoundEventFired.add( handleSoundEventFired );						_deathAnimationClip.animationObject = Weapon(_attackingGameObject).deathAnimationObject;						_deathAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Weapon(_attackingGameObject).deathAnimationObject.cacheId ).bitmapData;												if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_WEAPON_SMOOTHING) )						{							_deathAnimationClip.smoothing = false;						}					}										hitarea_mc.width = _attackingGameObject.rollOverWidth;					hitarea_mc.height = _attackingGameObject.rollOverHeight;					hitarea_mc.x = 0;					hitarea_mc.y = -hitarea_mc.height*0.5 + 10;				}							/** set/get currentTile			  *	---------------------------------------------------------------------------- */				override public function set currentTile( g:GameboardTile ):void				{					_currentTile = g;									}								//public function set canAttackFlyer( b:Boolean ):void { _canAttackFlyer = b; }				//public function get canAttackFlyer():Boolean { return _canAttackFlyer; }								//public function set canAttackDigger( b:Boolean ):void { _canAttackDigger = b; }				//public function get canAttackDigger():Boolean { return _canAttackDigger; }							/** set currentIndexInPath			  *	---------------------------------------------------------------------------- *			  *	For enemy, the directions they are facing is the other way since they are			  *	travelling from the end of the path.			  *	---------------------------------------------------------------------------- */				override public function set currentIndexInPath( i:int ):void				{					_currentIndexInPath = i;										//trace( _path );										//TODO:					//	There might be a bug with the initial direction, keep an eye on this!!!!					if( _currentIndexInPath == 0 )						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], null );					//else if( _currentIndexInPath == _pathLength-1 )						//_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], _path[_currentIndexInPath-1] );					else						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], _path[_currentIndexInPath-1] );										//if( _direction != _oldDirection )					//{						//showAnimation();					//}										//trace( "_direction: "+_direction );					//trace( "oneDirectionOnly: "+_attackingGameObject.oneDirectionOnly );										if( _attackingGameObject.oneDirectionOnly )					{						_upAnimationClip.initCanvas( false );						//_upAnimationClip.startAnimation( true );						_upAnimationClip.showAnimation( 0 );						_upAnimationClip.contentClip.visible = true;						_currentAnimationDisplayObject = _upAnimationClip;					}					else					{						//showAnimation( _direction );						switch( direction )						{							case GameLevelUtil.DIRECTION_UP:								_upAnimationClip.initCanvas( false );								_currentAnimationDisplayObject = _upAnimationClip;								break;														case GameLevelUtil.DIRECTION_RIGHT:								_upAnimationClip.initCanvas( true );								_currentAnimationDisplayObject = _upAnimationClip;								break;														case GameLevelUtil.DIRECTION_DOWN:								_downAnimationClip.initCanvas( false );								_currentAnimationDisplayObject = _downAnimationClip;								break;														case GameLevelUtil.DIRECTION_LEFT:								_downAnimationClip.initCanvas( true );								_currentAnimationDisplayObject = _downAnimationClip;								break;						}												_currentAnimationDisplayObject.contentClip.visible = true;						_currentAnimationDisplayObject.showAnimation(0);					}										if( _oldDirection < 0 )						_oldDirection = _direction;									}							/** set/get contentClip			  *	---------------------------------------------------------------------------- */				override public function set contentClip( m:MovieClip ):void				{					_contentClip = m;					//_contentClip.mouseChildren = false;					_contentClip.mouseEnabled = false;					//enableInteraction();										upAnimation_mc = _contentClip.upAnimation_mc;					downAnimation_mc = _contentClip.downAnimation_mc;					deathAnimation_mc = _contentClip.deathAnimation_mc;					hitarea_mc = _contentClip.hitarea_mc;										upAnimation_mc.visible = false;					downAnimation_mc.visible = false;					deathAnimation_mc.visible = false;										_upAnimationClip = new AnimationDisplayObject();					_upAnimationClip.contentClip = upAnimation_mc;					_upAnimationClip.init();					//_upAnimationClip.addEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired, false, 0, true );					_upAnimationClip.onSoundEventFired.add( handleSoundEventFired );					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_WEAPON_SMOOTHING) )					{						_upAnimationClip.smoothing = false;					}										_downAnimationClip = new AnimationDisplayObject();					_downAnimationClip.contentClip = downAnimation_mc;					_downAnimationClip.init();					//_downAnimationClip.addEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired, false, 0, true );					_downAnimationClip.onSoundEventFired.add( handleSoundEventFired );					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_WEAPON_SMOOTHING) )					{						_downAnimationClip.smoothing = false;					}									}								//public function get hitByLaserEnemies():Vector.<EnemyDisplayObject> { return _hitByLaserEnemies; }								public function set shield( s:ShieldWeaponDisplayObject ):void				{					_shield = s;					//_shield.addEventListener( GameLevelEvent.DIE, handleShieldDied, false, 0, true );					_shield.onDied.add( handleShieldDied );				}				public function get shield():ShieldWeaponDisplayObject { return _shield; }								public function set addition( a:AdditionWeaponDisplayObject ):void				{					_addition = a;				}				public function get addition():AdditionWeaponDisplayObject { return _addition; }								public function set additionalClipOnGameboard( a:AnimationDisplayObject ):void { _additionalClipOnGameboard = a; }				public function get additionalClipOnGameboard():AnimationDisplayObject { return _additionalClipOnGameboard; }								public function get currentAnimationDisplayObject():AnimationDisplayObject { return _currentAnimationDisplayObject; }								public function enableInteraction():void				{					hitarea_mc.visible = true;					hitarea_mc.addEventListener( MouseEvent.ROLL_OVER, handleRolledOver, false, 0, true );					hitarea_mc.addEventListener( MouseEvent.ROLL_OUT, handleRolledOut, false, 0, true );				}								public function disableInteraction():void				{					hitarea_mc.visible = false;					hitarea_mc.removeEventListener( MouseEvent.ROLL_OVER, handleRolledOver );					hitarea_mc.removeEventListener( MouseEvent.ROLL_OUT, handleRolledOut );				}								protected function handleRolledOver( event:MouseEvent ):void				{					//trace( this+"handleRolledOver();" );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_WEAPON_ROLLED_OVER) );					onRolledOver.dispatch( this );				}								protected function handleRolledOut( event:MouseEvent ):void				{					//trace( this+"handleRolledOut();" );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.ON_WEAPON_ROLLED_OUT) );					onRolledOut.dispatch( this );				}							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					//trace( "WeaponDisplayObject: init();" );										super.init();										_debug = true;										//_hitByLaserEnemies = new Vector.<EnemyDisplayObject>;										//_enemiesAttacked = new Array();					//_tilesWatching = new Array();					_attacking = false;					_ignoredByEnemy = false;										_toStringOutput = "";										onRemovedFromGame = new Signal( WeaponDisplayObject );					onRolledOver = new Signal( WeaponDisplayObject );					onRolledOut = new Signal( WeaponDisplayObject );				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					super.pause();										if( _attacking )					{						_attackTimer.pause();					}										_currentAnimationDisplayObject.pause();				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					super.unpause();										if( _attacking )					{						_attackTimer.unpause();					}										_currentAnimationDisplayObject.unpause();				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "kill();" );										_needToBeUpdatedOnEnterFrame = false;										disableInteraction();										if( _shield != null )					{						//_shield.removeEventListener( GameLevelEvent.DIE, handleShieldDied );						_shield.onDied.remove( handleShieldDied );												if( _shield.alive )							_shield.die();												_shield = null;					}										if( _addition != null )					{						//trace( "_addition.currentAnimationDisplayObject: "+_addition.currentAnimationDisplayObject );						if( _addition.alive )							_addition.die();						_addition = null;					}										_additionalClipOnGameboard = null;										_currentAnimationDisplayObject = null;										_upAnimationClip.stopAnimation();					//_upAnimationClip.removeEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired );					_upAnimationClip.onSoundEventFired.remove( handleSoundEventFired );					_upAnimationClip.kill();										_downAnimationClip.stopAnimation();					//_downAnimationClip.removeEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired );					_downAnimationClip.onSoundEventFired.remove( handleSoundEventFired );					_downAnimationClip.kill();										if( Weapon(_attackingGameObject).deathAnimationObject != null )					{												_deathAnimationClip.stopAnimation();						//_deathAnimationClip.removeEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired );						//_deathAnimationClip.removeEventListener( BoogaEvent.ON_ANIMATION_ENDS, handleDeathAnimationEnded );						_deathAnimationClip.onSoundEventFired.remove( handleSoundEventFired );						_deathAnimationClip.onAnimationEnded.remove( handleDeathAnimationEnded );						_deathAnimationClip.kill();					}										//VectorUtil.removeAll( _hitByLaserEnemies );										_contentClip = null;										onRemovedFromGame = null;					onRolledOver = null;					onRolledOut = null;										super.kill();									}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				override public function updateOnEnterFrame():void				{					if( _needToBeUpdatedOnEnterFrame )					{						if( _currentAnimationDisplayObject != null )							_currentAnimationDisplayObject.showNextAnimation();					}				}							/** die			  *	---------------------------------------------------------------------------- */				override public function die():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "die();" );										if( _alive )					{						super.die();												if( _shield != null )						{							//_shield.removeEventListener( GameLevelEvent.DIE, handleShieldDied );							_shield.onDied.remove( handleShieldDied );							_shield.die();							_shield = null;						}												if( _addition != null )						{							_addition.die();							_addition = null;						}												_alive = false;												stopAttacking();												_currentAnimationDisplayObject.stopAnimation();						_currentAnimationDisplayObject.contentClip.visible = false;												if( Weapon(_attackingGameObject).deathAnimationObject != null )						{							//trace( 'play death animation' );							_deathAnimationClip.initCanvas();							_deathAnimationClip.startAnimation(false, 0);							_deathAnimationClip.contentClip.visible = true;							_currentAnimationDisplayObject = _deathAnimationClip;						}						else						{							//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );							onRemovedFromGame.dispatch( this );						}					}										//trace( "_tilesWatching: "+_tilesWatching );										//var i:uint;					/*					for( var i:uint=0; i<_tilesWatching.length; ++i )					{						GameboardTile(_tilesWatching[i]).removeWeaponWatching( this );						_tilesWatching[i] = null;					}					_tilesWatching = new Array();					*/					/*					for( i=0; i<_enemiesAttacked.length; ++i )					{						_enemiesAttacked[i].removeEventListener( "onDie", handleEnemyDied );						_enemiesAttacked[i] = null;					}					_enemiesAttacked = new Array();					*/					//kill();									}								/** hit			  *	---------------------------------------------------------------------------- *			  *	Reduces the health of the game object. When the health reaches 0, the object			  *	dies.			  *	---------------------------------------------------------------------------- */				override public function hit( gameObject:AbstractGameObject, power:Number, oneHitKill:Boolean=false ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "GameLevelAttackingDisplayObject", "hit("+gameObject.power+");" );										if( _alive )					{						var randomIndex:int;												if( _attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_STONE_INDEX ) )						{							/*							randomIndex = int(Math.random()*2);							if( randomIndex == 0 )								SoundEffectPlayer.getInstance().playLibrarySound( "sfx_weapon_destroyed_stone_1.wav", false, "sfx_weapon_destroyed_stone_1.wav", "sfx_weapon_destroyed_stone_1.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );							else if( randomIndex == 1 )								SoundEffectPlayer.getInstance().playLibrarySound( "sfx_weapon_destroyed_stone_2.wav", false, "sfx_weapon_destroyed_stone_2.wav", "sfx_weapon_destroyed_stone_2.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );							*/														SoundEffectPlayer.getInstance().playLibrarySound( "sfx_weapon_hit_stone_1.wav", false, "sfx_weapon_hit_stone_1.wav", "sfx_weapon_hit_stone_1.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );						}						else if( _attackingGameObject.hasAttackProperty( GameLevelUtil.ATTACK_PROPERTY_WOOD_INDEX ) )						{							randomIndex = int(Math.random()*2);							if( randomIndex == 0 )								SoundEffectPlayer.getInstance().playLibrarySound( "sfx_wooden_weapon_hit_1.wav", false, "sfx_wooden_weapon_hit_1.wav", "sfx_wooden_weapon_hit_1.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );							else if( randomIndex == 1 )								SoundEffectPlayer.getInstance().playLibrarySound( "sfx_wooden_weapon_hit_2.wav", false, "sfx_wooden_weapon_hit_2.wav", "sfx_wooden_weapon_hit_2.wav", SoundEffectPlayer.SOUND_PLAYER_SFX );														}												if( _shield != null )						{							_shield.hit( gameObject, power, oneHitKill );						}						else						{							super.hit( gameObject, power, oneHitKill );						}					}				}							/** placedOnBoard			  *	---------------------------------------------------------------------------- *			  *	Called when WeaponDisplayObject gets added to the stage.			  *	Each weapon type is going to do different things ( either going to just stay			  *	static or actually going to start animating ).			  *	---------------------------------------------------------------------------- */				public function placedOnBoard():void				{					_currentAnimationDisplayObject.startAnimation( true );				}							/** render			  *	---------------------------------------------------------------------------- 				override public function render():void				{					if( this._positionIn2D != null && _isometricMatrix != null )					{						//trace( "this._inIsometricView: "+this._inIsometricView );						//trace( "this._positionIn2D: "+this._positionIn2D );												if( this._inIsometricView )						{							_contentClip.x = Math.round((this._positionIn2D.x * _isometricMatrix[0][0]) + (this._positionIn2D.y * _isometricMatrix[1][0]));							_contentClip.y = Math.round((this._positionIn2D.x * _isometricMatrix[0][1]) + (this._positionIn2D.y * _isometricMatrix[1][1])) + (_altitude * _isometricMatrix[2][1]);						}						else						{							_contentClip.x = this._positionIn2D.x;							_contentClip.y = this._positionIn2D.y;						}					}				}*/							/** attackTargets			  *	---------------------------------------------------------------------------- *			  *	See if this object can attack one of the targets that are given.			  *	It always attacks the closest target.			  *	---------------------------------------------------------------------------- 				override public function attackTargets( targets:Vector.<GameLevelAttackingDisplayObject> ):GameLevelAttackingDisplayObject				{					//trace( "_attacking: "+_attacking );										//var tempAttackedTarget = super.attackTargets( targets );										return super.attackTargets( targets );				}*/							/** startAttackAnimation			  *	---------------------------------------------------------------------------- *			  *	Shows the attack animation of the displayObject. You can also do anything			  *	extra when it attacks. Separating this from attackTargets function so that			  *	extended classes can just override this function instead of overriding that 			  *	function.			  *	---------------------------------------------------------------------------- */				override public function startAttackAnimation():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "startAttackAnimation();" );										//Not sure if this is the better way of doing it like this					if( _attackedTarget != null && _attackingGameObject.power > 0 )					{						if( _attackTimer == null )						{							_attackTimer = new CustomTimer( 1000 * _attackingGameObject.rateOfFire );							//_attackTimer.addEventListener( TimerEvent.TIMER, handleAttackTimerFired, false, 0, true );							_attackTimer.onTimerFired.add( handleAttackTimerFired );						}												if( _speedUp )							_attackTimer.multiplier = .5;						else							_attackTimer.multiplier = 1;												//trace( "_attackTimer.delay: "+_attackTimer.delay );												_attacking = true;						_attackTimer.start();												if( _attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_BLOCKING_INDEX) )						{							handleAnimationEventFired();						}						else						{							showAnimation( _direction );						}					}				}											/** handleAttackTimerFired			  *	---------------------------------------------------------------------------- 				override protected function handleAttackTimerFired( timer:CustomTimer ):void				{					super.handleAttackTimerFired(timer);										//trace( "_attackTimer.delay: "+_attackTimer.delay );				}*/							/** canAttackTarget			  *	---------------------------------------------------------------------------- *			  *	Check to see if this object can attack the target. Override this function			  *	in the attacking object as the requirement is different for reach one.			  *	---------------------------------------------------------------------------- */				override protected function canAttackTarget( target:GameLevelDisplayObject ):Boolean				{					//if( (target as GameLevelAtt.attackingGameObject.hasAttackProperty										if( target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_GHOST_INDEX) && target.ghosting )					{						if( !_attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ENCHANTED_INDEX) )							return false;					}										var range:Number = 45 + (_attackingGameObject.range * 90);						range = range * range;										var distance:Number = (_positionIn2D.x - target.positionIn2D.x) * (_positionIn2D.x - target.positionIn2D.x);						distance += (_positionIn2D.y - target.positionIn2D.y) * (_positionIn2D.y - target.positionIn2D.y);										//trace( "target positionIn2D: "+target.positionIn2D );					//trace( "weapon positionIn2D: "+_positionIn2D );					//trace( "distance: "+distance );					//trace( "range: "+range );										if( distance > range )						return false;										if( target is GameLevelAttackingDisplayObject )					{						if( GameLevelAttackingDisplayObject(target).attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FLYER_INDEX) )						{							return _attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_FLYER_INDEX);						}					}					//trace( '_attackingGameObjectElementCompatibility: '+_attackingGameObjectElementCompatibility );					if( _attackingGameObjectElementCompatibility != null && target.attackingGameObject.hasAttackProperty(_attackingGameObjectElementCompatibility.weakAgainst) )					{						//trace( 'weapons do not work on these type of enemies' );						return false;					}										return true;				}							/** showAnimation			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				protected function showAnimation( direction:int ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( toString(), "showAnimation("+direction+");" );										if( _attacking )					{						if( _attackingGameObject.oneDirectionOnly )						{							_currentAnimationDisplayObject.startAnimation( false, 0 );						}						else						{							switch( direction )							{								case GameLevelUtil.DIRECTION_UP:									_upAnimationClip.initCanvas( false );									//_upAnimationClip.startAnimation( false, 0 );									_currentAnimationDisplayObject = _upAnimationClip;									break;																case GameLevelUtil.DIRECTION_RIGHT:									_upAnimationClip.initCanvas( true );									//_upAnimationClip.startAnimation( false, 0 );									_currentAnimationDisplayObject = _upAnimationClip;									break;																case GameLevelUtil.DIRECTION_DOWN:									_downAnimationClip.initCanvas( false );									//_downAnimationClip.startAnimation( false, 0 );									_currentAnimationDisplayObject = _downAnimationClip;									break;																case GameLevelUtil.DIRECTION_LEFT:									_downAnimationClip.initCanvas( true );									//_downAnimationClip.startAnimation( false, 0 );									_currentAnimationDisplayObject = _downAnimationClip;									break;							}														_currentAnimationDisplayObject.contentClip.visible = true;							_currentAnimationDisplayObject.startAnimation( false, 0 );						}												//trace( "is animation looping ? "+_currentAnimationDisplayObject.looping );					}					else if( !_alive )					{											}					else					{						switch( direction )						{							case GameLevelUtil.DIRECTION_UP:								_upAnimationClip.initCanvas( false );								_currentAnimationDisplayObject = _upAnimationClip;								break;														case GameLevelUtil.DIRECTION_RIGHT:								_upAnimationClip.initCanvas( true );								_currentAnimationDisplayObject = _upAnimationClip;								break;														case GameLevelUtil.DIRECTION_DOWN:								_downAnimationClip.initCanvas( false );								_currentAnimationDisplayObject = _downAnimationClip;								break;														case GameLevelUtil.DIRECTION_LEFT:								_downAnimationClip.initCanvas( true );								_currentAnimationDisplayObject = _downAnimationClip;								break;						}					}										_currentAnimationDisplayObject.contentClip.visible = true;				}							/** handleAnimationEventFired			  *	---------------------------------------------------------------------------- */				protected function handleAnimationEventFired():void				{					//trace( "handleAnimationEventFired();" );										//trace( "_currentAnimationDisplayObject.running: "+_currentAnimationDisplayObject.running );					//trace( "_currentAnimationDisplayObject.looping: "+_currentAnimationDisplayObject.looping );					//trace( "_alive: "+_alive );					//trace( "_attackedTarget: "+_attackedTarget );										if( _alive && _attackedTarget != null )					{						//TODO:						//	Depending on the type of weapons, it will either 						//_attackedTarget.hit( _attackingGameObject, _attackingGameObject.power );						//_attackedTarget = null;						if( _attackingGameObject.power > 0 )						{							_attackedTarget.hit( _attackingGameObject, _attackingGameObject.power );						}												_attackedTarget = null;					}				}							/** handleSoundEventFired			  *	---------------------------------------------------------------------------- */				protected function handleSoundEventFired( soundDataId:int ):void				{					//trace( "handleSoundEventFired();" );					//trace( "sound id that should play "+event.customParameters.soundDataId );										var soundData:SoundData = SoundsIndex.getInstance().getSoundById(soundDataId);					//trace( "play sound: "+soundData.soundId );					//trace( "sound volume: "+soundData.volume );					//trace( SoundEffectPlayer.getInstance().getVolume( soundData.soundId ) );					SoundEffectPlayer.getInstance().playLibrarySound( soundData.soundId, false, _contentClip.name, soundData.soundId );					soundData = null;				}							/** handleDeathAnimationEnded			  *	---------------------------------------------------------------------------- */				//protected function handleDeathAnimationEnded( event:BoogaEvent ):void				protected function handleDeathAnimationEnded( animationDisplayObject:AnimationDisplayObject ):void				{					//trace( 'handleDeathAnimationEnded();' );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );					onRemovedFromGame.dispatch( this );				}							/** handleShieldDied			  *	---------------------------------------------------------------------------- */				protected function handleShieldDied( shield:ShieldWeaponDisplayObject ):void				{					//trace( "handleShieldDied();" );										//_shield.removeEventListener( GameLevelEvent.DIE, handleShieldDied );					_shield.onDied.remove( handleShieldDied );					_shield = null;				}							/** startAttacking			  *	---------------------------------------------------------------------------- */				public function startAttacking():void				{					// check if the enemies are actually in range					/*					if( !_attacking && _enemiesAttacked.length > 0 )					{						if( _attackTimer == null )						{							_attackTimer = new CustomTimer( 1000 * _attackingGameObject.rateOfFire );							_attackTimer.addEventListener( TimerEvent.TIMER, handleAttackTimerFired, false, 0, true );						}												EnemyDisplayObject(_enemiesAttacked[0]).hit( _attackingGameObject, _attackingGameObject.power );												_attacking = true;												_attackTimer.start();					}					*/				}							/** speedUpByWarriorGod			  *	---------------------------------------------------------------------------- */				public function speedUpByWarriorGod():void				{					//trace( "speedUpByWarriorGod();" );										if( !_speedUp )					{						_speedUp = true;												if( _attackTimer != null )						{							_attackTimer.multiplier = .5;							//trace( "_attackTimer.delay: "+_attackTimer.delay );						}					}				}							/** slowDownFromWarriorGod			  *	---------------------------------------------------------------------------- */				public function slowDownFromWarriorGod():void				{					//trace( "slowDownFromWarriorGod();" );										if( _speedUp )					{						_speedUp = false;												if( _attackTimer != null )						{							_attackTimer.multiplier = 1;							//trace( "_attackTimer.delay: "+_attackTimer.delay );						}					}				}							/** isHitByLaserEnemy			  *	---------------------------------------------------------------------------- *			  *	Checks if the EnemyDisplayObject has hit this weapon object with the laser yet.			  *	---------------------------------------------------------------------------- 				public function isHitByLaserEnemy( enemyDO:EnemyDisplayObject ):Boolean				{					if( VectorUtil.find( _hitByLaserEnemies, enemyDO ) == null )					{						_hitByLaserEnemies.push( enemyDO );						return false;					}										return true;				}*/							/** resetHitByLaserEnemy			  *	---------------------------------------------------------------------------- *			  *	Removes all laser enemies that hit this weapon object.			  *	---------------------------------------------------------------------------- 				public function resetHitByLaserEnemy():void				{					VectorUtil.removeAll( _hitByLaserEnemies );				}*/							/** toString			  *	---------------------------------------------------------------------------- */				override public function toString():String				{					if( _toStringOutput == "" )					{						//trace( "name: "+StringsIndex.getInstance().getString(String(_attackingGameObject.name)) );						_toStringOutput = StringsIndex.getInstance().getString(String(_attackingGameObject.name)).replace(/[\s*]/g, "_")+"_"+_currentTile.row+"_"+_currentTile.column;					}										return _toStringOutput;				}								override public function clone():*				{					var clonedObject:WeaponDisplayObject = UtilFunctions.clone(this) as WeaponDisplayObject;						clonedObject.attackingGameObject = _attackingGameObject;										return clonedObject;				}		}			}