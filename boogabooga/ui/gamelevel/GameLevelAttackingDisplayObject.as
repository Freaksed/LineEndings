/** GameLevelAttackingDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Enemy class.  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.events.Event;		import flash.events.FullScreenEvent;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.events.TimerEvent;		import flash.utils.getDefinitionByName;		import flash.utils.getQualifiedClassName;				import com.greensock.TweenLite;		import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.UtilFunctions;		import org.osflash.signals.Signal;				//import com.gamelevel.data.*;		import com.boogabooga.data.SettingsIndex;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.GameLevelDataIndex;		import com.boogabooga.data.gamelevel.Gate;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.utils.GameLevelUtil;		import com.boogabooga.utils.ElementCompatibility;				public dynamic class GameLevelAttackingDisplayObject extends GameLevelDisplayObject		{			protected var _attackingGameObject:AbstractGameObject; // This can be Weapon or Enemy			protected var _attackingGameObjectElementCompatibility:ElementCompatibility;			protected var _path:Vector.<GameboardTile>;			protected var _pathLength:uint;			protected var _pathIndex:int;			protected var _currentIndexInPath:int;			protected var _currentTile:GameboardTile;			protected var _attacking:Boolean;			protected var _attackTimer:CustomTimer;			protected var _attackedTarget:GameLevelAttackingDisplayObject;						//protected var _targets:Array;						protected var _direction:int;			protected var _alive:Boolean;			protected var _ignoredByEnemy:Boolean;						protected var _poisoned:Boolean;			protected var _slowedDown:Boolean;			protected var _poisonedTimer:CustomTimer;			protected var _slowedDownTimer:CustomTimer;			protected var _hitColorChangeTimer:CustomTimer;						//protected var _poisonedColorTransform:ColorTransform;			//protected var _slowedDownColorTransform:ColorTransform;			protected var _originalColorTransform:ColorTransform;						public var onHit:Signal;			public var onDied:Signal;			public var onAttackTimerFired:Signal;						/*			poisoned colorTransform			(redMultiplier=0.5, greenMultiplier=0.5, blueMultiplier=0.5, alphaMultiplier=1, redOffset=51, greenOffset=0, blueOffset=77, alphaOffset=0)						slowed down colorTransform			(redMultiplier=0.5, greenMultiplier=0.5, blueMultiplier=0.5, alphaMultiplier=1, redOffset=0, greenOffset=77, blueOffset=128, alphaOffset=0)			*/						/**	Stage Instances **/			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function GameLevelAttackingDisplayObject()				{					//init();				}							/** set/get attackingGameObject			  *	---------------------------------------------------------------------------- */				public function set attackingGameObject( a:AbstractGameObject ):void				{					if( a is Weapon )					{						_attackingGameObject = UtilFunctions.clone(a) as Weapon;					}					else if( a is Enemy )					{						_attackingGameObject = UtilFunctions.clone(a) as Enemy;					}					else if( a is Gate )					{						_attackingGameObject = UtilFunctions.clone(a) as Gate;					}										_attackingGameObjectElementCompatibility = GameLevelUtil.checkForElement( _attackingGameObject );					/*					if( _attackingGameObjectElementCompatibility != null )					{						trace( '_attackingGameObjectElementCompatibility.element: '+_attackingGameObjectElementCompatibility.element );						trace( '_attackingGameObjectElementCompatibility.against: '+_attackingGameObjectElementCompatibility.against );						trace( '_attackingGameObjectElementCompatibility.strongAgainst: '+_attackingGameObjectElementCompatibility.strongAgainst );					}					*/					//trace( "_attackingGameObject: "+_attackingGameObject );					//trace( "_attackingGameObject.power: "+_attackingGameObject.power );					//trace( getQualifiedClassName(a) );				}				public function get attackingGameObject():AbstractGameObject				{					return _attackingGameObject;				}								public function get attackingGameObjectElementCompatibility():ElementCompatibility { return _attackingGameObjectElementCompatibility; }							/** set/get currentTile			  *	---------------------------------------------------------------------------- */				public function set currentTile( g:GameboardTile ):void { _currentTile = g; }				public function get currentTile():GameboardTile { return _currentTile; }							/** set/get path			  *	---------------------------------------------------------------------------- */				public function set path( p:Vector.<GameboardTile> ):void				{					if( p == null )						return;										_path = p;					_pathLength = _path.length;				}				public function get path():Vector.<GameboardTile> { return _path; }								public function set pathIndex( i:int ):void { _pathIndex = i; }				public function get pathIndex():int { return _pathIndex; }							/** set/get currentIndexInPath			  *	---------------------------------------------------------------------------- */				public function set currentIndexInPath( i:int ):void				{					_currentIndexInPath = i;										//trace( "_currentIndexInPath: "+_currentIndexInPath );					//trace( "currentTile: "+_path[_currentIndexInPath] );										if( _currentIndexInPath == 0 )						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], null, false );					else						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], _path[_currentIndexInPath-1] );				}				public function get currentIndexInPath():int { return _currentIndexInPath; }							/** get attacking			  *	---------------------------------------------------------------------------- */				public function get attacking():Boolean { return _attacking; }								public function get direction():int { return _direction; }								public function get alive():Boolean { return _alive; }								public function set ignoredByEnemy( b:Boolean ):void { _ignoredByEnemy = b; }				public function get ignoredByEnemy():Boolean { return _ignoredByEnemy; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_needToBeUpdatedOnEnterFrame = true;					_attacking = false;					_alive = true;					_ignoredByEnemy = false;										_poisoned = false;					_slowedDown = false;										//_poisonedColorTransform = new ColorTransform(0.5, 0.5, 0.5, 1, 51, 0, 77, 0);					//_slowedDownColorTransform = new ColorTransform(0.5, 0.5, 0.5, 1, 0, 77, 128, 0);					_originalColorTransform = new ColorTransform();// _contentClip.transform.colorTransform;										//_targets = new Array();										onHit = new Signal();					onDied = new Signal();					onAttackTimerFired = new Signal();				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					if( _attacking )					{						_attackTimer.pause();					}										if( _poisoned )					{						_poisonedTimer.pause();					}										if( _slowedDown )					{						_slowedDownTimer.pause();					}										if( _hitColorChangeTimer && _hitColorChangeTimer.isRunning )					{						_hitColorChangeTimer.pause();					}				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					if( _attacking )					{						_attackTimer.unpause();					}										if( _poisoned )					{						_poisonedTimer.unpause();					}										if( _slowedDown )					{						_slowedDownTimer.unpause();					}										if( _hitColorChangeTimer && _hitColorChangeTimer.isRunning )					{						_hitColorChangeTimer.unpause();					}				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					_needToBeUpdatedOnEnterFrame = false;										if( _attacking )						stopAttacking();										if( _attackTimer != null )					{						//_attackTimer.removeEventListener( TimerEvent.TIMER, handleAttackTimerFired );						_attackTimer.onTimerFired.remove( handleAttackTimerFired );						_attackTimer.kill();						_attackTimer = null;					}										if( _poisonedTimer != null )					{						//_poisonedTimer.removeEventListener( TimerEvent.TIMER, handlePoisonedTimerFired );						//_poisonedTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, handlePoisonedTimerCompleted );						_poisonedTimer.onTimerFired.remove( handlePoisonedTimerFired );						_poisonedTimer.onTimerCompleted.remove( handlePoisonedTimerCompleted );						_poisonedTimer.kill();						_poisonedTimer = null;					}										if( _slowedDownTimer != null )					{						//_slowedDownTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, handleSlowedDownTimerCompleted );						_slowedDownTimer.onTimerCompleted.remove( handleSlowedDownTimerCompleted );						_slowedDownTimer.kill();						_slowedDownTimer = null;					}										if( _hitColorChangeTimer != null )					{						_hitColorChangeTimer.onTimerCompleted.remove( stopHitColorChangeTimer );						_hitColorChangeTimer.kill();						_hitColorChangeTimer = null;					}										//ArrayUtil.removeAll( _path );					_attackingGameObject = null;					_currentTile = null;										//super.kill();										onHit = null;					onDied = null;					onAttackTimerFired = null;				}							/** hit			  *	---------------------------------------------------------------------------- *			  *	Reduces the health of the game object. When the health reaches 0, the object			  *	dies.			  *	---------------------------------------------------------------------------- */				public function hit( gameObject:AbstractGameObject, power:Number, oneHitKill:Boolean=false ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameLevelAttackingDisplayObject", "hit("+gameObject.power+");" );										//trace( gameObject.attackProperties );										if( _alive )					{						if( oneHitKill )						{							//dispatchEvent( new GameLevelEvent(GameLevelEvent.HIT, {power:_attackingGameObject.health}) );							onHit.dispatch( this );														_attackingGameObject.health = 0;							die();						}						else						{							_attackingGameObject.health -= power;							//trace( _attackingGameObject+" health: "+_attackingGameObject.health );														//dispatchEvent( new GameLevelEvent(GameLevelEvent.HIT, {power:power}) );							onHit.dispatch( this );														if( _attackingGameObject.health <= 0 )							{								die();							}							else							{								if( gameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_POISON_INDEX) )								{									//trace( "POISONED !!!" );									poison( gameObject.additionalAttackValue*1000 );								}								else if( gameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ICE_INDEX) )								{									//trace( "SLOWED DOWN !!!" );									slowDown( gameObject.additionalAttackValue*1000 );								}								else								{									//startHitColorChangeTimer();								}								startHitColorChangeTimer();							}						}					}				}							/** recover			  *	---------------------------------------------------------------------------- *			  *	Recovers the health of the game object. It can only add health up to the 			  *	maximum health, it does not go over.			  *	---------------------------------------------------------------------------- */				public function recover( gameObject:AbstractGameObject ):void				{					if( _alive )					{						//_attackingGameObject.health += gameObject.power;												if( _attackingGameObject.health + gameObject.power > _attackingGameObject.maxHealth )							_attackingGameObject.health = _attackingGameObject.maxHealth;						else							_attackingGameObject.health += gameObject.power;					}				}							/** die			  *	---------------------------------------------------------------------------- */				public function die():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "GameLevelAttackingDisplayObject", "die();" );										stopHitColorChangeTimer();										_alive = false;										if( _attacking )					{						_attackTimer.stop();						_attacking = false;					}										if( _poisoned )					{						_poisonedTimer.stop();						_poisoned = false;					}										if( _slowedDown )					{						_slowedDownTimer.stop();						_slowedDown = false;					}										//dispatchEvent( new GameLevelEvent(GameLevelEvent.DIE) );					onDied.dispatch( this );				}							/** startHitColorChangeTimer			  *	---------------------------------------------------------------------------- */				public function startHitColorChangeTimer():void				{					if( _hitColorChangeTimer == null )					{						_hitColorChangeTimer = new CustomTimer(200, 1);						//_hitColorChangeTimer.addEventListener( TimerEvent.TIMER_COMPLETE, stopHitColorChangeTimer, false, 0, true );						_hitColorChangeTimer.onTimerCompleted.add( stopHitColorChangeTimer );					}										stopHitColorChangeTimer();										if( _attackingGameObject.health < (_attackingGameObject.maxHealth/3) )					{						//red						_contentClip.transform.colorTransform = GameLevelDisplayObject.redColorTransform;						/*						TweenLite.to( _contentClip, .1, {colorTransform:{redMultiplier:GameLevelDisplayObject.redColorTransform.redMultiplier, greenMultiplier:GameLevelDisplayObject.redColorTransform.greenMultiplier, 															blueMultiplier:GameLevelDisplayObject.redColorTransform.blueMultiplier, alphaMultiplier:GameLevelDisplayObject.redColorTransform.alphaMultiplier,									 						redOffset:GameLevelDisplayObject.redColorTransform.redOffset, greenOffset:GameLevelDisplayObject.redColorTransform.greenOffset, 															blueOffset:GameLevelDisplayObject.redColorTransform.blueOffset, alphaOffset:GameLevelDisplayObject.redColorTransform.alphaOffset}, overwrite:2} );						*/					}					else if( _attackingGameObject.health < (_attackingGameObject.maxHealth/3 * 2) )					{						//orange						_contentClip.transform.colorTransform = GameLevelDisplayObject.orangeColorTransform;						/*						TweenLite.to( _contentClip, .1, {colorTransform:{redMultiplier:GameLevelDisplayObject.orangeColorTransform.redMultiplier, greenMultiplier:GameLevelDisplayObject.orangeColorTransform.greenMultiplier, 															blueMultiplier:GameLevelDisplayObject.orangeColorTransform.blueMultiplier, alphaMultiplier:GameLevelDisplayObject.orangeColorTransform.alphaMultiplier,									 						redOffset:GameLevelDisplayObject.orangeColorTransform.redOffset, greenOffset:GameLevelDisplayObject.orangeColorTransform.greenOffset, 															blueOffset:GameLevelDisplayObject.orangeColorTransform.blueOffset, alphaOffset:GameLevelDisplayObject.orangeColorTransform.alphaOffset}, overwrite:2} );						*/					}					else					{						//yellow						_contentClip.transform.colorTransform = GameLevelDisplayObject.yellowColorTransform;						/*						TweenLite.to( _contentClip, .1, {colorTransform:{redMultiplier:GameLevelDisplayObject.yellowColorTransform.redMultiplier, greenMultiplier:GameLevelDisplayObject.yellowColorTransform.greenMultiplier, 															blueMultiplier:GameLevelDisplayObject.yellowColorTransform.blueMultiplier, alphaMultiplier:GameLevelDisplayObject.yellowColorTransform.alphaMultiplier,															redOffset:GameLevelDisplayObject.yellowColorTransform.redOffset, greenOffset:GameLevelDisplayObject.yellowColorTransform.greenOffset, 															blueOffset:GameLevelDisplayObject.yellowColorTransform.blueOffset, alphaOffset:GameLevelDisplayObject.yellowColorTransform.alphaOffset}, overwrite:2} );						*/					}										_hitColorChangeTimer.start();				}							/** stopHitColorChangeTimer			  *	---------------------------------------------------------------------------- */				public function stopHitColorChangeTimer( timer:CustomTimer=null ):void				{					if( _hitColorChangeTimer != null )					{						if( _hitColorChangeTimer.isRunning )							_hitColorChangeTimer.stop();												_hitColorChangeTimer.reset();					}															if( _contentClip )					{						if( _poisoned )						{							if( SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_COLOR_HIT_FADE) )							{								TweenLite.to( _contentClip, .2, {colorTransform:{redMultiplier:GameLevelDisplayObject.poisonedColorTransform.redMultiplier, greenMultiplier:GameLevelDisplayObject.poisonedColorTransform.greenMultiplier, 																blueMultiplier:GameLevelDisplayObject.poisonedColorTransform.blueMultiplier, alphaMultiplier:GameLevelDisplayObject.poisonedColorTransform.alphaMultiplier,																redOffset:GameLevelDisplayObject.poisonedColorTransform.redOffset, greenOffset:GameLevelDisplayObject.poisonedColorTransform.greenOffset, 																blueOffset:GameLevelDisplayObject.poisonedColorTransform.blueOffset, alphaOffset:GameLevelDisplayObject.poisonedColorTransform.alphaOffset}, overwrite:2} );							}							else							{								_contentClip.transform.colorTransform = GameLevelDisplayObject.poisonedColorTransform;							}						}						else if( _slowedDown )						{							if( SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_COLOR_HIT_FADE) )							{								TweenLite.to( _contentClip, .2, {colorTransform:{redMultiplier:GameLevelDisplayObject.slowedDownColorTransform.redMultiplier, greenMultiplier:GameLevelDisplayObject.slowedDownColorTransform.greenMultiplier, 																blueMultiplier:GameLevelDisplayObject.slowedDownColorTransform.blueMultiplier, alphaMultiplier:GameLevelDisplayObject.slowedDownColorTransform.alphaMultiplier,																redOffset:GameLevelDisplayObject.slowedDownColorTransform.redOffset, greenOffset:GameLevelDisplayObject.slowedDownColorTransform.greenOffset, 																blueOffset:GameLevelDisplayObject.slowedDownColorTransform.blueOffset, alphaOffset:GameLevelDisplayObject.slowedDownColorTransform.alphaOffset}, overwrite:2} );							}							else							{								_contentClip.transform.colorTransform = GameLevelDisplayObject.slowedDownColorTransform;							}						}						else						{							if( SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_COLOR_HIT_FADE) )							{								TweenLite.to( _contentClip, .2, {colorTransform:{redMultiplier:_originalColorTransform.redMultiplier, greenMultiplier:_originalColorTransform.greenMultiplier, 																blueMultiplier:_originalColorTransform.blueMultiplier, alphaMultiplier:_originalColorTransform.alphaMultiplier,																redOffset:_originalColorTransform.redOffset, greenOffset:_originalColorTransform.greenOffset, 																blueOffset:_originalColorTransform.blueOffset, alphaOffset:_originalColorTransform.alphaOffset}, overwrite:2} );							}							else							{								_contentClip.transform.colorTransform = _originalColorTransform;							}						}					}									}							/** poison			  *	---------------------------------------------------------------------------- */				public function poison( duration:Number ):void				{					stopHitColorChangeTimer();										if( !_poisoned )					{						if( _poisonedTimer == null )						{							_poisonedTimer = new CustomTimer(1000, 20);							//_poisonedTimer.addEventListener( TimerEvent.TIMER, handlePoisonedTimerFired, false, 0, true );							//_poisonedTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handlePoisonedTimerCompleted, false, 0, true );							_poisonedTimer.onTimerFired.add( handlePoisonedTimerFired );							_poisonedTimer.onTimerCompleted.add( handlePoisonedTimerCompleted );						}					}					else					{						_poisonedTimer.stop();						_poisonedTimer.reset();					}										_poisoned = true;					//_poisonedTimer.repeatCount = int(duration / 1000);					_poisonedTimer.start();										//trace( "poison repeatCount: "+_poisonedTimer.repeatCount );										//trace( "before _originalColorTransform: "+_originalColorTransform );					//_contentClip.transform.colorTransform = GameLevelDisplayObject.poisonedColorTransform;										//trace( "_originalColorTransform: "+_originalColorTransform );				}							/** handlePoisonedTimerFired			  *	---------------------------------------------------------------------------- */				protected function handlePoisonedTimerFired( timer:CustomTimer ):void				{					//ConsoleBroadcaster.broadcast( "GameLevelAttackingDisplayObject", "handlePoisonedTimerFired();" );										_attackingGameObject.health -= .1;					startHitColorChangeTimer();										//dispatchEvent( new GameLevelEvent(GameLevelEvent.HIT, {power:.1}) );					onHit.dispatch( this );										if( _attackingGameObject.health <= 0 )					{						die();					}				}							/** handlePoisonedTimerCompleted			  *	---------------------------------------------------------------------------- */				protected function handlePoisonedTimerCompleted( timer:CustomTimer ):void				{					//ConsoleBroadcaster.broadcast( "GameLevelATtackingDisplayObject", "handlePoisonedTimerCompleted();" );										//trace( "_originalColorTransform: "+_originalColorTransform );										_poisonedTimer.reset();					_poisoned = false;					//_contentClip.transform.colorTransform = _originalColorTransform;					stopHitColorChangeTimer();				}							/** slowDown			  *	---------------------------------------------------------------------------- */				public function slowDown( duration:Number ):void				{					stopHitColorChangeTimer();										if( !_slowedDown )					{						if( _slowedDownTimer == null )						{							_slowedDownTimer = new CustomTimer(10000, 1);							//_slowedDownTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleSlowedDownTimerCompleted, false, 0, true );							_slowedDownTimer.onTimerCompleted.add( handleSlowedDownTimerCompleted );						}					}					else					{						_slowedDownTimer.stop();						_slowedDownTimer.reset();					}										_slowedDown = true;					//_slowedDownTimer.delay = duration;					_slowedDownTimer.start();										if( _attackTimer != null )					{						trace( "_attackTimer before slow down: "+_attackTimer.delay );						_attackTimer.multiplier = 2;					}										//_contentClip.transform.colorTransform = GameLevelDisplayObject.slowedDownColorTransform;				}							/** handleSlowedDownTimerCompleted			  *	---------------------------------------------------------------------------- */				protected function handleSlowedDownTimerCompleted( timer:CustomTimer ):void				{					_slowedDownTimer.reset();					_slowedDown = false;										if( _attackTimer != null )					{						_attackTimer.multiplier = 1;						trace( "_attackTimer after slow down runs out: "+_attackTimer.delay );					}										//_contentClip.transform.colorTransform = _originalColorTransform;					stopHitColorChangeTimer();				}							/** attackTargets			  *	---------------------------------------------------------------------------- *			  *	See if this object can attack one of the targets that are given.			  *	It always attacks the closest target.			  *	---------------------------------------------------------------------------- */				public function attackTargets( targets:Vector.<GameLevelAttackingDisplayObject> ):GameLevelAttackingDisplayObject				{					//trace( this.toString()+"   _attacking: "+_attacking );					//trace( this.toString()+"   targets.length: "+targets.length );										if( !_attacking && targets.length > 0 )					{						//trace( this.toString() + " attacking something" );												//TODO:						//	Check if it can attack any of the targets, the one with shortest distance or the first one in the list.						targets = sortTargetsByDistance(targets);												for( var i:uint=0; i<targets.length; ++i )						{							if( canAttackTarget(targets[i]) )							{								//ConsoleBroadcaster.broadcast( "GameLevelAttackingDisplayObject", this.toString()+" attack "+targets[i].toString() );								//targets[i].hit( _attackingGameObject, _attackingGameObject.power );								/*								if( _attackTimer == null )								{									_attackTimer = new CustomTimer( 1000 * _attackingGameObject.rateOfFire );									_attackTimer.addEventListener( TimerEvent.TIMER, handleAttackTimerFired, false, 0, true );								}								*/								_attackedTarget = targets[i];								//_attacking = true;								//_attackTimer.start();								return targets[i];							}						}					}										//_attackedTarget = null;					return null;				}							/** startAttackAnimation			  *	---------------------------------------------------------------------------- *			  *	Shows the attack animation of the displayObject. You can also do anything			  *	extra when it attacks. Separating this from attackTargets function so that			  *	extended classes can just override this function instead of overriding that 			  *	function.			  *	---------------------------------------------------------------------------- */				public function startAttackAnimation():void				{									}							/** canAttackTarget			  *	---------------------------------------------------------------------------- *			  *	Check to see if this object can attack the target. Override this function			  *	in the attacking object as the requirement is different for reach one.			  *	---------------------------------------------------------------------------- */				protected function canAttackTarget( target:GameLevelDisplayObject ):Boolean				{					var range:Number = _attackingGameObject.range * 90;						range = range * range;										var distance:Number = (_positionIn2D.x - target.positionIn2D.x) * (_positionIn2D.x - target.positionIn2D.x);						distance += (_positionIn2D.y - target.positionIn2D.y) * (_positionIn2D.y - target.positionIn2D.y);										if( distance > range )						return false;										return true;				}							/** getClosestTarget			  *	---------------------------------------------------------------------------- *			  *	Returns the closest target to attack			  *	---------------------------------------------------------------------------- 				protected function getClosestTarget( targets:Array ):GameLevelDisplayObject				{					//var sortedTargets:Array = new Array();										if( targets.length > 0 )						return sortTargetsByDistance(targets)[0];										return null;				}*/											/** sortTargetsByDistance			  *	---------------------------------------------------------------------------- *			  *	Sort the targets based on the distance. First one is the closest			  *	---------------------------------------------------------------------------- */				protected function sortTargetsByDistance( targets:Vector.<GameLevelAttackingDisplayObject> ):Vector.<GameLevelAttackingDisplayObject>				{					var sortedTargets:Vector.<GameLevelAttackingDisplayObject> = new Vector.<GameLevelAttackingDisplayObject>;					var distances:Array = new Array();					var distance:Number;					var i:uint, j:uint;					var targetsLength:int = targets.length;					var sortedTargetsLength:int = 0;										for( i=0; i<targetsLength; ++i )					{						distance = ((GameLevelDisplayObject(targets[i]).positionIn2D.y - _positionIn2D.y) * (GameLevelDisplayObject(targets[i]).positionIn2D.y - _positionIn2D.y));						distance += ((GameLevelDisplayObject(targets[i]).positionIn2D.x - _positionIn2D.x) * (GameLevelDisplayObject(targets[i]).positionIn2D.x - _positionIn2D.x));												//trace( "targets[i]: "+targets[i].currentTile );						//trace( "distance: "+distance );												if( sortedTargets.length == 0 )						{							sortedTargets.push( targets[i] );							distances.push( distance );						}						else						{							sortedTargetsLength = sortedTargets.length;														for( j=0; j<sortedTargetsLength; ++j )							{								if( distance < distances[j] )								{									sortedTargets.splice( j, 0, targets[i] );									distances.splice( j, 0, distance );									break;								}								else if( j == sortedTargets.length-1 )								{									sortedTargets.push( targets[i] );									distances.push( distance );									break;								}							}						}					}										return sortedTargets;				}							/** stopAttacking			  *	---------------------------------------------------------------------------- */				public function stopAttacking():void				{					if( _attacking )					{						if( _attackTimer != null )							_attackTimer.stop();												_attacking = false;					}				}							/** handleAttackTimerFired			  *	---------------------------------------------------------------------------- */				protected function handleAttackTimerFired( timer:CustomTimer ):void				{					//trace( "handleAttackTimerFired();" );										_attacking = false;					_attackTimer.stop();										//dispatchEvent( new GameLevelEvent(GameLevelEvent.ATTACK_TIMER_FIRE) );					onAttackTimerFired.dispatch( this );				}								public function clone():*				{					var clonedObject:GameLevelAttackingDisplayObject = UtilFunctions.clone(this) as GameLevelAttackingDisplayObject;										return clonedObject;				}		}			}