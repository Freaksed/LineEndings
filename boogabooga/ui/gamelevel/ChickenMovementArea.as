/** ChickenMovementArea  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that contains the movement area for chickens.  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.events.Event;		import flash.events.FullScreenEvent;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.utils.getDefinitionByName;				import com.greensock.TweenLite;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;				//import com.gamelevel.data.*;		import com.boogabooga.data.gamelevel.Chicken;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.utils.GameLevelUtil;				public class ChickenMovementArea extends GameLevelDisplayObject		{			protected var _topLeftPointIn2D:Point;			protected var _topRightPointIn2D:Point;			protected var _bottomRightPointIn2D:Point;			protected var _bottomLeftPointIn2D:Point;						protected var _topLeftPointInIsometric:Point;			protected var _topRightPointInIsometric:Point;			protected var _bottomRightPointInIsometric:Point;			protected var _bottomLeftPointInIsometric:Point;						protected var _movementAreaIn2D:Rectangle;			protected var _emptyArea:Boolean;						/**	Stage Instances **/			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function ChickenMovementArea()				{					//init();				}								public function set emptyArea( b:Boolean ):void { _emptyArea = b; }				public function get emptyArea():Boolean { return _emptyArea; }								public function get movementAreaIn2D():Rectangle { return _movementAreaIn2D; }							/** init			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				override public function init():void				{					//trace( "ChickenMovementArea: init();" );										super.init();										_topLeftPointIn2D = new Point();					_topRightPointIn2D = new Point();					_bottomRightPointIn2D = new Point();					_bottomLeftPointIn2D = new Point();										_topLeftPointInIsometric = new Point();					_topRightPointInIsometric = new Point();					_bottomRightPointInIsometric = new Point();					_bottomLeftPointInIsometric = new Point();										_debug = true;					_emptyArea = true;				}							/** setPoints			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function setPoints( topLeft:Point, topRight:Point, bottomRight:Point, bottomLeft:Point ):void				{					//trace( "topLeft: "+topLeft );					//trace( "topRight: "+topRight );					//trace( "bottomRight: "+bottomRight );					//trace( "bottomLeft: "+bottomLeft );										_topLeftPointIn2D = topLeft;					_topRightPointIn2D = topRight;					_bottomRightPointIn2D = bottomRight;					_bottomLeftPointIn2D = bottomLeft;										_movementAreaIn2D = new Rectangle( topLeft.x, topLeft.y, topRight.x-topLeft.x, bottomLeft.y-topLeft.y );										var positionInIsometric:Point = GameLevelUtil.getPositionInIsometric( _topLeftPointIn2D );					_topLeftPointInIsometric.x = positionInIsometric.x;					_topLeftPointInIsometric.y = positionInIsometric.y;					//_topLeftPointInIsometric.x = Math.round((_topLeftPointIn2D.x * _isometricMatrix[0][0]) + (_topLeftPointIn2D.y * _isometricMatrix[1][0]));					//_topLeftPointInIsometric.y = Math.round((_topLeftPointIn2D.x * _isometricMatrix[0][1]) + (_topLeftPointIn2D.y * _isometricMatrix[1][1]));										positionInIsometric = GameLevelUtil.getPositionInIsometric( _topRightPointIn2D );					_topRightPointInIsometric.x = positionInIsometric.x;					_topRightPointInIsometric.y = positionInIsometric.y;					//_topRightPointInIsometric.x = Math.round((_topRightPointIn2D.x * _isometricMatrix[0][0]) + (_topRightPointIn2D.y * _isometricMatrix[1][0]));					//_topRightPointInIsometric.y = Math.round((_topRightPointIn2D.x * _isometricMatrix[0][1]) + (_topRightPointIn2D.y * _isometricMatrix[1][1]));										positionInIsometric = GameLevelUtil.getPositionInIsometric( _bottomRightPointIn2D );					_bottomRightPointInIsometric.x = positionInIsometric.x;					_bottomRightPointInIsometric.y = positionInIsometric.y;					//_bottomRightPointInIsometric.x = Math.round((_bottomRightPointIn2D.x * _isometricMatrix[0][0]) + (_bottomRightPointIn2D.y * _isometricMatrix[1][0]));					//_bottomRightPointInIsometric.y = Math.round((_bottomRightPointIn2D.x * _isometricMatrix[0][1]) + (_bottomRightPointIn2D.y * _isometricMatrix[1][1]));										positionInIsometric = GameLevelUtil.getPositionInIsometric( _bottomLeftPointIn2D );					_bottomLeftPointInIsometric.x = positionInIsometric.x;					_bottomLeftPointInIsometric.y = positionInIsometric.y;					//_bottomLeftPointInIsometric.x = Math.round((_bottomLeftPointIn2D.x * _isometricMatrix[0][0]) + (_bottomLeftPointIn2D.y * _isometricMatrix[1][0]));					//_bottomLeftPointInIsometric.y = Math.round((_bottomLeftPointIn2D.x * _isometricMatrix[0][1]) + (_bottomLeftPointIn2D.y * _isometricMatrix[1][1]));									}							/** render			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				override public function render():void				{					//super.render();										_contentClip.graphics.clear();										//trace( _positionIn2D );										if( this._inIsometricView )					{						_contentClip.graphics.moveTo( _topLeftPointInIsometric.x, _topLeftPointInIsometric.y );						_contentClip.graphics.beginFill( 0x000000, 0 );						_contentClip.graphics.lineTo( _topRightPointInIsometric.x, _topRightPointInIsometric.y );						_contentClip.graphics.lineTo( _bottomRightPointInIsometric.x, _bottomRightPointInIsometric.y );						_contentClip.graphics.lineTo( _bottomLeftPointInIsometric.x, _bottomLeftPointInIsometric.y );						_contentClip.graphics.lineTo( _topLeftPointInIsometric.x, _topLeftPointInIsometric.y );						_contentClip.graphics.endFill();					}					else					{						_contentClip.graphics.moveTo( _topLeftPointIn2D.x, _topLeftPointIn2D.y );						_contentClip.graphics.beginFill( 0x000000, 0 );						_contentClip.graphics.lineTo( _topRightPointIn2D.x, _topRightPointIn2D.y );						_contentClip.graphics.lineTo( _bottomRightPointIn2D.x, _bottomRightPointIn2D.y );						_contentClip.graphics.lineTo( _bottomLeftPointIn2D.x, _bottomLeftPointIn2D.y );						_contentClip.graphics.lineTo( _topLeftPointIn2D.x, _topLeftPointIn2D.y );						_contentClip.graphics.endFill();					}				}		}			}