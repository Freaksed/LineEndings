/** GameboardTile  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel	{		import flash.display.MovieClip;		import flash.display.Sprite;		import flash.events.Event;		import flash.events.IOErrorEvent;		import flash.events.MouseEvent;		import flash.events.ProgressEvent;		import flash.events.TimerEvent;		import flash.filters.GlowFilter;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.utils.Timer;				import com.greensock.TweenLite;		import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.cache.HashTable;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.loader.CustomLoader;						import com.boogabooga.ui.gamelevel.Gameboard;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.ui.gamelevel.weapons.WeaponDisplayObject;				public class GameboardTile extends GameLevelDisplayObject		{			protected var _id:uint;			protected var _tileWidth:int;			protected var _tileHeight:int;			protected var _tileType:String;			protected var _tileTypeIndex:uint;			protected var _tileSize:String;			protected var _tileSizeIndex:uint;			protected var _row:int;			protected var _column:int;			protected var _currentTile:MovieClip;			protected var _includedInCurrentPath:Boolean;			protected var _occupiedByWeapon:Boolean;			protected var _occupiedByShield:Boolean;			protected var _occupiedByAddition:Boolean;			protected var _editable:Boolean;			protected var _layerNumber:uint;			protected var _hasExtraHitArea1:Boolean;			protected var _hasExtraHitArea2:Boolean;			protected var _hasExtraHitArea3:Boolean;			protected var _hasExtraHitArea4:Boolean;						//protected var _positionIn2D:Point;			//protected var _inIsometricView:Boolean;						//protected var _inEditorMode:Boolean;						protected var _isometricTileClips:Array;			protected var _tileClips:Array;			//protected var _weaponsWatching:Array;						/**	Stage Instances **/			public var border_mc:MovieClip;			public var placeable_mc:MovieClip;			public var path_mc:MovieClip;			public var gate_mc:MovieClip;			public var digSpot_mc:MovieClip;			public var isometricBorder_mc:MovieClip;			public var isometricPlaceable_mc:MovieClip;			public var isometricPath_mc:MovieClip;			public var isometricGate_mc:MovieClip;			public var isometricDigSpot_mc:MovieClip;			public var extraHitArea1_mc:MovieClip;			public var extraHitArea2_mc:MovieClip;			public var extraHitArea3_mc:MovieClip;			public var extraHitArea4_mc:MovieClip;			/**	End of Stage Instances **/						public static const TILE_TYPE_PLACEABLE:String = "TileTypePlaceable";			public static const TILE_TYPE_PATH:String = "TileTypePath";			public static const TILE_TYPE_DIG_SPOT:String = "TileTypeDigSpot";			public static const TILE_TYPE_GATE:String = "TileTypeGate";			public static const TILE_TYPE_SPAWN_POINT:String = "TileTypeSpawnPoint";			public static const TILE_TYPE_CHICKEN_AREA:String = "TileTypeChickenArea";						public static var TILE_TYPE_PLACEABLE_INDEX:uint;			public static var TILE_TYPE_PATH_INDEX:uint;			public static var TILE_TYPE_DIG_SPOT_INDEX:uint;			public static var TILE_TYPE_GATE_INDEX:uint;			public static var TILE_TYPE_SPAWN_POINT_INDEX:uint;			public static var TILE_TYPE_CHICKEN_AREA_INDEX:uint;						/** Constructor			  *	---------------------------------------------------------------------------- */				public function GameboardTile()				{					//init();				}								override public function set contentClip( m:MovieClip ):void				{					super.contentClip = m;										border_mc = _contentClip.border_mc;					placeable_mc = _contentClip.placeable_mc;					path_mc = _contentClip.path_mc;					gate_mc = _contentClip.gate_mc;					digSpot_mc = _contentClip.digSpot_mc;					isometricBorder_mc = _contentClip.isometricBorder_mc;					isometricPlaceable_mc = _contentClip.isometricPlaceable_mc;					isometricPath_mc = _contentClip.isometricPath_mc;					isometricGate_mc = _contentClip.isometricGate_mc;					isometricDigSpot_mc = _contentClip.isometricDigSpot_mc;					extraHitArea1_mc = _contentClip.extraHitArea1_mc;					extraHitArea1_mc.visible = false;					extraHitArea2_mc = _contentClip.extraHitArea2_mc;					extraHitArea2_mc.visible = false;					extraHitArea3_mc = _contentClip.extraHitArea3_mc;					extraHitArea3_mc.visible = false;					extraHitArea4_mc = _contentClip.extraHitArea4_mc;					extraHitArea4_mc.visible = false;				}							/** set/get id			  *	---------------------------------------------------------------------------- */				public function set id( u:uint ):void { _id = u; }				public function get id():uint { return _id; }							/** set/get editable			  *	---------------------------------------------------------------------------- */				public function set editable( _e:Boolean ):void				{					_editable = _e;										if( _editable )					{						_contentClip.buttonMode = true;						_contentClip.addEventListener( MouseEvent.MOUSE_OVER, handleMouseOver, false, 0, true );						_contentClip.addEventListener( MouseEvent.MOUSE_OUT, handleMouseOut, false, 0, true );						_contentClip.addEventListener( MouseEvent.CLICK, handleClicked, false, 0, true );					}					else					{						_contentClip.buttonMode = false;												if( _contentClip.hasEventListener(MouseEvent.CLICK) )							_contentClip.removeEventListener( MouseEvent.CLICK, handleClicked );												_contentClip.removeEventListener( MouseEvent.MOUSE_OVER, handleMouseOver );						_contentClip.removeEventListener( MouseEvent.MOUSE_OUT, handleMouseOut );					}										//_contentClip.addEventListener( MouseEvent.ROLL_OVER, handleRolledOver, false, 0, true );					//_contentClip.addEventListener( MouseEvent.ROLL_OUT, handleRolledOut, false, 0, true );				}				public function get editable():Boolean				{					return _editable;				}							/** set/get layerNumber			  *	---------------------------------------------------------------------------- */				public function set layerNumber( l:uint ):void { _layerNumber = l; }				public function get layerNumber():uint { return _layerNumber; }							/** set/get tileWidth			  *	---------------------------------------------------------------------------- */				public function set tileWidth( _w:int ):void { _tileWidth = _w; }				public function get tileWidth():int { return _tileWidth; }							/** set/get tileHeight			  *	---------------------------------------------------------------------------- */				public function set tileHeight( _h:int ):void { _tileHeight = _h; }				public function get tileHeight():int { return _tileHeight; }							/** set/get tileType			  *	---------------------------------------------------------------------------- */				public function set tileType( _t:String ):void				{					_tileType = _t;										_tileTypeIndex = HashTable.getInstance().getHash( _tileType );					/*					if( this._tileType == GameboardTile.TILE_TYPE_PLACEABLE )					{						//placeable_mc.visible = true;						//path_mc.visible = false;					}					else if( this._tileType == GameboardTile.TILE_TYPE_PATH )					{						//placeable_mc.visible = false;						//path_mc.visible = true;												//EventNotificationCenter.getInstance().addEventListener( "onTowerRangeUpdated", handleTowerRangeUpdated );					}					*/					//showTileClip( this._tileType );										showTileClip( _tileTypeIndex );				}				public function get tileType():String { return _tileType; }							/** set/get tileTypeIndex			  *	---------------------------------------------------------------------------- */				//public function set tileTypeIndex( u:uint ):void { _tileTypeIndex = u; }				public function get tileTypeIndex():uint { return _tileTypeIndex; }							/** set/get tileSize			  *	---------------------------------------------------------------------------- */				public function set tileSize( _s:String ):void				{					_tileSize = _s;										_tileSizeIndex = HashTable.getInstance().getHash( _tileSize );				}				public function get tileSize():String { return _tileSize; }							/** set/get tileSizeIndex			  *	---------------------------------------------------------------------------- */				//public function set tileSizeIndex( u:uint ):void { _tileSizeIndex = u; }				public function get tileSizeIndex():uint { return _tileSizeIndex; }							/** set/get row			  *	---------------------------------------------------------------------------- */				public function set row( _r:int ):void { _row = _r; }				public function get row():int { return _row; }							/** set/get column			  *	---------------------------------------------------------------------------- */				public function set column( _c:int ):void { _column = _c; }				public function get column():int { return _column; }							/** set/get includedInCurrentPath			  *	---------------------------------------------------------------------------- */				public function set includedInCurrentPath( _i:Boolean ):void { _includedInCurrentPath = _i; }				public function get includedInCurrentPath():Boolean { return _includedInCurrentPath; }							/** set/get occupiedByWeapon			  *	---------------------------------------------------------------------------- */				public function set occupiedByWeapon( b:Boolean ):void { _occupiedByWeapon = b; }				public function get occupiedByWeapon():Boolean { return _occupiedByWeapon; }								public function set occupiedByShield( b:Boolean ):void { _occupiedByShield = b; }				public function get occupiedByShield():Boolean { return _occupiedByShield; }								public function set occupiedByAddition( b:Boolean ):void { _occupiedByAddition = b; }				public function get occupiedByAddition():Boolean { return _occupiedByAddition; }							/** set inIsometricView			  *	---------------------------------------------------------------------------- */			 	override public function set inIsometricView( i:Boolean ):void				{					super.inIsometricView = i;										if( _inIsometricView )					{						border_mc.visible = false;						isometricBorder_mc.visible = true;					}					else					{						border_mc.visible = true;						isometricBorder_mc.visible = false;					}										if( !_editable )					{						_editable = true;						showTileClip( _tileTypeIndex );						_editable = false;					}					else					{						showTileClip( _tileTypeIndex );					}										//trace( this.placeable_mc.visible );					//trace( this.isometricPlaceable_mc.visible );										render();				}								public function set tileOpacity( n:Number ):void				{					border_mc.alpha = n;					placeable_mc.alpha = n;					path_mc.alpha = n;					gate_mc.alpha = n;					digSpot_mc.alpha = n;										isometricBorder_mc.alpha = n;					isometricPlaceable_mc.alpha = n;					isometricPath_mc.alpha = n;					isometricGate_mc.alpha = n;					isometricDigSpot_mc.alpha = n;				}								public function get currentTile():MovieClip { return _currentTile; }								public function set hasExtraHitArea1( b:Boolean ):void { _hasExtraHitArea1 = b; }				public function get hasExtraHitArea1():Boolean { return _hasExtraHitArea1; }				public function set hasExtraHitArea2( b:Boolean ):void { _hasExtraHitArea2 = b; }				public function get hasExtraHitArea2():Boolean { return _hasExtraHitArea2; }				public function set hasExtraHitArea3( b:Boolean ):void { _hasExtraHitArea3 = b; }				public function get hasExtraHitArea3():Boolean { return _hasExtraHitArea3; }				public function set hasExtraHitArea4( b:Boolean ):void { _hasExtraHitArea4 = b; }				public function get hasExtraHitArea4():Boolean { return _hasExtraHitArea4; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										TILE_TYPE_PLACEABLE_INDEX = HashTable.getInstance().addHash( TILE_TYPE_PLACEABLE );					TILE_TYPE_PATH_INDEX = HashTable.getInstance().addHash( TILE_TYPE_PATH );					TILE_TYPE_DIG_SPOT_INDEX = HashTable.getInstance().addHash( TILE_TYPE_DIG_SPOT );					TILE_TYPE_GATE_INDEX = HashTable.getInstance().addHash( TILE_TYPE_GATE );					TILE_TYPE_SPAWN_POINT_INDEX = HashTable.getInstance().addHash( TILE_TYPE_SPAWN_POINT );					TILE_TYPE_CHICKEN_AREA_INDEX = HashTable.getInstance().addHash( TILE_TYPE_CHICKEN_AREA );										_occupiedByWeapon = false;					_occupiedByShield = false;					_occupiedByAddition = false;										_includedInCurrentPath = false;					//_inEditorMode = false;										border_mc.visible = false;					placeable_mc.visible = false;					path_mc.visible = false;					gate_mc.visible = false;					digSpot_mc.visible = false;					isometricBorder_mc.visible = false;					isometricBorder_mc.alpha = 0;					isometricBorder_mc.cacheAsBitmap = true;					isometricPlaceable_mc.visible = false;					isometricPlaceable_mc.alpha = 0;					isometricPlaceable_mc.cacheAsBitmap = true;					isometricPath_mc.visible = false;					isometricPath_mc.alpha = 0;					isometricPath_mc.cacheAsBitmap = true;					isometricGate_mc.visible = false;					isometricGate_mc.alpha = 0;					isometricGate_mc.cacheAsBitmap = true;					isometricDigSpot_mc.visible = false;					isometricDigSpot_mc.alpha = 0;					isometricDigSpot_mc.cacheAsBitmap = true;										_tileClips = [ {typeIndex:TILE_TYPE_PLACEABLE_INDEX, clip:placeable_mc}, {typeIndex:TILE_TYPE_PATH_INDEX, clip:path_mc}, {typeIndex:TILE_TYPE_GATE_INDEX, clip:gate_mc}, {typeIndex:TILE_TYPE_DIG_SPOT_INDEX, clip:digSpot_mc} ];					_isometricTileClips = [ {typeIndex:TILE_TYPE_PLACEABLE_INDEX, clip:isometricPlaceable_mc}, {typeIndex:TILE_TYPE_PATH_INDEX, clip:isometricPath_mc}, {typeIndex:TILE_TYPE_GATE_INDEX, clip:isometricGate_mc}, {typeIndex:TILE_TYPE_DIG_SPOT_INDEX, clip:isometricDigSpot_mc} ];										//this.tileType = TILE_TYPE_PLACEABLE;					_contentClip.tabEnabled = false;										_editable = true;					_inIsometricView = false;					_layerNumber = 0;					_hasExtraHitArea1 = false;					_hasExtraHitArea2 = false;					_hasExtraHitArea3 = false;					_hasExtraHitArea4 = false;										//_weaponsWatching = new Array();				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					this.tileType = TILE_TYPE_PLACEABLE;										_contentClip.removeEventListener( MouseEvent.CLICK, handleClicked );					_contentClip.removeEventListener( MouseEvent.MOUSE_OVER, handleMouseOver );					_contentClip.removeEventListener( MouseEvent.MOUSE_OUT, handleMouseOut );										ArrayUtil.removeAll( _tileClips );					ArrayUtil.removeAll( _isometricTileClips );										super.kill();										//_contentClip.removeEventListener( MouseEvent.ROLL_OVER, handleRolledOver );					//_contentClip.removeEventListener( MouseEvent.ROLL_OUT, handleRolledOut );					/*					for( var i in _tileClips )					{						delete _tileClips[i].typeIndex;						delete _tileClips[i].clip;						_tileClips[i] = null;					}					_tileClips = null;										for( i in _isometricTileClips )					{						delete _isometricTileClips[i].typeIndex;						delete _isometricTileClips[i].clip;						_isometricTileClips[i] = null;					}					_isometricTileClips = null;					*/					/*					for( var j:uint=0; j<_weaponsWatching.length; ++j )					{						_weaponsWatching[j] = null;					}					_weaponsWatching = new Array();					*/					//_gameboardReference = null;				}							/** handleClicked			  *	---------------------------------------------------------------------------- */				protected function handleClicked( event:MouseEvent ):void				{					/*					if( this._tileType == GameboardTile.TILE_TYPE_PLACEABLE )					{						this.tileType = GameboardTile.TILE_TYPE_PATH;					}					else if( this._tileType == GameboardTile.TILE_TYPE_PATH )					{						this.tileType = GameboardTile.TILE_TYPE_PLACEABLE;					}					*/					/*					if( this._tileType != GameboardTile.TILE_TYPE_PLACEABLE )					{						this.tileType = GameboardTile.TILE_TYPE_PLACEABLE;					}					*/					dispatchEvent( new CustomEvent("onTileClicked") );				}								protected function handleMouseOver( event:MouseEvent ):void				{					dispatchEvent( new CustomEvent("onTileMouseOver") );				}								protected function handleMouseOut( event:MouseEvent ):void				{					dispatchEvent( new CustomEvent("onTileMouseOut") );				}							/** handleRolledOver			  *	---------------------------------------------------------------------------- *			  *	This event is fired when user rolls over the tile.			  *	---------------------------------------------------------------------------- 			 	private function handleRolledOver( event:MouseEvent ):void				{					showCrosshair();				}*/							/** handleRolledOut			  *	---------------------------------------------------------------------------- *			  *	This event is fired when user rolls off from the tile.			  *	---------------------------------------------------------------------------- 			 	private function handleRolledOut( event:MouseEvent ):void				{					hideCrosshair();				}*/							/** showCrosshair			  *	---------------------------------------------------------------------------- *			  *	Dispatches the event to show the red/green crosshair.			  *	---------------------------------------------------------------------------- 			 	public function showCrosshair():void				{					if( _inIsometricView )					{						//if( this._tileType == TILE_TYPE_TOWER )												if( this._tileTypeIndex == TILE_TYPE_TOWER_INDEX )						{							//dispatchEvent( new CustomEvent("onShowCrosshair") );						}						else						{							//dispatchEvent( new CustomEvent("onShowCrosshair") );						}												//else if( this._tileType == Tile_TYPE_					}				}*/							/** hideCrosshair			  *	---------------------------------------------------------------------------- *			  *	Dispatches the event to hide the red/green crosshair.			  *	---------------------------------------------------------------------------- 			 	public function hideCrosshair():void				{					if( _inIsometricView )					{						dispatchEvent( new CustomEvent("onHideCrosshair") );					}				}*/							/** showTileClip			  *	---------------------------------------------------------------------------- */				public function showTileClip( tileTypeIndex:uint ):void				{					//trace( "editable: "+editable );					//trace( "_inIsometricView: "+_inIsometricView );										if( editable )					{						extraHitArea1_mc.visible = false;												var i:int;												if( _inIsometricView )						{							for( i=0; i<_tileClips.length; i++ )								_tileClips[i].clip.visible = false;														for( i=0; i<_isometricTileClips.length; i++ )							{								//if( tileType == _isometricTileClips[i].type )								if( _tileTypeIndex == TILE_TYPE_SPAWN_POINT_INDEX && _isometricTileClips[i].typeIndex == TILE_TYPE_GATE_INDEX )								{									_currentTile = _isometricTileClips[i].clip;									_isometricTileClips[i].clip.visible = true;								}								else if( _tileTypeIndex == TILE_TYPE_CHICKEN_AREA_INDEX && _isometricTileClips[i].typeIndex == TILE_TYPE_PATH_INDEX )								{									_currentTile = _isometricTileClips[i].clip;									_isometricTileClips[i].clip.visible = true;								}								else if( _tileTypeIndex == _isometricTileClips[i].typeIndex )								{									_currentTile = _isometricTileClips[i].clip;									_isometricTileClips[i].clip.visible = true;									//trace( "setting "+_isometricTileClips[i].clip+"to visible" );									//_isometricTileClips[i].clip.cacheAsBitmap = true;								}								else								{									_isometricTileClips[i].clip.visible = false;								}							}														if( _tileTypeIndex == TILE_TYPE_PATH_INDEX || _tileTypeIndex == TILE_TYPE_DIG_SPOT_INDEX )							{								isometricBorder_mc.visible = false;							}							else							{								isometricBorder_mc.visible = true;							}						}						else						{							for( i=0; i<_isometricTileClips.length; i++ )								_isometricTileClips[i].clip.visible = false;																					for( i=0; i<_tileClips.length; i++ )							{								//if( tileType == _tileClips[i].type )								if( _tileTypeIndex == TILE_TYPE_SPAWN_POINT_INDEX && _isometricTileClips[i].typeIndex == TILE_TYPE_GATE_INDEX )								{									_currentTile = _tileClips[i].clip;									_tileClips[i].clip.visible = true;								}								else if( _tileTypeIndex == TILE_TYPE_CHICKEN_AREA_INDEX && _isometricTileClips[i].typeIndex == TILE_TYPE_PATH_INDEX )								{									_currentTile = _tileClips[i].clip;									_tileClips[i].clip.visible = true;								}								else if( _tileTypeIndex == _tileClips[i].typeIndex )								{									_currentTile = _tileClips[i].clip;									_tileClips[i].clip.visible = true;									//_tileClips[i].clip.cacheAsBitmap = true;								}								else								{									_tileClips[i].clip.visible = false;								}							}														if( _tileTypeIndex == TILE_TYPE_PATH_INDEX || _tileTypeIndex == TILE_TYPE_DIG_SPOT_INDEX )							{								border_mc.visible = false;							}							else							{								border_mc.visible = true;							}						}											}				}							/** hideTileClip			  *	---------------------------------------------------------------------------- */				public function hideTileClip( tileType:String ):void				{					for( var i:int=0; i<_tileClips.length; i++ )					{						_tileClips[i].clip.visible = false;					}				}							/** toggleHitArea			  *	---------------------------------------------------------------------------- */				public function toggleHitArea( index:int=-1, toggled:Boolean=false ):void				{					if( index == 0 )					{						//extraHitArea1_mc.visible = toggled;						_hasExtraHitArea1 = toggled;					}					else if( index == 1 )					{						_hasExtraHitArea2 = toggled;					}					else if( index == 2 )					{						_hasExtraHitArea3 = toggled;					}					else if( index == 3 )					{						_hasExtraHitArea4 = toggled;					}				}							/** getTileBound			  *	---------------------------------------------------------------------------- */				public function getTileBound():Rectangle				{					//var rect:Rectangle = path_mc.getBounds(_gameboardReference.tilesContainer_mc);					//var rect:Rectangle = new Rectangle( this._positionIn2D.x-_gameboardReference.tilesContainer_mc.x-path_mc.width/2, this._positionIn2D.y-_gameboardReference.tilesContainer_mc.y-path_mc.width/2, path_mc.width, path_mc.height );					var rect:Rectangle = new Rectangle( _positionIn2D.x-path_mc.width/2, _positionIn2D.y-path_mc.width/2, path_mc.width, path_mc.height );										return rect;				}							/** isAdjacentToTile			  *	---------------------------------------------------------------------------- */				public function isAdjacentToTile( tile:GameboardTile ):Boolean				{					if( _row == tile.row && (_column == tile.column+1 || _column == tile.column-1) )					{						return true;					}					else if( _column == tile.column && (_row == tile.row+1 || _row == tile.row-1) )					{						return true;					}										return false;				}								public function isTheSameAsTile( tile:GameboardTile ):Boolean				{					if( _row == tile.row && _column == tile.column )						return true;										return false;				}							/** override toString			  *	---------------------------------------------------------------------------- */				override public function toString():String				{					//return this.name;					//return "tile_"+_row+"_"+_column;					return _contentClip.name;				}		}			}