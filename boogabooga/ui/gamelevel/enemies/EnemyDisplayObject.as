/** EnemyDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Enemy class.  *		Various enemy properties  *			- Puncher  *			- Projectile  *			- Laser  *			- Flyer  *			- Egg Layer  *			- Egg  *			- Egg Layer Hatchling  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel.enemies	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.display.Sprite;		import flash.events.Event;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.events.MouseEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.events.TimerEvent;		import flash.utils.getDefinitionByName;				import com.greensock.TweenLite;		import com.greensock.easing.Sine;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.events.EventNotificationCenter;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.sound.SoundEffectPlayer;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.cache.BitmapDataManager;		import org.osflash.signals.Signal;				//import com.gamelevel.data.*;		import com.boogabooga.data.SettingsIndex;		import com.boogabooga.data.SoundData;		import com.boogabooga.data.SoundsIndex;		import com.boogabooga.data.StringsIndex;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.GameLevelDataIndex;		import com.boogabooga.data.gamelevel.God;		import com.boogabooga.data.maingame.MainGameDataIndex;		import com.boogabooga.events.BoogaEvent;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.AnimationDisplayObject;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.GameLevelAttackingDisplayObject;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.ui.gamelevel.weapons.WeaponDisplayObject;		import com.boogabooga.utils.GameLevelUtil;		import com.boogabooga.utils.ElementCompatibility;				public dynamic class EnemyDisplayObject extends GameLevelAttackingDisplayObject		{			//protected var _contentClip:MovieClip;			//protected var _shadowClip:MovieClip;			protected var _targetAltitude:Number;			protected var _shadowDisplayObject:GameLevelDisplayObject;						protected var _spawnPath:Vector.<GameboardTile>;			protected var _spawnPathLength:int;			protected var _inSpawnPath:Boolean;			protected var _currentPath:Vector.<GameboardTile>;			protected var _currentPathLength:int;						protected var _targetTile:GameboardTile;			protected var _targetPoint:Point;			protected var _nextMovementPoints:Array;			protected var _hitareaBounds:Rectangle;			protected var _currentSpeed:Number;			//protected var _atEndOfPath:Boolean;			protected var _currentAnimationDisplayObject:AnimationDisplayObject;			protected var _halfwayPoint:Point;			protected var _passedHalfwayPoint:Boolean;						protected var _pushedBack:Boolean;			protected var _reversed:Boolean;			protected var _oldDirection:int;			protected var _moving:Boolean;			protected var _pausedMoving:Boolean;			protected var _overshootX:Boolean;			protected var _overshootY:Boolean;			protected var _oldAnimationDirection:int;						//protected var _attackedTarget:GameLevelAttackingDisplayObject;			protected var _hitByCurrentGod:Boolean;			protected var _hitBySpringTrapAnimation:Boolean;						protected var _hitByWeapons:Vector.<WeaponDisplayObject>;						protected var _walkUpAnimationClip:AnimationDisplayObject;			protected var _walkDownAnimationClip:AnimationDisplayObject;			protected var _attackUpAnimationClip:AnimationDisplayObject;			protected var _attackDownAnimationClip:AnimationDisplayObject;			protected var _deathUpAnimationClip:AnimationDisplayObject;			protected var _deathDownAnimationClip:AnimationDisplayObject;						protected var _toStringOutput:String;						public var onRemovedFromGame:Signal;			public var onMovedToNextTile:Signal;			public var onMovedToNextPoint:Signal;			public var onSpawnPathEnded:Signal;			public var onSpawnPathReentered:Signal;			public var onPathEnded:Signal;						/**	Stage Instances **/			public var walkUpAnimation_mc:MovieClip;			public var walkDownAnimation_mc:MovieClip;			//public var rightAnimation_mc:MovieClip;			//public var leftAnimation_mc:MovieClip;			public var attackUpAnimation_mc:MovieClip;			public var attackDownAnimation_mc:MovieClip;			public var deathUpAnimation_mc:MovieClip;			public var deathDownAnimation_mc:MovieClip;			public var hitarea_mc:MovieClip;			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function EnemyDisplayObject()				{									}							/** set/get path			  *	---------------------------------------------------------------------------- */				override public function set path( p:Vector.<GameboardTile> ):void				{					//trace( "set path: "+_p );										super.path = p;										_currentIndexInPath = 0;										if( !_inSpawnPath )					{						_currentPath = _path;						_currentPathLength = _pathLength;												var startBoundRectangle:Rectangle = GameboardTile(_path[0]).getTileBound();												//trace( startBoundRectangle );						//trace( GameboardTile(_path[0]).row );						//trace( GameboardTile(_path[0]).column );												if( GameboardTile(_path[0]).row == 0 )						{							_positionIn2D.x = startBoundRectangle.left + startBoundRectangle.width*0.5;							_positionIn2D.y = startBoundRectangle.top;						}						else if( GameboardTile(_path[0]).row == GameLevelDataIndex.getInstance().boardMaxRows-1 )						{							_positionIn2D.x = startBoundRectangle.left + startBoundRectangle.width*0.5;							_positionIn2D.y = startBoundRectangle.bottom;						}						else if( GameboardTile(_path[0]).column == 0 )						{							_positionIn2D.x = startBoundRectangle.left;							_positionIn2D.y = startBoundRectangle.top + startBoundRectangle.height*0.5;						}						else if( GameboardTile(_path[0]).column == GameLevelDataIndex.getInstance().boardMaxColumns-1 )						{							_positionIn2D.x = startBoundRectangle.right;							_positionIn2D.y = startBoundRectangle.top + startBoundRectangle.height*0.5;						}												//trace( "_positionIn2D: "+_positionIn2D );												_currentTile = _path[0];												//trace( "_currentTile: "+_currentTile );												render();					}				}								public function set spawnPath( p:Vector.<GameboardTile> ):void				{					_spawnPath = p;					_spawnPathLength = _spawnPath.length;					_currentIndexInPath = 0;					var startBoundRectangle:Rectangle = _spawnPath[0].getTileBound();										_positionIn2D.x = startBoundRectangle.left + startBoundRectangle.width*0.5;					_positionIn2D.y = startBoundRectangle.top + startBoundRectangle.height*0.5;										_currentPath = _spawnPath;					_currentPathLength = _spawnPathLength;										_currentTile = _spawnPath[0];										render();									}							/** set currentIndexInPath			  *	---------------------------------------------------------------------------- *			  *	For enemy, the directions they are facing is the other way since they are			  *	travelling from the end of the path.			  *	---------------------------------------------------------------------------- */				override public function set currentIndexInPath( i:int ):void				{					//trace( "set currentIndexInPath();" );										_currentIndexInPath = i;										//trace( "setting currentIndexInpath to "+i );										//TODO:					//	There might be a bug with the initial direction, keep an eye on this!!!!										if( _reversed || _pushedBack )					{						/*						if( _currentIndexInPath == 0 )							_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath+1], _currentPath[_currentIndexInPath] );						else if( _currentIndexInPath == _currentPathLength-1 )							_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath-1] );						else						{							_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath+1], _currentPath[_currentIndexInPath] );														if( _currentIndexInPath > 1 )							{								_oldDirection = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath-1] );							}						}						*/												/*						if( !_inSpawnPath && _currentIndexInPath == 0 )						{							//trace( "_currentTile: "+_currentPath[_currentIndexInPath] );							//trace( "_path[0]: "+_path[0] );							_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath] );							trace( "_direction on first path tile to spawn path is "+_direction );						}						*/												//trace( "_inSpawnPath: "+_inSpawnPath );						//trace( "_currentIndexInPath: "+_currentIndexInPath );												if( _inSpawnPath )						{							if( _currentIndexInPath == _currentPath.length-1 )							{								//_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _path[0] );								_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath-1] );							}							else if( _currentIndexInPath == 0 )							{								//_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath] );							}							else							{								_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath-1] );							}						}						else						{							if( _currentIndexInPath == 0 )								_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath] );							else								_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _path[_currentIndexInPath-1] );						}												//trace( "_direction: "+_direction );					}					else					{						if( _currentIndexInPath == 0 )							_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath+1], true );						else if( _currentIndexInPath == _currentPathLength-1 )							_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath-1], _currentPath[_currentIndexInPath] );						else							_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath+1] );												if( _inSpawnPath && _currentIndexInPath == _currentPath.length-1 )						{							//trace( "_currentTile: "+_currentPath[_currentIndexInPath] );							//trace( "_path[0]: "+_path[0] );							_direction = GameLevelUtil.directionFromTileAToTileB( _path[0], _currentPath[_currentIndexInPath] );							//trace( "_direction on last spawn tile is "+_direction );						}					}										//if( _direction != _oldDirection )					//{						//showAnimation();					//}										if( _oldDirection < 0 )						_oldDirection = _direction;				}							/** set attackingGameObject			  *	---------------------------------------------------------------------------- */				override public function set attackingGameObject( a:AbstractGameObject ):void				{					super.attackingGameObject = a;										_currentSpeed = _attackingGameObject.speed;										_walkUpAnimationClip.animationObject = Enemy(_attackingGameObject).walkUpAnimationObject;					_walkUpAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Enemy(_attackingGameObject).walkUpAnimationObject.cacheId ).bitmapData;					//_walkUpAnimationClip.initCanvas();										_walkDownAnimationClip.animationObject = Enemy(_attackingGameObject).walkDownAnimationObject;					_walkDownAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Enemy(_attackingGameObject).walkDownAnimationObject.cacheId ).bitmapData;					//_walkDownAnimationClip.initCanvas();										if( Enemy(_attackingGameObject).attackUpAnimationObject != null )					{						_attackUpAnimationClip.animationObject = Enemy(_attackingGameObject).attackUpAnimationObject;						_attackUpAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Enemy(_attackingGameObject).attackUpAnimationObject.cacheId ).bitmapData;						//_attackUpAnimationClip.initCanvas();					}										if( Enemy(_attackingGameObject).attackDownAnimationObject != null )					{						_attackDownAnimationClip.animationObject = Enemy(_attackingGameObject).attackDownAnimationObject;						_attackDownAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Enemy(_attackingGameObject).attackDownAnimationObject.cacheId ).bitmapData;						//_attackDownAnimationClip.initCanvas();					}										if( Enemy(_attackingGameObject).deathUpAnimationObject != null )					{						_deathUpAnimationClip.animationObject = Enemy(_attackingGameObject).deathUpAnimationObject;						_deathUpAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Enemy(_attackingGameObject).deathUpAnimationObject.cacheId ).bitmapData;						//_deathUpAnimationClip.initCanvas();					}										if( Enemy(_attackingGameObject).deathDownAnimationObject != null )					{						_deathDownAnimationClip.animationObject = Enemy(_attackingGameObject).deathDownAnimationObject;						_deathDownAnimationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( Enemy(_attackingGameObject).deathDownAnimationObject.cacheId ).bitmapData;						//_deathDownAnimationClip.initCanvas();					}				}								//public function get atEndOfPath():Boolean { return _atEndOfPath; }								public function get moving():Boolean { return _moving; }				public function get pausedMoving():Boolean { return _pausedMoving; }								public function set hitByCurrentGod( b:Boolean ):void { _hitByCurrentGod = b; }				public function get hitByCurrentGod():Boolean { return _hitByCurrentGod; }								override public function get direction():int { return _direction == _oldDirection ? _direction : _oldDirection; }								public function get passedHalfwayPoint():Boolean { return _passedHalfwayPoint; }								public function set inSpawnPath( b:Boolean ):void { _inSpawnPath = b; }				public function get inSpawnPath():Boolean { return _inSpawnPath; }								public function set currentSpeed( n:Number ):void { _currentSpeed = n; }								public function set reversed( b:Boolean ):void				{					if( _alive && _reversed != b )					{						_reversed = b;												//trace( "_direction before reversed: "+_direction );												this.currentIndexInPath = _currentIndexInPath;												_oldDirection = _direction;						//trace( "_direction: "+_direction );												var tileBound:Rectangle = _currentTile.getTileBound();						//trace( "tileBound: "+tileBound );						//trace( "_direction: "+_direction );						//trace( "_oldDirection: "+_oldDirection );						//trace( "_targetTile.getTileBound(): "+_targetTile.getTileBound() );						/*						if( false )						{							//trace( "change of direction" );							showAnimation( _oldDirection <= 0 ? _direction : _oldDirection );							_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y;														//trace( "next halfway point "+_halfwayPoint );														//_oldDirection = _direction;						}						else						{*/							//trace( "_passedHalfwayPoint is false" );														showAnimation( _direction );							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y + tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.bottom );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y - tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x - tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x + tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y;							}														//trace( "next halfway point "+_halfwayPoint );						//}												//trace( "_targetPoint: "+_targetPoint );						//trace( "_halfwayPoint: "+_halfwayPoint );												if( _attacking )						{							stopAttacking();							continueMoving();						}						else if( _pausedMoving )						{							continueMoving();						}					}				}								public function set pushedBack( b:Boolean ):void				{					if( _alive && _pushedBack != b )					{						_pushedBack = b;												if( _pushedBack )							_currentSpeed = 6;						else							_currentSpeed = _attackingGameObject.speed;												//trace( "_direction before pushed back: "+_direction );												this.currentIndexInPath = _currentIndexInPath;												_oldDirection = _direction;						//trace( "_direction: "+_direction );												var tileBound:Rectangle = _currentTile.getTileBound();						//trace( "tileBound: "+tileBound );						//trace( "_direction: "+_direction );						//trace( "_oldDirection: "+_oldDirection );						//trace( "_targetTile.getTileBound(): "+_targetTile.getTileBound() );						/*						if( false )						{							//trace( "change of direction" );							showAnimation( _oldDirection <= 0 ? _direction : _oldDirection );							_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y;														//trace( "next halfway point "+_halfwayPoint );														//_oldDirection = _direction;						}						else						{*/							//trace( "_passedHalfwayPoint is false" );														showAnimation( _direction );							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y + tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.bottom );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y - tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x - tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x + tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y;							}														//trace( "next halfway point "+_halfwayPoint );						//}												//trace( "_targetPoint: "+_targetPoint );						//trace( "_halfwayPoint: "+_halfwayPoint );												if( _attacking )						{							stopAttacking();							continueMoving();						}						else if( _pausedMoving )						{							continueMoving();						}					}				}							/** set/get contentClip			  *	---------------------------------------------------------------------------- */				override public function set contentClip( m:MovieClip ):void				{					_contentClip = m;					_contentClip.mouseChildren = false;					_contentClip.mouseEnabled = false;										walkUpAnimation_mc = _contentClip.walkUpAnimation_mc;					walkUpAnimation_mc.mouseChildren = false;					walkUpAnimation_mc.mouseEnabled = false;					walkDownAnimation_mc = _contentClip.walkDownAnimation_mc;					walkDownAnimation_mc.mouseChildren = false;					walkDownAnimation_mc.mouseEnabled = false;					attackUpAnimation_mc = _contentClip.attackUpAnimation_mc;					attackUpAnimation_mc.mouseChildren = false;					attackUpAnimation_mc.mouseEnabled = false;					attackDownAnimation_mc = _contentClip.attackDownAnimation_mc;					attackDownAnimation_mc.mouseChildren = false;					attackDownAnimation_mc.mouseEnabled = false;					deathUpAnimation_mc = _contentClip.deathUpAnimation_mc;					deathUpAnimation_mc.mouseChildren = false;					deathUpAnimation_mc.mouseEnabled = false;					deathDownAnimation_mc = _contentClip.deathDownAnimation_mc;					deathDownAnimation_mc.mouseChildren = false;					deathDownAnimation_mc.mouseEnabled = false;					hitarea_mc = _contentClip.hitarea_mc;										walkUpAnimation_mc.visible = false;					//rightAnimation_mc.visible = false;					walkDownAnimation_mc.visible = false;					//leftAnimation_mc.visible = false;					attackUpAnimation_mc.visible = false;					attackDownAnimation_mc.visible = false;					deathUpAnimation_mc.visible = false;					deathDownAnimation_mc.visible = false;										_walkUpAnimationClip = new AnimationDisplayObject();					_walkUpAnimationClip.contentClip = walkUpAnimation_mc;					_walkUpAnimationClip.init();					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_ENEMY_SMOOTHING) )					{						_walkUpAnimationClip.smoothing = false;					}										_walkDownAnimationClip = new AnimationDisplayObject();					_walkDownAnimationClip.contentClip = walkDownAnimation_mc;					_walkDownAnimationClip.init();					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_ENEMY_SMOOTHING) )					{						_walkDownAnimationClip.smoothing = false;					}										_attackUpAnimationClip = new AnimationDisplayObject();					_attackUpAnimationClip.contentClip = attackUpAnimation_mc;					_attackUpAnimationClip.init();					//_attackUpAnimationClip.addEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleAttackAnimationEvent, false, 0, true );					//_attackUpAnimationClip.addEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired, false, 0, true );					_attackUpAnimationClip.onAnimationEventFired.add( handleAttackAnimationEventFired );					_attackUpAnimationClip.onSoundEventFired.add( handleSoundEventFired );					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_ENEMY_SMOOTHING) )					{						_attackUpAnimationClip.smoothing = false;					}										_attackDownAnimationClip = new AnimationDisplayObject();					_attackDownAnimationClip.contentClip = attackDownAnimation_mc;					_attackDownAnimationClip.init();					//_attackDownAnimationClip.addEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleAttackAnimationEvent, false, 0, true );					//_attackDownAnimationClip.addEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired, false, 0, true );					_attackDownAnimationClip.onAnimationEventFired.add( handleAttackAnimationEventFired );					_attackDownAnimationClip.onSoundEventFired.add( handleSoundEventFired );					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_ENEMY_SMOOTHING) )					{						_attackDownAnimationClip.smoothing = false;					}										_deathUpAnimationClip = new AnimationDisplayObject();					_deathUpAnimationClip.contentClip = deathUpAnimation_mc;					_deathUpAnimationClip.init();					//_deathUpAnimationClip.addEventListener( BoogaEvent.ON_ANIMATION_ENDS, handleDeathAnimationEnded, false, 0, true );					//_deathUpAnimationClip.addEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired, false, 0, true );					_deathUpAnimationClip.onAnimationEnded.add( handleDeathAnimationEnded );					_deathUpAnimationClip.onSoundEventFired.add( handleSoundEventFired );					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_ENEMY_SMOOTHING) )					{						_deathUpAnimationClip.smoothing = false;					}										_deathDownAnimationClip = new AnimationDisplayObject();					_deathDownAnimationClip.contentClip = deathDownAnimation_mc;					_deathDownAnimationClip.init();					//_deathDownAnimationClip.addEventListener( BoogaEvent.ON_ANIMATION_ENDS, handleDeathAnimationEnded, false, 0, true );					//_deathDownAnimationClip.addEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired, false, 0, true );					_deathDownAnimationClip.onAnimationEnded.add( handleDeathAnimationEnded );					_deathDownAnimationClip.onSoundEventFired.add( handleSoundEventFired );					if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_ENEMY_SMOOTHING) )					{						_deathDownAnimationClip.smoothing = false;					}									}								public function get currentAnimationDisplayObject():AnimationDisplayObject { return _currentAnimationDisplayObject; }								public function set shadowDisplayObject( g:GameLevelDisplayObject ):void				{					_shadowDisplayObject = g;					//_shadowDisplayObject.x = _contentClip.x;					//_shadowDisplayObject.y = _contentClip.y;										render();				}				public function get shadowDisplayObject():GameLevelDisplayObject { return _shadowDisplayObject; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					//trace( "EnemyDisplayObject: init();" );										super.init();										_direction = -1;					_oldDirection = -1;					_oldAnimationDirection = -1;										_debug = true;										_nextMovementPoints = new Array();										_moving = false;					_attacking = false;					_hitByCurrentGod = false;					_hitBySpringTrapAnimation = false;										_toStringOutput = "";										_halfwayPoint = new Point();					_passedHalfwayPoint = false;										_targetPoint = new Point();										_inSpawnPath = false;										onRemovedFromGame = new Signal( EnemyDisplayObject );					onMovedToNextTile = new Signal( EnemyDisplayObject, GameboardTile );					onMovedToNextPoint = new Signal( EnemyDisplayObject );					onSpawnPathEnded = new Signal( EnemyDisplayObject );					onSpawnPathReentered = new Signal( EnemyDisplayObject );					onPathEnded = new Signal( EnemyDisplayObject );										//_attackTimer = new CustomTimer( _attackingGameObject.rateOfFire );					//_attackTimer.addEventListener( TimerEvent.TIMER, handleAttackTimerFired, false, 0, true );										//TESTING:					//this.buttonMode = true;					//this.addEventListener( MouseEvent.CLICK, handleClicked );				}				/*				function handleClicked( event:MouseEvent ):void				{					moveToNextTile();				}				*/			/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					/*					if( _moving )					{						_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );					}										if( _hitBySpringTrapAnimation )					{						_contentClip.removeEventListener( Event.ENTER_FRAME, handleDiedBySpringTrapEnterFrameAnimation );					}										_currentAnimationDisplayObject.pause();					*/					super.pause();				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					/*					if( _moving )					{						_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );					}										if( _hitBySpringTrapAnimation )					{						_contentClip.addEventListener( Event.ENTER_FRAME, handleDiedBySpringTrapEnterFrameAnimation, false, 0, true );					}										_currentAnimationDisplayObject.unpause();					*/					super.unpause();				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					if( _debug ) ConsoleBroadcaster.broadcast( toString(), "kill();" );										//TweenLite.killTweensOf( _contentClip );					//TweenLite.killTweensOf( _shadowDisplayObject.contentClip );										_needToBeUpdatedOnEnterFrame = false;										if( _moving )					{						//_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );						stopMoving();					}										if( _currentAnimationDisplayObject != null )					{						_currentAnimationDisplayObject.stopAnimation();						_currentAnimationDisplayObject = null;					}										if( _hitBySpringTrapAnimation )					{						//_contentClip.removeEventListener( Event.ENTER_FRAME, handleDiedBySpringTrapEnterFrameAnimation );					}										//_attackUpAnimationClip.removeEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleAttackAnimationEvent );					//_attackUpAnimationClip.removeEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired );					//_attackDownAnimationClip.removeEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleAttackAnimationEvent );					//_attackDownAnimationClip.removeEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired );					_attackUpAnimationClip.onAnimationEventFired.remove( handleAttackAnimationEventFired );					_attackUpAnimationClip.onSoundEventFired.remove( handleSoundEventFired );					_attackDownAnimationClip.onAnimationEventFired.remove( handleAttackAnimationEventFired );					_attackDownAnimationClip.onSoundEventFired.remove( handleSoundEventFired );										//_deathUpAnimationClip.removeEventListener( BoogaEvent.ON_ANIMATION_ENDS, handleDeathAnimationEnded );					//_deathUpAnimationClip.removeEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired );					//_deathDownAnimationClip.removeEventListener( BoogaEvent.ON_ANIMATION_ENDS, handleDeathAnimationEnded );					//_deathDownAnimationClip.removeEventListener( BoogaEvent.ON_SOUND_EVENT, handleSoundEventFired );					_deathUpAnimationClip.onAnimationEnded.remove( handleDeathAnimationEnded );					_deathUpAnimationClip.onSoundEventFired.remove( handleSoundEventFired );					_deathDownAnimationClip.onAnimationEnded.remove( handleDeathAnimationEnded );					_deathDownAnimationClip.onSoundEventFired.remove( handleSoundEventFired );										_walkUpAnimationClip.kill();					_walkDownAnimationClip.kill();					_attackUpAnimationClip.kill();					_attackDownAnimationClip.kill();					_deathUpAnimationClip.kill();					_deathDownAnimationClip.kill();										_contentClip = null;										if( _shadowDisplayObject != null )					{						_shadowDisplayObject.contentClip.stop();						_shadowDisplayObject = null;					}										onRemovedFromGame = null;					onMovedToNextTile = null;					onMovedToNextPoint = null;					onSpawnPathEnded = null;					onSpawnPathReentered = null;					onPathEnded = null;										super.kill();				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				override public function updateOnEnterFrame():void				{					if( _needToBeUpdatedOnEnterFrame )					{						if( !_slowedDown || (_slowedDown && (GameLevelDataIndex.getInstance().currentCounter & 1) == 0) )						{							if( _moving && !_pausedMoving )							{								handleEnterFrameMoving(null);							}														if( _hitBySpringTrapAnimation )							{								handleDiedBySpringTrapEnterFrameAnimation(null);							}														if( _currentAnimationDisplayObject != null )								_currentAnimationDisplayObject.showNextAnimation();						}					}				}							/** die			  *	---------------------------------------------------------------------------- */				override public function die():void				{					if( _debug ) ConsoleBroadcaster.broadcast( toString(), "die();" );										super.die();										_alive = false;										stopAttacking();					stopMoving();										//TweenLite.to( _contentClip, 1.5, {alpha:0, ease:Sine.easeOut} );					//TweenLite.to( _shadowDisplayObject.contentClip, 1.5, {alpha:0, ease:Sine.easeOut} );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.DIE) );										if( _attackingGameObject.deathUpAnimationObject || _attackingGameObject.deathDownAnimationObject )						showAnimation( _direction );					else						//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );						onRemovedFromGame.dispatch( this );									}							/** hit			  *	---------------------------------------------------------------------------- *			  *	Reduces the health of the game object. When the health reaches 0, the object			  *	dies.			  *	---------------------------------------------------------------------------- */				override public function hit( gameObject:AbstractGameObject, power:Number, oneHitKill:Boolean=false ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GameLevelAttackingDisplayObject", "hit("+gameObject.power+");" );										//trace( gameObject.attackProperties );										if( _alive )					{						if( oneHitKill )						{							//dispatchEvent( new GameLevelEvent(GameLevelEvent.HIT, {power:_attackingGameObject.health}) );							onHit.dispatch( this );														_attackingGameObject.health = 0;							die();						}						else						{							//get the element's property							if( !(gameObject is God) )							{								var element:ElementCompatibility = GameLevelUtil.checkForElement( gameObject );																//trace( "element: "+element );								if( element != null )								{									//trace( _attackingGameObject.attackProperties );									//trace( "strongAgainst: "+element.strongAgainst );									//trace( "weakAgainst: "+element.weakAgainst );									if( _attackingGameObject.hasAttackProperty(element.weakAgainst) )									{										power = 0;									}									else if( _attackingGameObject.hasAttackProperty(element.strongAgainst) )									{										//trace( '_attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_WEAK_AGAINST_ENCHANTED_INDEX): '+_attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_WEAK_AGAINST_ENCHANTED_INDEX) );										power = power * element.strongPowerMultiplier;									}								}																//trace( "power: "+power );							}														_attackingGameObject.health -= power;							//trace( _attackingGameObject+" health: "+_attackingGameObject.health );														//dispatchEvent( new GameLevelEvent(GameLevelEvent.HIT, {power:power}) );							onHit.dispatch( this );														if( _attackingGameObject.health <= 0 )							{								die();							}							else if( power > 0 )							{								if( gameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_POISON_INDEX) )								{									//trace( "POISONED !!!" );									poison( gameObject.additionalAttackValue*1000 );								}								else if( gameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ICE_INDEX) )								{									//trace( "SLOWED DOWN !!!" );									slowDown( gameObject.additionalAttackValue*1000 );								}								else								{									//startHitColorChangeTimer();								}								startHitColorChangeTimer();							}						}					}				}							/** hitBySpringTrap			  *	---------------------------------------------------------------------------- *			  *	When enemies get hit by the spring trap, they will be flung up.			  *	---------------------------------------------------------------------------- */				public function hitBySpringTrap():void				{					//trace( "hitBySpringTrap" );										_alive = false;										stopAttacking();					stopMoving();										_hitBySpringTrapAnimation = true;										_targetPoint.x = this.x;					_targetPoint.y = MainGameDataIndex.getInstance().outOfBoundsRectangle.y - 100;					_targetAltitude = -800;										onDied.dispatch( this );				}							/** placedOnBoard			  *	---------------------------------------------------------------------------- *			  *	Called when EnemyDisplayObject gets added to the stage.			  *	Each weapon type is going to do different things ( either going to just stay			  *	static or actually going to start animating ).			  *	---------------------------------------------------------------------------- */				public function placedOnBoard( customPosition:Boolean=false ):void				{					if( _inSpawnPath )					{						this.currentIndexInPath = 0;					}					else					{						if( customPosition )						{							//if( _positionIn2D == null ) _positionIn2D = new Point();							//_positionIn2D.x = _currentPath[_currentIndexInPath].positionIn2D.x;							//_positionIn2D.y = _currentPath[_currentIndexInPath].positionIn2D.y;						}						else						{							this.currentIndexInPath = 0;						}					}										render();										startMoving();				}							/** render			  *	---------------------------------------------------------------------------- */				override public function render():void				{					if( this._positionIn2D != null )					{						//trace( "this._inIsometricView: "+this._inIsometricView );						//trace( "this._positionIn2D: "+this._positionIn2D );												if( this._inIsometricView )						{							var positionInIsometric:Point = GameLevelUtil.getPositionInIsometric( _positionIn2D, _altitude );							_contentClip.x = positionInIsometric.x;							_contentClip.y = positionInIsometric.y;							//_contentClip.x = Math.round((this._positionIn2D.x * _isometricMatrix[0][0]) + (this._positionIn2D.y * _isometricMatrix[1][0]));							//_contentClip.y = Math.round((this._positionIn2D.x * _isometricMatrix[0][1]) + (this._positionIn2D.y * _isometricMatrix[1][1])) + (_altitude * _isometricMatrix[2][1]);														if( _shadowDisplayObject != null && SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_SHADOW) )							{								positionInIsometric = GameLevelUtil.getPositionInIsometric( _positionIn2D, 0 );								_shadowDisplayObject.x = positionInIsometric.x;								_shadowDisplayObject.y = positionInIsometric.y;								//_shadowDisplayObject.x = _contentClip.x;								//_shadowDisplayObject.y = Math.round((this._positionIn2D.x * _isometricMatrix[0][1]) + (this._positionIn2D.y * _isometricMatrix[1][1]));							}						}						else						{							_contentClip.x = this._positionIn2D.x;							_contentClip.y = this._positionIn2D.y;														if( _shadowDisplayObject != null && SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_SHADOW) )							{								_shadowDisplayObject.x = _contentClip.x;								_shadowDisplayObject.y = _contentClip.y;							}						}											}				}							/** startMoving			  *	---------------------------------------------------------------------------- *			  *	Starts the animation of the enemy moving across the level			  *	---------------------------------------------------------------------------- */				public function startMoving():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "startMoving();" );					//trace( "startMoving();" );										if( !_moving && _currentPath != null )					{						//trace( "_currentIndexInpath: "+_currentIndexInPath );						//trace( "_currentTile: "+_currentTile );						//this.currentIndexInPath = 0;						//_moving = true;												showAnimation( _direction );												moveToNextTile();												_moving = true;					}				}							/** continueMoving			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function continueMoving():void				{					//trace( "continueMoving();" );										if( _moving && _pausedMoving )					{						//_moving = true;						_pausedMoving = false;						showAnimation( _direction );						//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );						//moveToNextPoint();					}				}							/** stopMoving			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function stopMoving():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "stopMoving();" );					//trace( "stopMoving();" );										if( _moving && !_pausedMoving )					{						//_moving = false;						_pausedMoving = true;						//_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );					}				}							/** slowDown			  *	---------------------------------------------------------------------------- */				override public function slowDown( duration:Number ):void				{					super.slowDown( duration );										_currentSpeed = _attackingGameObject.speed * .5;				}							/** handleSlowedDownTimerCompleted			  *	---------------------------------------------------------------------------- */				override protected function handleSlowedDownTimerCompleted( timer:CustomTimer ):void				{					super.handleSlowedDownTimerCompleted( timer );										_currentSpeed = _attackingGameObject.speed;				}							/** moveToNextTile			  *	---------------------------------------------------------------------------- *			  *	This function is part of the enemy animation. It makes the enemy moves to			  *	next tile on its path.			  *	---------------------------------------------------------------------------- */				protected function moveToNextTile():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "moveToNextTile();" );										//trace( "_direction: "+_direction );					//trace( "_currentIndexInPath: "+_currentIndexInPath );					//trace( "_currentPathLength: "+_currentPathLength );										if( _currentIndexInPath < _currentPathLength )					{						if( _currentTile != null )						{							//trace( "move clip from layer "+_currentTile.layerNumber );						}						_currentTile = _currentPath[_currentIndexInPath];												//trace( "move clip to layer "+_currentTile.layerNumber );												//trace( "_currentIndexInPath: "+_currentIndexInPath );						//trace( "_currentTile: "+_currentTile );						//trace( "_currentTile.weaponsWatching: "+_currentTile.weaponsWatching );												//++_currentIndexInPath;												//TODO:						//	It seems there is a bug in here somewhere... double check this later						//if( _currentIndexInPath < _currentPathLength-1 )							//_targetTile = _currentPath[_currentIndexInPath+1];						//else							//_targetTile = _currentPath[_currentIndexInPath];													//trace( "_targetTile.occupiedByWeapon: "+_targetTile.occupiedByWeapon );												//_oldDirection = _direction;						//this.currentIndexInPath += 1;						//trace( "direction: "+_direction );						var tileBound:Rectangle = _currentTile.getTileBound();						//trace( "tileBound: "+tileBound );						//trace( "_direction: "+_direction );						//trace( "_oldDirection: "+_oldDirection );						//trace( "_targetTile.getTileBound(): "+_targetTile.getTileBound() );												//TODO:						//	Change the target point to be the edge of the tile instead of just the middle of the tile												if( _oldDirection != _direction )						{							//trace( "change of direction" );							showAnimation( _oldDirection <= 0 ? _direction : _oldDirection );							_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y;														//trace( "_targetPoint: "+_targetPoint );							//trace( "next halfway point "+_halfwayPoint );														//_oldDirection = _direction;						}						else						{							//trace( "_passedHalfwayPoint is false" );														showAnimation( _direction );							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y + tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.bottom );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y - tileBound.height*0.5;							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x - tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x + tileBound.width*0.5;								_halfwayPoint.y = _targetPoint.y;							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y;							}														//trace( "next halfway point "+_halfwayPoint );						}												//_moving = true;												//trace( "_targetPoint: "+_targetPoint );						//trace( "_halfwayPoint: "+_halfwayPoint );						//trace( "_currentTile: "+_currentTile );												//_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );												//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );						//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_TILE, {tile:_currentTile}) );						onMovedToNextTile.dispatch( this, _currentTile );											}					else					{						/*						trace( "PATH ENDS!!!" );						//_atEndOfPath = true;						_moving = false;												_currentTile = _path[_currentIndexInPath];						//trace( _currentTile );												dispatchEvent( new GameLevelEvent(GameLevelEvent.PATH_END) );						*/						//TODO;						//	Path ends, attack the gate or the village now!					}				}							/** handleEnterFrameMoving			  *	---------------------------------------------------------------------------- *			  *	Moves this along the assigned path			  *	---------------------------------------------------------------------------- */				protected function handleEnterFrameMoving( event:Event ):void				{					//trace( "handleEnterFrameMoving();" );					//trace( "_positionIn2D.x: "+_positionIn2D.x+", _positionIn2D.y: "+_positionIn2D.y );					//trace( "_targetPoint.x: "+_targetPoint.x+", _targetPoint.y: "+_targetPoint.y );					//trace( this.visible );					//trace( "_moving: "+_moving );										//trace( "_overshootY: "+_overshootY );										if( _overshootX || _overshootY )					{						//trace( "_overshootX: "+_overshootX );						//trace( "_overshootY: "+_overshootY );						//trace( "_oldDirection: "+_oldDirection );						//trace( "_direction: "+_direction );												if( _oldDirection == _direction )						{							_overshootX = false;							_overshootY = false;														//_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );														if( _reversed || _pushedBack )							{								if( _currentIndexInPath > 0 )								{									_oldDirection = _direction;									this.currentIndexInPath -= 1;									_passedHalfwayPoint = false;									moveToNextTile();								}								else								{									if( !_inSpawnPath )									{										_inSpawnPath = true;										_moving = false;																				_currentPath = _spawnPath;										_currentPathLength = _spawnPathLength;																				_currentTile = _currentPath[_spawnPathLength-1];										this.currentIndexInPath = _spawnPathLength-1;																				onSpawnPathReentered.dispatch( this );									}									else									{										//stopMoving();																				if( _reversed )											this.reversed = false;										else if( _pushedBack )											this.pushedBack = false;									}								}							}							else							{								if( _currentIndexInPath < _currentPathLength-1 )								{									_oldDirection = _direction;									//trace( "increasing currentIndexInPath by 1" );																		this.currentIndexInPath += 1;																		_passedHalfwayPoint = false;									moveToNextTile();								}								else								{									if( _inSpawnPath )									{										_currentPath = _path;										_currentPathLength = _pathLength;																				_inSpawnPath = false;										_moving = false;																				_currentTile = _currentPath[0];										this.currentIndexInPath = 0;																				//trace( "_currentTile: "+_currentTile );										//trace( "_direction: "+_direction );																				//dispatchEvent( new GameLevelEvent(GameLevelEvent.SPAWN_PATH_END) );										onSpawnPathEnded.dispatch( this );																				//moveToNextTile();									}									else									{										//dispatchEvent( new GameLevelEvent(GameLevelEvent.PATH_END) );										onPathEnded.dispatch( this );									}								}							}						}						else						{							_overshootX = false;							_overshootY = false;														var tileBound:Rectangle = _currentTile.getTileBound();							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top );							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.bottom );							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height*0.5 );							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height*0.5 );							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width*0.5, tileBound.top+tileBound.height*0.5 );							}														//trace( "_targetPoint: "+_targetPoint );														_oldDirection = _direction;														_passedHalfwayPoint = false;														showAnimation( _direction );														//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_TILE, {tile:_currentTile}) );														onMovedToNextTile.dispatch( this, _currentTile );						}					}					else					{						moveToNextPoint();					}				}							/** moveToNextPoint			  *	---------------------------------------------------------------------------- *			  *	Moves the display object to the next target point			  *	---------------------------------------------------------------------------- */				protected function moveToNextPoint():void				{					//trace( "moveToNextPoint();" );					var moveX:Number = _targetPoint.x - _positionIn2D.x;					var moveY:Number = _targetPoint.y - _positionIn2D.y;					//if( Math.abs(moveX)										var nextMoveX:Number;					var nextMoveY:Number;					var moveXNegative:Boolean;					var moveYNegative:Boolean;										if( moveX != 0 )					{						_overshootX = (moveX < 0 ? -moveX : moveX) < _currentSpeed;												moveXNegative = moveX < 0;						moveX = (moveX < 0 ? -moveX : moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveX;												_positionIn2D.x += moveX;						//this.x = _positionIn2D.x;												//x = Math.round( (moveXNegative ? -_threat.speed : threat.speed) + x );					}										if( moveY != 0 )					{						_overshootY = (moveY < 0 ? -moveY : moveY) < _currentSpeed;												moveYNegative = moveY < 0;												moveY = (moveY < 0 ? -moveY : moveY) > _currentSpeed ? (moveYNegative ? -_currentSpeed : _currentSpeed) : moveY;												_positionIn2D.y += moveY;						//this.y = _positionIn2D.y;												//y = Math.round( (moveYNegative ? -_threat.speed : threat.speed) + y );					}										//trace( "_currentSpeed: "+_currentSpeed );					//trace( "moveX: "+moveX );					//trace( "moveY: "+moveY );					//trace( "_overshootX: "+_overshootX );					//trace( "_overshootY: "+_overshootY );					/*					if( _overshootX )					{						nextMoveX = 0;					}					else					{						nextMoveX = _targetPoint.x - _positionIn2D.x;												moveXNegative = moveX < 0;						nextMoveX = Math.abs(moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveX;					}										if( _overshootY )					{						nextMoveY = 0;					}					else					{						nextMoveY = _targetPoint.y - _positionIn2D.y;												moveYNegative = moveY < 0;						nextMoveY = Math.abs(moveY) > _currentSpeed ? (moveYNegative ? -_currentSpeed : _currentSpeed) : moveY;					}										_nextMovementPoints[0] = new Point( _positionIn2D.x+nextMoveX, _positionIn2D.y+nextMoveY );										if( _overshootX )					{						nextMoveX = 0;					}					else					{						nextMoveX = _targetPoint.x - _nextMovementPoints[0].x;												moveXNegative = moveX < 0;						nextMoveX = Math.abs(moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveY;					}										if( _overshootY )					{						nextMoveY = 0;					}					else					{						nextMoveY = _targetPoint.x - _nextMovementPoints[0].y;												moveYNegative = moveY < 0;						nextMoveY = Math.abs(moveY) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveY;					}										_nextMovementPoints[1] = new Point( _nextMovementPoints[0].x+nextMoveX, _nextMovementPoints[0].y+nextMoveY );					*/					if( moveX == 0 && moveY == 0 )					{						_overshootX = true;						_overshootY = true;					}										if( !_passedHalfwayPoint )					{						switch( _direction )						{							case GameLevelUtil.DIRECTION_UP:								if( _positionIn2D.y < _halfwayPoint.y )									_passedHalfwayPoint = true;								break;														case GameLevelUtil.DIRECTION_RIGHT:								if( _positionIn2D.x > _halfwayPoint.x )									_passedHalfwayPoint = true;								break;															case GameLevelUtil.DIRECTION_DOWN:								if( _positionIn2D.y > _halfwayPoint.y )									_passedHalfwayPoint = true;								break;														case GameLevelUtil.DIRECTION_LEFT:								if( _positionIn2D.x < _halfwayPoint.x )									_passedHalfwayPoint = true;								break;						}					}										//trace( "_positionIn2D: "+_positionIn2D );										if( !_inSpawnPath )						//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_POINT) );						onMovedToNextPoint.dispatch( this );										//if( !_slowedDown || (_slowedDown && (GameLevelDataIndex.getInstance().currentCounter & 1) == 0) )						render();				}							/** attackTargets			  *	---------------------------------------------------------------------------- *			  *	See if this object can attack one of the targets that are given.			  *	It always attacks the closest target.			  *	The enemy stops when it finds a target to attack.			  *	---------------------------------------------------------------------------- 				override public function attackTargets( targets:Vector.<GameLevelAttackingDisplayObject> ):GameLevelAttackingDisplayObject				{					//stopMoving();										//var target:GameLevelAttackingDisplayObject = super.attackTargets( targets );					if( _attackedTarget == null )					{						super.attackTargets( targets );												//ConsoleBroadcaster.broadcast( toString(), "_attackedTarget: "+_attackedTarget );												if( _attackedTarget != null )						{							stopMoving();							showAnimation( _direction );							return _attackedTarget;						}					}										return null;				}*/							/** startAttackAnimation			  *	---------------------------------------------------------------------------- *			  *	Shows the attack animation of the displayObject. You can also do anything			  *	extra when it attacks. Separating this from attackTargets function so that			  *	extended classes can just override this function instead of overriding that 			  *	function.			  *	---------------------------------------------------------------------------- */				override public function startAttackAnimation():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "startAttackAnimation();" );										if( _attackedTarget != null )					{						if( _attackTimer == null )						{							_attackTimer = new CustomTimer( 1000 * _attackingGameObject.rateOfFire );							//_attackTimer.addEventListener( TimerEvent.TIMER, handleAttackTimerFired, false, 0, true );							_attackTimer.onTimerFired.add( handleAttackTimerFired );														if( _slowedDown )							{								_attackTimer.multiplier = 2;							}						}												_attacking = true;						_attackTimer.start();												stopMoving();						showAnimation( _direction );					}				}							/** canAttackTarget			  *	---------------------------------------------------------------------------- *			  *	Check to see if this object can attack the target. Override this function			  *	in the attacking object as the requirement is different for reach one.			  *	---------------------------------------------------------------------------- */				override protected function canAttackTarget( target:GameLevelDisplayObject ):Boolean				{					if( _reversed || _pushedBack )						return false;										if( target.ignoredByEnemy )						return false;										if( target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SPRING_TRAP_INDEX) || target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_TRAP_INDEX) )						return false;										var range:Number = _attackingGameObject.range * 90;						range = range * range;										var distance:Number = (_positionIn2D.x - target.positionIn2D.x) * (_positionIn2D.x - target.positionIn2D.x);						distance += (_positionIn2D.y - target.positionIn2D.y) * (_positionIn2D.y - target.positionIn2D.y);										if( distance > range )						return false;										return true;				}							/** showAnimation			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	public function showAnimation( direction:int ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "showAnimation("+direction+");" );										//TODO:					//	Right now the animation is staggering when enemy is moving between tiles.					//	Need to change it so that it doesn't do that !!!!										//trace( "_attacking: "+_attacking );					//trace( "_alive: "+_alive );					//trace( "_moving: "+_moving );					//trace( "_oldDirection: "+_oldDirection );					//trace( "direction: "+direction );										if( direction != _oldDirection && _oldDirection >= 0 )						direction = _oldDirection;										var newAnimationDisplayObject:AnimationDisplayObject;					/*					switch( direction )					{						case GameLevelUtil.DIRECTION_UP:							newAnimationDisplayObject = _attackUpAnimationClip;							break;												case GameLevelUtil.DIRECTION_RIGHT:							newAnimationDisplayObject = _attackUpAnimationClip;							break;												case GameLevelUtil.DIRECTION_DOWN:							newAnimationDisplayObject = _attackDownAnimationClip;							break;												case GameLevelUtil.DIRECTION_LEFT:							newAnimationDisplayObject = _attackDownAnimationClip;							break;					}										if( _currentAnimationDisplayObject != null && newAnimationDisplayObject != _currentAnimationDisplayObject )					{						_currentAnimationDisplayObject.stopAnimation();						_currentAnimationDisplayObject.visible = false;					}					*/										if( _attacking )					{						_oldAnimationDirection = -1;												switch( direction )						{							case GameLevelUtil.DIRECTION_UP:								_attackUpAnimationClip.initCanvas( false );								newAnimationDisplayObject = _attackUpAnimationClip;								//_attackUpAnimationClip.startAnimation( true, 0 );								//_attackUpAnimationClip.visible = true;								break;														case GameLevelUtil.DIRECTION_RIGHT:								_attackUpAnimationClip.initCanvas( true );								newAnimationDisplayObject = _attackUpAnimationClip;								//_attackUpAnimationClip.startAnimation( true, 0 );								//_attackUpAnimationClip.visible = true;								break;														case GameLevelUtil.DIRECTION_DOWN:								_attackDownAnimationClip.initCanvas( false );								newAnimationDisplayObject = _attackDownAnimationClip;								//_attackDownAnimationClip.startAnimation( true, 0 );								//_attackDownAnimationClip.visible = true;								break;														case GameLevelUtil.DIRECTION_LEFT:								_attackDownAnimationClip.initCanvas( true );								newAnimationDisplayObject = _attackDownAnimationClip;								//_attackDownAnimationClip.startAnimation( true, 0 );								//_attackDownAnimationClip.visible = true;								break;						}												//if( newAnimationDisplayObject != _currentAnimationDisplayObject )						//{							if( _currentAnimationDisplayObject != null )							{								_currentAnimationDisplayObject.stopAnimation();								_currentAnimationDisplayObject.contentClip.visible = false;							}														_currentAnimationDisplayObject = newAnimationDisplayObject;							_currentAnimationDisplayObject.startAnimation( false, 0 );							_currentAnimationDisplayObject.contentClip.visible = true;						//}											}					else if( !_alive )					{						_oldAnimationDirection = -1;												switch( direction )						{							case GameLevelUtil.DIRECTION_UP:								_deathUpAnimationClip.initCanvas( false );								newAnimationDisplayObject = _deathUpAnimationClip;								break;														case GameLevelUtil.DIRECTION_RIGHT:								_deathUpAnimationClip.initCanvas( true );								newAnimationDisplayObject = _deathUpAnimationClip;								break;														case GameLevelUtil.DIRECTION_DOWN:								_deathDownAnimationClip.initCanvas( false );								newAnimationDisplayObject = _deathDownAnimationClip;								break;														case GameLevelUtil.DIRECTION_LEFT:								_deathDownAnimationClip.initCanvas( true );								newAnimationDisplayObject = _deathDownAnimationClip;								break;						}												//if( newAnimationDisplayObject != _currentAnimationDisplayObject )						//{							if( _currentAnimationDisplayObject != null )							{								_currentAnimationDisplayObject.stopAnimation();								_currentAnimationDisplayObject.contentClip.visible = false;							}														_currentAnimationDisplayObject = newAnimationDisplayObject;							_currentAnimationDisplayObject.startAnimation( false, 0 );							_currentAnimationDisplayObject.contentClip.visible = true;						//}											}					else// if( this._alive )					{						if( _oldAnimationDirection != direction )						{							_oldAnimationDirection = direction;														if( _currentAnimationDisplayObject != null )							{								_currentAnimationDisplayObject.stopAnimation();								_currentAnimationDisplayObject.contentClip.visible = false;							}														switch( direction )							{								case GameLevelUtil.DIRECTION_UP:									if( _pushedBack )									{										_walkDownAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkDownAnimationClip;									}									else									{										_walkUpAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkUpAnimationClip;									}									//_walkUpAnimationClip.startAnimation( true, 0 );									//_walkUpAnimationClip.visible = true;									break;																case GameLevelUtil.DIRECTION_RIGHT:									if( _pushedBack )									{										_walkDownAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkDownAnimationClip;									}									else									{										_walkUpAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkUpAnimationClip;									}									//_walkUpAnimationClip.startAnimation( true, 0 );									//walkUpAnimation_mc.visible = true;									break;																case GameLevelUtil.DIRECTION_DOWN:									if( _pushedBack )									{										_walkUpAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkUpAnimationClip;									}									else									{										_walkDownAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkDownAnimationClip;									}									//_walkDownAnimationClip.startAnimation( true, 0 );									//_walkDownAnimationClip.visible = true;									break;																case GameLevelUtil.DIRECTION_LEFT:									if( _pushedBack )									{										_walkUpAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkUpAnimationClip;									}									else									{										_walkDownAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkDownAnimationClip;									}									//_walkDownAnimationClip.startAnimation( true, 0 );									//_walkDownAnimationClip.visible = true;									break;							}														//trace( "newAnimationDisplayObject: "+newAnimationDisplayObject );							//trace( "not equal ? "+(_currentAnimationDisplayObject != newAnimationDisplayObject) );														//if( newAnimationDisplayObject != _currentAnimationDisplayObject )							//{																_currentAnimationDisplayObject = newAnimationDisplayObject;								_currentAnimationDisplayObject.startAnimation( true, 0 );								_currentAnimationDisplayObject.contentClip.visible = true;							//}														//trace( "_currentAnimationDisplayObject: "+_currentAnimationDisplayObject.contentClip.name );						}					}				}							/** handleDiedBySpringTrapEnterFrameAnimation			  *	---------------------------------------------------------------------------- *			  *	This is EnterFrame function when enemies get flung out.			  *	---------------------------------------------------------------------------- */				protected function handleDiedBySpringTrapEnterFrameAnimation( event:Event ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "handleDiedBySpringTrapEnterFrameAnimation();" );										//_contentClip.y -= 10;					_altitude -= 30;										//if( !_slowedDown || (_slowedDown && (GameLevelDataIndex.getInstance().currentCounter & 1) == 0) )						render();										//trace( "_contentClip.y "+_contentClip)										if( _altitude < _targetAltitude )					{						//trace( " ********* REMOVE ENEMY after spring trap animation done" );						//_contentClip.removeEventListener( Event.ENTER_FRAME, handleDiedBySpringTrapEnterFrameAnimation );												//TweenLite.to( _contentClip, 1.5, {alpha:0, ease:Sine.easeOut} );						//TweenLite.to( _shadowDisplayObject.contentClip, 1.5, {alpha:0, ease:Sine.easeOut} );												//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );						onRemovedFromGame.dispatch( this );					}				}											/**	******************************************* *			  * AnimationDisplayObject Events			  *	******************************************* */			 				/** handleAttackAnimationEvent			  *	---------------------------------------------------------------------------- */				//protected function handleAttackAnimationEvent( event:BoogaEvent ):void				protected function handleAttackAnimationEventFired():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "handleAttackAnimationEvent();" );										//trace( "_attackedTarget: "+_attackedTarget );										if( _alive && _attackedTarget != null )					{						_attackedTarget.hit( _attackingGameObject, _attackingGameObject.power );						_attackedTarget = null;					}				}				/*				protected function handleAnimationTimerFired( event:CustomEvent ):void				{					trace( "_tileIndex: "+_attackUpAnimationClip.tileIndex );				}				*/			/** handleDeathAnimationEvent			  *	---------------------------------------------------------------------------- 				protected function handleDeathAnimationEvent( event:CustomEvent ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( toString(), "handleDeathAnimationEvent();" );										dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );				}*/							/** handleSoundEventFired			  *	---------------------------------------------------------------------------- */				//protected function handleSoundEventFired( event:BoogaEvent ):void				protected function handleSoundEventFired( soundDataId:int ):void				{					//trace( "handleSoundEventFired();" );					//trace( "sound id that should play "+event.customParameters.soundDataId );										var soundData:SoundData = SoundsIndex.getInstance().getSoundById(soundDataId);					SoundEffectPlayer.getInstance().playLibrarySound( soundData.soundId, false, _contentClip.name, soundData.soundId );					soundData = null;				}							/** handleDeathAnimationEnded			  *	---------------------------------------------------------------------------- */				//protected function handleDeathAnimationEnded( event:BoogaEvent ):void				protected function handleDeathAnimationEnded( animationDisplayObject:AnimationDisplayObject ):void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "handleDeathAnimationEnded();" );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );					onRemovedFromGame.dispatch( this );				}							/** toString			  *	---------------------------------------------------------------------------- */				override public function toString():String				{					if( _toStringOutput == "" )					{						//trace( "name : "+StringsIndex.getInstance().getString(String(_attackingGameObject.name)) );						_toStringOutput = StringsIndex.getInstance().getString(String(_attackingGameObject.name)).replace(/[\s*]/g, "_")+"_"+_currentTile.row+"_"+_currentTile.column;					}										return _toStringOutput;				}								override public function clone():*				{					var clonedObject:EnemyDisplayObject = UtilFunctions.clone(this) as EnemyDisplayObject;						clonedObject.attackingGameObject = _attackingGameObject;										trace( "clonedObject.attackingGameObject: "+clonedObject.attackingGameObject );										return clonedObject;				}		}			}