/** JumpingEnemyDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Enemy class.  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel.enemies	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.events.Event;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.events.MouseEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.events.TimerEvent;		import flash.utils.getDefinitionByName;				import com.greensock.TweenLite;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.cache.BitmapDataManager;				import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.GameLevelDataIndex;		import com.boogabooga.events.BoogaEvent;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.AnimationDisplayObject;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.ui.gamelevel.GateDisplayObject;		import com.boogabooga.ui.gamelevel.enemies.EnemyDisplayObject;		import com.boogabooga.utils.GameLevelUtil;				public class JumpingEnemyDisplayObject extends EnemyDisplayObject		{			protected var _moveX:Number;			protected var _moveY:Number;			protected var _holdMovementTimer:CustomTimer;			//protected var _checkEnemyTimer:CustomTimer;						private var _reversedWhileJumping:Boolean;						protected var _movingAfterWalkAnimationEvent:Boolean;						/**	Stage Instances **/			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function JumpingEnemyDisplayObject()				{									}								override public function set reversed( b:Boolean ):void				{					if( _reversed != b )					{						_reversed = b;												//trace( "_direction before reversed: "+_direction );						//trace( "_pausedMoving: "+_pausedMoving );												reverseMovement();					}				}								override public function set pushedBack( b:Boolean ):void				{					if( _pushedBack != b )					{						_pushedBack = b;												//trace( "_direction before pushedBack: "+_direction );												if( _holdMovementTimer != null )						{							if( _pushedBack )								_holdMovementTimer.multiplier = .25;							else								_holdMovementTimer.multiplier = 1;						}												reverseMovement();					}				}								protected function reverseMovement():void				{					if( _attacking )					{						//this.currentIndexInPath = _currentIndexInPath;						stopAttacking();						landOnTargetPoint();					}					else if( _holdMovementTimer != null && !_holdMovementTimer.isRunning )					{						//trace( "reversed while jumping" );						_reversedWhileJumping = true;						//this.currentIndexInPath = _currentIndexInPath;					}					/*					else					{						//_reversedWhileJumping = true;						if( _reversed )							this.currentIndexInPath = _currentIndexInPath;						else							this.currentIndexInPath = _currentIndexInPath;					}					*/										this.currentIndexInPath = _currentIndexInPath;										//trace( "_currentIndexInPath: "+_currentIndexInPath );										_oldDirection = _direction;					//trace( "_direction: "+_direction );										var tileBound:Rectangle = _currentTile.getTileBound();					//trace( "tileBound: "+tileBound );					//trace( "_direction: "+_direction );					//trace( "_oldDirection: "+_oldDirection );					//trace( "_targetTile.getTileBound(): "+_targetTile.getTileBound() );										/*if( false )					{						//trace( "change of direction" );						showAnimation( _oldDirection <= 0 ? _direction : _oldDirection );						_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );						_halfwayPoint.x = _targetPoint.x;						_halfwayPoint.y = _targetPoint.y;												//trace( "next halfway point "+_halfwayPoint );												//_oldDirection = _direction;					}					else					{					}*/										//trace( "_pausedMoving: "+_pausedMoving );										if( _holdMovementTimer != null && _holdMovementTimer.isRunning )					{						stopHoldMovementTimer();												//trace( "_passedHalfwayPoint is false" );						//trace( "setting new target point" );												showAnimation( _direction );						if( _direction == GameLevelUtil.DIRECTION_UP )						{							_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y + tileBound.height/2;						}						else if( _direction == GameLevelUtil.DIRECTION_DOWN )						{							_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.bottom );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y - tileBound.height/2;						}						else if( _direction == GameLevelUtil.DIRECTION_RIGHT )						{							_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height/2 );							_halfwayPoint.x = _targetPoint.x - tileBound.width/2;							_halfwayPoint.y = _targetPoint.y;						}						else if( _direction == GameLevelUtil.DIRECTION_LEFT )						{							_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height/2 );							_halfwayPoint.x = _targetPoint.x + tileBound.width/2;							_halfwayPoint.y = _targetPoint.y;						}						else						{							_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y;						}												//trace( "next halfway point "+_halfwayPoint );												startHoldMovementTimer();					}										//trace( "_targetPoint: "+_targetPoint );					//trace( "_halfwayPoint: "+_halfwayPoint );									}							/** set/get contentClip			  *	---------------------------------------------------------------------------- */				override public function set contentClip( m:MovieClip ):void				{					super.contentClip = m;										//_walkUpAnimationClip.addEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleWalkAnimationEvent, false, 0, true );					//_walkDownAnimationClip.addEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleWalkAnimationEvent, false, 0, true );					_walkUpAnimationClip.onAnimationEventFired.add( handleWalkAnimationEventFired );					_walkDownAnimationClip.onAnimationEventFired.add( handleWalkAnimationEventFired );				}							/** set currentIndexInPath			  *	---------------------------------------------------------------------------- *			  *	For enemy, the directions they are facing is the other way since they are			  *	travelling from the end of the path.			  *	---------------------------------------------------------------------------- 				override public function set currentIndexInPath( i:int ):void				{					_currentIndexInPath = i;										//trace( "setting currentIndexInpath to "+i );										//TODO:					//	There might be a bug with the initial direction, keep an eye on this!!!!										if( _currentIndexInPath == 0 )						_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath+1], true );					else if( _currentIndexInPath == _currentPathLength-1 )						_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath-1], _currentPath[_currentIndexInPath] );					else						_direction = GameLevelUtil.directionFromTileAToTileB( _currentPath[_currentIndexInPath], _currentPath[_currentIndexInPath+1] );										if( _inSpawnPath && _currentIndexInPath == _currentPath.length-1 )					{						//trace( "_currentTile: "+_currentTile );						//trace( "_path[0]: "+_path[0] );						_direction = GameLevelUtil.directionFromTileAToTileB( _path[0], _currentTile );						//trace( "_direction on last spawn tile is "+_direction );					}										//if( _direction != _oldDirection )					//{						//showAnimation();					//}										if( _oldDirection < 0 )						_oldDirection = _direction;				}*/							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_movingAfterWalkAnimationEvent = false;				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					//trace( "_moving: "+_moving );					//trace( "_attacking: "+_attacking );					//trace( "_holdMovementTimer.isRunning: "+_holdMovementTimer.isRunning );										if( _holdMovementTimer != null && _holdMovementTimer.isRunning )					{						_holdMovementTimer.pause();					}										super.pause();				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					super.unpause();										if( _holdMovementTimer != null && _holdMovementTimer.isRunning )					{						_holdMovementTimer.unpause();					}									}							/** die			  *	---------------------------------------------------------------------------- */				override public function die():void				{					stopHoldMovementTimer();										super.die();				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					_needToBeUpdatedOnEnterFrame = false;										stopHoldMovementTimer();										if( _holdMovementTimer != null )					{						_holdMovementTimer.onTimerCompleted.remove( handleHoldMovementTimerCompleted );						_holdMovementTimer.kill();						_holdMovementTimer = null;					}										//_walkUpAnimationClip.removeEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleWalkAnimationEvent );					//_walkDownAnimationClip.removeEventListener( BoogaEvent.ON_ANIMATION_EVENT, handleWalkAnimationEvent );					_walkUpAnimationClip.onAnimationEventFired.remove( handleWalkAnimationEventFired );					_walkDownAnimationClip.onAnimationEventFired.remove( handleWalkAnimationEventFired );										super.kill();				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				override public function updateOnEnterFrame():void				{					//super.updateOnEnterFrame();					/*					if( _needToBeUpdatedOnEnterFrame )					{						if( _moving )						{							handleEnterFrameMoving(null);						}												if( _hitBySpringTrapAnimation )						{							handleDiedBySpringTrapEnterFrameAnimation(null);						}												if( _currentAnimationDisplayObject != null )							_currentAnimationDisplayObject.showNextAnimation();					}					*/					if( _needToBeUpdatedOnEnterFrame )					{						//trace( "updateOnEnterFrame();" );						if( !_slowedDown || (_slowedDown && (GameLevelDataIndex.getInstance().currentCounter & 1) == 0) )						{							if( !_inSpawnPath && _holdMovementTimer.isRunning )								handleCheckForTargets(null);														if( _currentAnimationDisplayObject != null )							{								//trace( "running ? : "+_currentAnimationDisplayObject.running );								_currentAnimationDisplayObject.showNextAnimation();							}														//trace( "_movingAfterWalkAnimationEvent: "+_movingAfterWalkAnimationEvent );														if( _hitBySpringTrapAnimation )							{								handleDiedBySpringTrapEnterFrameAnimation(null);							}														if( _alive && _movingAfterWalkAnimationEvent )							{								handleEnterFrameMoving(null);							}						}					}				}							/** slowDown			  *	---------------------------------------------------------------------------- */				override public function slowDown( duration:Number ):void				{					super.slowDown( duration );										if( _holdMovementTimer != null )						_holdMovementTimer.multiplier = 2;				}							/** handleSlowedDownTimerComplete			  *	---------------------------------------------------------------------------- */				override protected function handleSlowedDownTimerCompleted( timer:CustomTimer ):void				{					super.handleSlowedDownTimerCompleted( timer );										if( _holdMovementTimer != null )						_holdMovementTimer.multiplier = 1;									}							/** hitBySpringTrap			  *	---------------------------------------------------------------------------- *			  *	When enemies get hit by the spring trap, they will be flung up.			  *	---------------------------------------------------------------------------- */				override public function hitBySpringTrap():void				{					//trace( "hitBySpringTrap" );										_holdMovementTimer.stop();										super.hitBySpringTrap();									}							/** placedOnBoard			  *	---------------------------------------------------------------------------- *			  *	Called when WeaponDisplayObject gets added to the stage.			  *	Each weapon type is going to do different things ( either going to just stay			  *	static or actually going to start animating ).			  *	---------------------------------------------------------------------------- 				override public function placedOnBoard( customPosition:Boolean=false ):void				{					if( customPosition )					{						if( _positionIn2D == null ) _positionIn2D = new Point();						_positionIn2D.x = _path[_currentIndexInPath].positionIn2D.x;						_positionIn2D.y = _path[_currentIndexInPath].positionIn2D.y;					}					else					{						this.currentIndexInPath = 0;					}										//_currentSpeed = 3;										render();										startMoving();				}*/							/** startMoving			  *	---------------------------------------------------------------------------- *			  *	Starts the animation of the enemy moving across the level			  *	---------------------------------------------------------------------------- */				override public function startMoving():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "JumpingEnemyDisplayObject", "startMoving();" );					//trace( "startMoving();" );										if( !_moving && _currentPath != null )					{						//this.currentIndexInPath = 0;						_moving = true;												if( _holdMovementTimer == null )						{							_holdMovementTimer = new CustomTimer( 2000, 1 );							//_holdMovementTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleHoldMovementTimerCompleted, false, 0, true );							_holdMovementTimer.onTimerCompleted.add( handleHoldMovementTimerCompleted );														if( _pushedBack )								_holdMovementTimer.multiplier = .25;						}												if( !_inSpawnPath && _currentIndexInPath == 0 )						{							//trace( "start hold movement timer before it moves to the first point in path" );							startHoldMovementTimer();						}						else if( (_reversed || _pushedBack) && _inSpawnPath && _currentIndexInPath == _spawnPathLength-1 )						{							startHoldMovementTimer();						}						else						{							showAnimation( _direction );							moveToNextTile();						}						//moveToNextTile();					}				}							/** continueMoving			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				override public function continueMoving():void				{					//ConsoleBroadcaster.broadcast( "JumpingEnemyDisplayObject", "continueMoving();" );					//trace( "continueMoving();" );					//trace( "_pausedMoving: "+_pausedMoving );										if( _moving && _pausedMoving )					{						_pausedMoving = false;												//_moving = true;						//showAnimation( _direction );												//moveToNextTile();												if( !_holdMovementTimer.isRunning )							startHoldMovementTimer();					}				}							/** moveToNextTile			  *	---------------------------------------------------------------------------- *			  *	This function is part of the enemy animation. It makes the enemy moves to			  *	next tile on its path.			  *	---------------------------------------------------------------------------- */				override protected function moveToNextTile():void				{					//trace( "moveToNextTile();" );										//trace( "_currentIndexInPath: "+_currentIndexInPath );					//trace( "_currentPathLength: "+_currentPathLength );					//trace( "_direction: "+_direction );										if( _currentIndexInPath < _currentPathLength )					{						//_currentTile = _currentPath[_currentIndexInPath];												//trace( "_currentTile: "+_currentTile );												//++_currentIndexInPath;												if( _currentIndexInPath < _currentPathLength-1 )							_targetTile = _currentPath[_currentIndexInPath+1];						else							_targetTile = _currentPath[_currentIndexInPath];						_moving = true;						_movingAfterWalkAnimationEvent = false;						/*						if( _inSpawnPath && _currentIndexInPath == _currentPath.length-1 )						{							trace( "_currentTile: "+_currentTile );							trace( "_path[0]: "+_path[0] );							_direction = GameLevelUtil.directionFromTileAToTileB( _path[0], _currentTile );							trace( "_direction on last spawn tile is "+_direction );						}						*/						//_oldDirection = _direction;						//this.currentIndexInPath += 1;						//trace( "direction: "+_direction );						var tileBound:Rectangle = _currentTile.getTileBound();												//trace( "_targetTile.getTileBound(): "+_targetTile.getTileBound() );												//TODO:						//	Change the target point to be the edge of the tile instead of just the middle of the tile													if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top );								//_halfwayPoint.x = _targetPoint.x;								//_halfwayPoint.y = _targetPoint.y + tileBound.height/2;							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.bottom );								//_halfwayPoint.x = _targetPoint.x;								//_halfwayPoint.y = _targetPoint.y - tileBound.height/2;							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height/2 );								//_halfwayPoint.x = _targetPoint.x - tileBound.width/2;								//_halfwayPoint.y = _targetPoint.y;							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height/2 );								//_halfwayPoint.x = _targetPoint.x + tileBound.width/2;								//_halfwayPoint.y = _targetPoint.y;							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );								//_halfwayPoint.x = _targetPoint.x;								//_halfwayPoint.y = _targetPoint.y;							}												_halfwayPoint.x = _positionIn2D.x + (_targetPoint.x - _positionIn2D.x)/2;						_halfwayPoint.y = _positionIn2D.y + (_targetPoint.y - _positionIn2D.y)/2;												_moveX = (_targetPoint.x - _positionIn2D.x) / (_attackingGameObject.walkUpAnimationObject.animationCount - _attackingGameObject.walkUpAnimationObject.animationEvent);						_moveX = Math.round(_moveX * 1000) / 1000;						_moveY = (_targetPoint.y - _positionIn2D.y) / (_attackingGameObject.walkUpAnimationObject.animationCount - _attackingGameObject.walkUpAnimationObject.animationEvent);						_moveY = Math.round(_moveY * 1000) / 1000;												if( _oldDirection != _direction )						{							//trace( "change of direction" );							showAnimation( _oldDirection <= 0 ? _direction : _oldDirection );							/*							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tile							}							else if ( _direction == GameLevelUtil.DIRECTION_DOWN )							{															}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{															}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{															}							*/							//_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );							//_halfwayPoint.x = _targetPoint.x;							//_halfwayPoint.y = _targetPoint.y;														//trace( "next halfway point "+_halfwayPoint );														//_oldDirection = _direction;						}						else						{							//trace( "_passedHalfwayPoint is false" );														showAnimation( _direction );																					//trace( "next halfway point "+_halfwayPoint );						}												//trace( "_moveX: "+_moveX );						//trace( "_moveY: "+_moveY );												//trace( "_positionIn2D: "+_positionIn2D );						//trace( "_targetPoint: "+_targetPoint );						//trace( "_halfwayPoint: "+_halfwayPoint );						//trace( "_currentTile: "+_currentTile );												//_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );												//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );						//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_TILE, {tile:_currentTile}) );						onMovedToNextTile.dispatch( this, _currentTile );					}									}											/** handleEnterFrameMoving			  *	---------------------------------------------------------------------------- *			  *	Moves this along the assigned path			  *	---------------------------------------------------------------------------- */				override protected function handleEnterFrameMoving( event:Event ):void				{					//trace( "handleEnterFrameMoving();" );					//trace( "_positionIn2D.x: "+_positionIn2D.x+", _positionIn2D.y: "+_positionIn2D.y );					//trace( "_targetPoint.x: "+_targetPoint.x+", _targetPoint.y: "+_targetPoint.y );					//trace( this.visible );										if( _overshootX || _overshootY )					{						//trace( "_overshootX: "+_overshootX );						//trace( "_overshootY: "+_overshootY );						//trace( "_oldDirection: "+_oldDirection );						//trace( "_direction: "+_direction );												//trace( "stop handleEnterFrameMoving();" );												if( _oldDirection == _direction )						{							_overshootX = false;							_overshootY = false;														//trace( "remove enter frame event" );							//_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );							//_moving = false;							_pausedMoving = true;							_movingAfterWalkAnimationEvent = false;														if( _reversed || _pushedBack )							{								if( _currentIndexInPath > 0 )								{									_oldDirection = _direction;																		if( _reversedWhileJumping )										_reversedWhileJumping = false;									else										this.currentIndexInPath -= 1;																		_passedHalfwayPoint = false;									landOnTargetPoint();								}								else								{									if( !_inSpawnPath )									{										_inSpawnPath = true;										_moving = false;										_passedHalfwayPoint = false;																				_currentPath = _spawnPath;										_currentPathLength = _spawnPathLength;																				_currentTile = _currentPath[_currentPathLength-1];										this.currentIndexInPath = _currentPathLength-1;																				_currentAnimationDisplayObject.stopAnimation();										_currentAnimationDisplayObject.showAnimation(0);																				onSpawnPathReentered.dispatch( this );									}									else									{										//this.reversed = false;																				if( _reversed )											_reversed = false;										else if( _pushedBack )										{											_pushedBack = false;											_holdMovementTimer.multiplier = 1;										}																				this.currentIndexInPath = 0;										_passedHalfwayPoint = false;										landOnTargetPoint();									}								}							}							else							{								if( _currentIndexInPath < _currentPathLength-1 )								{									_oldDirection = _direction;																		if( _reversedWhileJumping )										_reversedWhileJumping = false;									else										this.currentIndexInPath += 1;																		//trace( "increase index path by 1" );																		_passedHalfwayPoint = false;									//moveToNextTile();																		landOnTargetPoint();								}								else								{									if( _inSpawnPath )									{										_currentPath = _path;										_currentPathLength = _pathLength;																				_inSpawnPath = false;										_moving = false;										_passedHalfwayPoint = false;																				_currentTile = _currentPath[0];										currentIndexInPath = 0;																				_currentAnimationDisplayObject.stopAnimation();										_currentAnimationDisplayObject.showAnimation(0);																				//this.startHoldMovementTimer();										/*										var tileBound:Rectangle = _path[0].getTileBound();										if( _direction == GameLevelUtil.DIRECTION_UP )										{											_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top );										}										else if( _direction == GameLevelUtil.DIRECTION_DOWN )										{											_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.bottom );										}										else if( _direction == GameLevelUtil.DIRECTION_RIGHT )										{											_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height/2 );										}										else if( _direction == GameLevelUtil.DIRECTION_LEFT )										{											_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height/2 );										}										else										{											_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );										}																				_halfwayPoint.x = _positionIn2D.x + (_targetPoint.x - _positionIn2D.x)/2;										_halfwayPoint.y = _positionIn2D.y + (_targetPoint.y - _positionIn2D.y)/2;																				_moveX = (_targetPoint.x - _positionIn2D.x) / (_attackingGameObject.walkUpAnimationObject.animationCount - _attackingGameObject.walkUpAnimationObject.animationEvent);										_moveX = Math.round(_moveX * 1000) / 1000;										_moveY = (_targetPoint.y - _positionIn2D.y) / (_attackingGameObject.walkUpAnimationObject.animationCount - _attackingGameObject.walkUpAnimationObject.animationEvent);										_moveY = Math.round(_moveY * 1000) / 1000;																				_moving = true;										_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );										*/										//dispatchEvent( new GameLevelEvent(GameLevelEvent.SPAWN_PATH_END) );										onSpawnPathEnded.dispatch( this );									}									else									{										//dispatchEvent( new GameLevelEvent(GameLevelEvent.PATH_END) );										onPathEnded.dispatch( this );									}								}							}						}						else						{							_overshootX = false;							_overshootY = false;														var tileBound:Rectangle = _currentTile.getTileBound();							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top );							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.bottom );							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height/2 );							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height/2 );							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );							}														_oldDirection = _direction;														_passedHalfwayPoint = false;														showAnimation( _direction );														//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_TILE, {tile:_currentTile}) );							onMovedToNextTile.dispatch( this, _currentTile );						}					}					else					{						moveToNextPoint();					}				}							/** moveToNextPoint			  *	---------------------------------------------------------------------------- *			  *	Moves the display object to the next target point			  *	---------------------------------------------------------------------------- */				override protected function moveToNextPoint():void				{										if( (_moveX < 0 && _positionIn2D.x <= _targetPoint.x) || (_moveX > 0 && _positionIn2D.x >= _targetPoint.x) )					{						_moveX = 0;					}					else					{						_positionIn2D.x += _moveX;						_positionIn2D.x = Math.round(_positionIn2D.x * 1000) / 1000;					}										if( (_moveY < 0 && _positionIn2D.y <= _targetPoint.y) || (_moveY > 0 && _positionIn2D.y >= _targetPoint.y) )					{						_moveY = 0;					}					else					{						_positionIn2D.y += _moveY;						_positionIn2D.y = Math.round(_positionIn2D.y * 1000) / 1000;					}										if( _moveX == 0 && _moveY == 0 )					{						_overshootX = true;						_overshootY = true;					}										//trace( "_positionIn2D: "+_positionIn2D );										if( !_passedHalfwayPoint )					{												if( _moveX == 0 && _moveY == 0 )						{							_passedHalfwayPoint = true;							//trace( "_passedHalfwayPoint is true" );							//showAnimation( _direction );						}						else if( (_moveX < 0 && _positionIn2D.x < _halfwayPoint.x) || (_moveX > 0 && _positionIn2D.x > _halfwayPoint.x) )						{							_passedHalfwayPoint = true;							//trace( "_passedHalfwayPoint is true" );							//showAnimation( _direction );						}						else if( (_moveY < 0 && _positionIn2D.y < _halfwayPoint.y) || (_moveY > 0 && _positionIn2D.y > _halfwayPoint.y) )						{							_passedHalfwayPoint = true;							//trace( "_passedHalfwayPoint is true" );							//showAnimation( _direction );						}												if( _oldDirection != _direction && _passedHalfwayPoint )						{							var newAnimationDisplayObject:AnimationDisplayObject;														//trace( "passing halfway point and change direction to "+_direction );							switch( _direction )							{								case GameLevelUtil.DIRECTION_UP:									if( _pushedBack )									{										_walkDownAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkDownAnimationClip;									}									else									{										_walkUpAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkUpAnimationClip;									}									break;																case GameLevelUtil.DIRECTION_RIGHT:									if( _pushedBack )									{										_walkDownAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkDownAnimationClip;									}									else									{										_walkUpAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkUpAnimationClip;									}									break;																case GameLevelUtil.DIRECTION_DOWN:									if( _pushedBack )									{										_walkUpAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkUpAnimationClip;									}									else									{										_walkDownAnimationClip.initCanvas( false );										newAnimationDisplayObject = _walkDownAnimationClip;									}									break;																case GameLevelUtil.DIRECTION_LEFT:									if( _pushedBack )									{										_walkUpAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkUpAnimationClip;									}									else									{										_walkDownAnimationClip.initCanvas( true );										newAnimationDisplayObject = _walkDownAnimationClip;									}									break;							}														_currentAnimationDisplayObject.stopAnimation();							_currentAnimationDisplayObject.contentClip.visible = false;														newAnimationDisplayObject.contentClip.visible = true;							newAnimationDisplayObject.showAnimation( _currentAnimationDisplayObject.tileIndex );														_currentAnimationDisplayObject = newAnimationDisplayObject;						}					}										if( !_passedHalfwayPoint )					{						_altitude -= 14;					}					else					{						_altitude += 14;												if( _altitude > 0 ) _altitude = 0;					}										_currentAnimationDisplayObject.showNextAnimation();										//dispatchEvent( new CustomEvent("onMovingToNextPoint") );										render();				}							/** landOnTargetPoint			  *	---------------------------------------------------------------------------- *			  *	When jumping enemy lands on target point, it needs to check if it can jump			  *	to the next			  *	---------------------------------------------------------------------------- */				protected function landOnTargetPoint():void				{					//trace( "landOnTargetPoint();" );										//_moving = false;					_pausedMoving = true;					_currentAnimationDisplayObject.stopAnimation();					_currentAnimationDisplayObject.showAnimation(0);										_currentTile = _currentPath[_currentIndexInPath];										//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_TILE, {tile:_currentPath[_currentIndexInPath]}) );					onMovedToNextTile.dispatch( this, _currentPath[_currentIndexInPath] );					//dispatchEvent( new GameLevelEvent(GameLevelEvent.LAND) );										if( _inSpawnPath )						startHoldMovementTimer();					else						handleCheckForTargets(null);				}							/** startHoldMovementTimer			  *	---------------------------------------------------------------------------- *			  *	Starts the hold movement timer. It's a timer for how long the enemy stays			  *	on the landed position before it jumps to the next position.			  *	---------------------------------------------------------------------------- */				public function startHoldMovementTimer():void				{					_holdMovementTimer.start();										//if( !_inSpawnPath )						//_contentClip.addEventListener( Event.ENTER_FRAME, handleCheckForTargets, false, 0, true );				}							/** stopHoldMovementTimer			  *	---------------------------------------------------------------------------- *			  *	Stops the hold movement timer. 			  *	---------------------------------------------------------------------------- */				public function stopHoldMovementTimer():void				{					if( _holdMovementTimer != null )					{						//_contentClip.removeEventListener( Event.ENTER_FRAME, handleCheckForTargets );												_holdMovementTimer.stop();						_holdMovementTimer.reset();					}				}							/** handleHoldMovementTimerCompleted			  *	---------------------------------------------------------------------------- *			  *	When the hold movement timer completes, the enemy will jump to the next			  *	position as long as there is no obstacle in front of him.			  *	---------------------------------------------------------------------------- */				protected function handleHoldMovementTimerCompleted( timer:CustomTimer ):void				{					//trace( "handleHoldMovementTimerCompleted();" );										stopHoldMovementTimer();										moveToNextTile();				}							/** kill			  *	---------------------------------------------------------------------------- */				protected function handleCheckForTargets( event:Event ):void				{					//trace( "handleCheckForTargets();" );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_POINT) );					onMovedToNextPoint.dispatch( this );				}							/** startAttackAnimation			  *	---------------------------------------------------------------------------- *			  *	Shows the attack animation of the displayObject. You can also do anything			  *	extra when it attacks. Separating this from attackTargets function so that			  *	extended classes can just override this function instead of overriding that 			  *	function.			  *	---------------------------------------------------------------------------- */				override public function startAttackAnimation():void				{					super.startAttackAnimation();										stopHoldMovementTimer();				}							/** canAttackTarget			  *	---------------------------------------------------------------------------- *			  *	Check to see if this object can attack the target. Override this function			  *	in the attacking object as the requirement is different for reach one.			  *	For the regular jumping enemy, it will only attack			  *	---------------------------------------------------------------------------- */				override protected function canAttackTarget( target:GameLevelDisplayObject ):Boolean				{					//if( _debug ) ConsoleBroadcaster.broadcast( "JumpingEnemyDisplayObject", "canAttackTarget("+target+");" );										if( _reversed || _pushedBack )						return false;										if( target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SPRING_TRAP_INDEX) || target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_TRAP_INDEX) )						return false;					/*					if( _attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_SUPER_JUMPER_INDEX) )					{						if( target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_HIGH_BLOCKING_INDEX) || target is GateDisplayObject )						{							return true;						}					}					else					{						if( target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_BLOCKING_INDEX) || target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_HIGH_BLOCKING_INDEX) || target is GateDisplayObject )						{							//trace( "can attack the high wall weapons" );							return true;						}					}					*/										if( target.attackingGameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_NO_JUMPING_INDEX) || target is GateDisplayObject )					{						return true;					}										return false;				}							/** showAnimation			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */			 	override public function showAnimation( direction:int ):void				{										super.showAnimation( direction );										if( !_attacking && _alive && _currentAnimationDisplayObject != null )					{						_currentAnimationDisplayObject.startAnimation( false, 0 );					}				}							/**	******************************************* *			  * AnimationDisplayObject Events			  *	******************************************* */			 				/** handleAttackAnimationEvent			  *	---------------------------------------------------------------------------- */				override protected function handleAttackAnimationEventFired():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "JumpingEnemyDisplayObject", "handleAttackAnimationEvent();" );										if( _alive && _attackedTarget != null )					{						_attackedTarget.hit( _attackingGameObject, _attackingGameObject.power );						_attackedTarget = null;												//dispatchEvent( new CustomEvent("onLaserFire", {shootTo:_attackedTarget.positionIn2D}) );					}				}							/** handleWalkAnimationEventFired			  *	---------------------------------------------------------------------------- */				//protected function handleWalkAnimationEvent( event:BoogaEvent ):void				protected function handleWalkAnimationEventFired():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "JumpingEnemyDisplayObject", "handleWalkAnimationEventFired();" );										//_currentAnimationDisplayObject.stopAnimation();										//trace( "add enter frame event" );					//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );					_movingAfterWalkAnimationEvent = true;				}		}			}