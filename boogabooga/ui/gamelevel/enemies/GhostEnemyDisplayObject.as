/** GhostEnemyDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Enemy class.  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel.enemies	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.events.Event;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.events.MouseEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.events.TimerEvent;		import flash.utils.getDefinitionByName;				import com.greensock.TweenLite;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.UtilFunctions;		import com.avatarlabs.utils.cache.BitmapDataManager;		import org.osflash.signals.Signal;				//import com.gamelevel.data.*;		import com.boogabooga.data.SettingsIndex;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.GameLevelDataIndex;		import com.boogabooga.events.BoogaEvent;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.GameboardTile;		import com.boogabooga.ui.gamelevel.enemies.EnemyDisplayObject;		import com.boogabooga.utils.GameLevelUtil;				public class GhostEnemyDisplayObject extends EnemyDisplayObject		{			protected var _ghostingTimer:CustomTimer;			protected var _ghosting:Boolean;			protected var _ghostingAnimationTimer:CustomTimer;						protected var _ghostColorTransform:ColorTransform;									/**	Stage Instances **/			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function GhostEnemyDisplayObject()				{									}								override public function set reversed( b:Boolean ):void				{					super.reversed = b;										if( _reversed )					{						_ghostingTimer.stop();						_ghostingTimer.reset();												if( _ghosting )						{							setGhosting( false );						}					}					else if( !_reversed && !_inSpawnPath )					{						_ghostingTimer.start();					}				}								override public function set pushedBack( b:Boolean ):void				{					super.pushedBack = b;										if( _pushedBack )					{						_ghostingTimer.stop();						_ghostingTimer.reset();												if( _ghosting )						{							setGhosting( false );						}					}				}								public function get ghosting():Boolean { return _ghosting; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					super.init();										_ghosting = false;										_ghostingAnimationTimer = new CustomTimer( 50, 10 );					//_ghostingAnimationTimer.addEventListener( TimerEvent.TIMER, handleGhostingAnimationTimerFired, false, 0, true );					//_ghostingAnimationTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleGhostingAnimationTimerCompleted, false, 0, true );					_ghostingAnimationTimer.onTimerFired.add( handleGhostingAnimationTimerFired );					_ghostingAnimationTimer.onTimerCompleted.add( handleGhostingAnimationTimerCompleted );										_ghostColorTransform = new ColorTransform( 1, 1, 1, 0.1, 0, 0, 0, 0 );										//onLaidEgg = new Signal( GhostEnemyDisplayObject, Point, int, int, int, Vector.<GameboardTile> );				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					if( !_inSpawnPath && _ghostingTimer && _ghostingTimer.isRunning )					{						_ghostingTimer.pause();					}										if( _ghostingAnimationTimer && _ghostingAnimationTimer.isRunning )					{						_ghostingAnimationTimer.pause();					}										super.pause();				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					super.unpause();										if( !_inSpawnPath && _ghostingTimer && _ghostingTimer.isRunning && _moving )					{						//trace( "unpause the ghosting timer" );						_ghostingTimer.unpause();					}										if( _ghostingAnimationTimer && _ghostingAnimationTimer.isRunning )					{						_ghostingAnimationTimer.unpause();					}									}							/** die			  *	---------------------------------------------------------------------------- */				override public function die():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "die();" );										if( _hitColorChangeTimer != null )					{						_hitColorChangeTimer.stop();					}										if( _ghostingAnimationTimer != null )						_ghostingAnimationTimer.stop();										if( _ghostingTimer != null )						_ghostingTimer.stop();										_ghosting = false;					_contentClip.alpha = 1;										super.die();									}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					if( _ghostingTimer != null )					{						_ghostingTimer.stop();						//_ghostingTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, handleGhostingTimerCompleted );						_ghostingTimer.onTimerCompleted.remove( handleGhostingTimerCompleted );						_ghostingTimer.kill();						_ghostingTimer = null;					}										if( _ghostingAnimationTimer != null )					{						_ghostingAnimationTimer.stop();						//_ghostingAnimationTimer.removeEventListener( TimerEvent.TIMER, handleGhostingAnimationTimerFired );						//_ghostingAnimationTimer.removeEventListener( TimerEvent.TIMER_COMPLETE, handleGhostingAnimationTimerCompleted );						_ghostingAnimationTimer.onTimerFired.remove( handleGhostingAnimationTimerFired );						_ghostingAnimationTimer.onTimerCompleted.remove( handleGhostingAnimationTimerCompleted );						_ghostingAnimationTimer.kill();						_ghostingAnimationTimer = null;					}										//onLaidEgg = null;										super.kill();				}							/** moveToNextTile			  *	---------------------------------------------------------------------------- *			  *	This function is part of the enemy animation. It makes the enemy moves to			  *	next tile on its path.			  *	---------------------------------------------------------------------------- */				override protected function moveToNextTile():void				{					super.moveToNextTile();										//trace( "_oldDirection == _direction ? " +(_oldDirection == _direction) );									}							/** moveToNextPoint			  *	---------------------------------------------------------------------------- *			  *	Moves the display object to the next target point			  *	---------------------------------------------------------------------------- */				override protected function moveToNextPoint():void				{					super.moveToNextPoint();										//trace( "_passedHalfwayPoint: "+_passedHalfwayPoint );					/*					if( _currentIndexInPath > 0 && _passedHalfwayPoint && !_hasLaidEgg )					{						//trace( "lay en egg !!!!!" );												_hasLaidEgg = true;												dispatchEvent( new GameLevelEvent(GameLevelEvent.LAY_EGG, {currentTile:_currentTile, hatchlingId:_attackingGameObject.hatchlingId, pathIndex:_pathIndex, currentIndexInPath:_currentIndexInPath, path:_path}) );					}					*/				}							/** slowDown			  *	---------------------------------------------------------------------------- */				override public function slowDown( duration:Number ):void				{					super.slowDown( duration );										_ghostingTimer.multiplier = 2;				}							/** handleSlowedDownTimerComplete			  *	---------------------------------------------------------------------------- */				override protected function handleSlowedDownTimerCompleted( timer:CustomTimer ):void				{					super.handleSlowedDownTimerCompleted( timer );										_ghostingTimer.multiplier = 1;				}							/** startMoving			  *	---------------------------------------------------------------------------- *			  *	Starts the animation of the enemy moving across the level			  *	---------------------------------------------------------------------------- */				override public function startMoving():void				{					super.startMoving();										if( _ghostingTimer == null )					{						_ghostingTimer = new CustomTimer( _attackingGameObject.additionalAttackValue*1000, 1 );						//_ghostingTimer.addEventListener( TimerEvent.TIMER_COMPLETE, handleGhostingTimerCompleted, false, 0, true );						_ghostingTimer.onTimerCompleted.add( handleGhostingTimerCompleted );					}										if( !_inSpawnPath )					{						_ghostingTimer.start();					}				}							/** continueMoving			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				override public function continueMoving():void				{					super.continueMoving();										if( _moving && !_inSpawnPath )					{						if( _ghostingTimer != null )						{							if( _ghostingTimer.isRunning )								_ghostingTimer.unpause();							else								_ghostingTimer.start();						}					}				}							/** stopMoving			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				override public function stopMoving():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "stopMoving();" );										//trace( 'stopMoving();' );										if( _moving && !_inSpawnPath )					{						if( _ghostingTimer != null )						{							_ghostingTimer.pause();							_ghostingTimer.stop();						}					}										super.stopMoving();				}							/** handleGhostingAnimationTimerFired			  *	---------------------------------------------------------------------------- *			  *	When the ghosting animation timer fired, we're animating the ghost.			  *	---------------------------------------------------------------------------- */				protected function handleGhostingAnimationTimerFired( timer:CustomTimer ):void				{					if( (_ghostingAnimationTimer.currentCount & 1) == 0 )					{						_contentClip.alpha = .1;					}					else					{						_contentClip.alpha = 1;					}				}							/** handleGhostingAnimationTimerCompleted			  *	---------------------------------------------------------------------------- *			  *	When the ghosting animation timer completed, reset the timer and set the			  *	ghosting property. Also, start the ghosting timer.			  *	---------------------------------------------------------------------------- */				protected function handleGhostingAnimationTimerCompleted( timer:CustomTimer ):void				{					//trace( 'handleGhostingAnimationTimerCompleted();' );										_ghostingAnimationTimer.reset();					_ghostingAnimationTimer.stop();										setGhosting( !_ghosting );										_ghostingTimer.reset();					_ghostingTimer.start();				}							/** handleGhostingTimerCompleted			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				protected function handleGhostingTimerCompleted( timer:CustomTimer ):void				{					//trace( "handleGhostingTimerCompleted();" );										//setGhosting( !_ghosting );										//_ghostingTimer.reset();					//_ghostingTimer.start();					_ghostingAnimationTimer.start();				}							/** setGhosting			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				protected function setGhosting( b:Boolean ):void				{					//trace( 'setGhosting('+b+');' );										_ghosting = b;										if( _hitColorChangeTimer != null && _hitColorChangeTimer.isRunning )					{						//trace( 'hit color change timer is running, stop it' );						_hitColorChangeTimer.stop();					}										if( _ghosting )					{						TweenLite.killTweensOf( _contentClip );						_contentClip.transform.colorTransform = _ghostColorTransform;					}					else					{						_contentClip.alpha = 1;					}										if( !_ghosting )					{						//onMovedToNextPoint.dispatch( this );						onMovedToNextTile.dispatch( this, _currentTile );					}				}							/** stopHitColorChangeTimer			  *	---------------------------------------------------------------------------- */				override public function stopHitColorChangeTimer( timer:CustomTimer=null ):void				{					if( _hitColorChangeTimer != null && _hitColorChangeTimer.isRunning )					{						_hitColorChangeTimer.stop();					}										if( _contentClip )					{						//trace( '_ghosting: '+_ghosting );						//trace( '_ghostingAnimationTimer isRunning: '+_ghostingAnimationTimer.isRunning );												if( _ghosting )						{							if( SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_COLOR_HIT_FADE) )							{								//trace( 'tweening to ghost' );								TweenLite.to( _contentClip, .2, {colorTransform:{redMultiplier:_ghostColorTransform.redMultiplier, greenMultiplier:_ghostColorTransform.greenMultiplier, 																blueMultiplier:_ghostColorTransform.blueMultiplier, alphaMultiplier:_ghostColorTransform.alphaMultiplier,																redOffset:_ghostColorTransform.redOffset, greenOffset:_ghostColorTransform.greenOffset, 																blueOffset:_ghostColorTransform.blueOffset, alphaOffset:_ghostColorTransform.alphaOffset}, overwrite:2} );							}							else							{								//trace( 'set to ghost' );								_contentClip.transform.colorTransform = _ghostColorTransform;							}														return;						}												super.stopHitColorChangeTimer( timer );					}									}							/** startAttackAnimation			  *	---------------------------------------------------------------------------- *			  *	Shows the attack animation of the displayObject. You can also do anything			  *	extra when it attacks. Separating this from attackTargets function so that			  *	extended classes can just override this function instead of overriding that 			  *	function.			  *	---------------------------------------------------------------------------- */				override public function startAttackAnimation():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( toString(), "startAttackAnimation();" );										if( _attackedTarget != null )					{						if( _ghosting )						{							_ghostingTimer.stop();							setGhosting( false );						}					}										super.startAttackAnimation();				}							/** hit			  *	---------------------------------------------------------------------------- *			  *	Reduces the health of the game object. When the health reaches 0, the object			  *	dies.			  *	---------------------------------------------------------------------------- */				override public function hit( gameObject:AbstractGameObject, power:Number, oneHitKill:Boolean=false ):void				{					if( _ghosting && !gameObject.hasAttackProperty(GameLevelUtil.ATTACK_PROPERTY_ENCHANTED_INDEX) )						return;										super.hit( gameObject, power, oneHitKill );				}											/**	******************************************* *			  * AnimationDisplayObject Events			  *	******************************************* */			 				/** handleAttackAnimationEvent			  *	---------------------------------------------------------------------------- 				override protected function handleAttackAnimationEvent( event:BoogaEvent ):void				{					if( _debug ) ConsoleBroadcaster.broadcast( "GhostEnemyDisplayObject", "handleAttackAnimationEvent();" );										if( _alive && _attackedTarget != null )					{						_attackedTarget.hit( _attackingGameObject, _attackingGameObject.power );						_attackedTarget = null;											}				}*/						}			}