/** GameLevelDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is a base class for all the UI game level objects that will be  *		placed in the gameboard. It has the math to convert the x,y of the class   *		between 2D view to the isometric view.  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.events.Event;		import flash.events.EventDispatcher;		import flash.events.FullScreenEvent;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.utils.getDefinitionByName;				import com.greensock.TweenLite;		import com.avatarlabs.utils.ArrayUtil;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;				//import com.gamelevel.data.*;		import com.boogabooga.ui.gamelevel.IGameLevelDisplayObject;		import com.boogabooga.utils.GameLevelUtil;				public dynamic class GameLevelDisplayObject extends EventDispatcher implements IGameLevelDisplayObject		{			protected var _debug:Boolean;			//protected var _isAssetLoaded:Boolean;			//protected var _assetLoader:CustomLoader;			protected var _needToBeUpdatedOnEnterFrame:Boolean;						protected var _contentClip:MovieClip;						protected var _gameboardReference:Gameboard;						protected var _altitude:Number;			protected var _positionIn2D:Point;			protected var _inIsometricView:Boolean;						public static var yellowColorTransform:ColorTransform = new ColorTransform(.5, .5, .5, 1, 128, 128, 0, 0);			public static var orangeColorTransform:ColorTransform = new ColorTransform(.5, .5, .5, 1, 128, 51, 0, 0);			public static var redColorTransform:ColorTransform = new ColorTransform(.5, .5, .5, 1, 128, 0, 0, 0);			public static var poisonedColorTransform:ColorTransform = new ColorTransform(0.5, 0.5, 0.5, 1, 51, 0, 77, 0);			public static var slowedDownColorTransform:ColorTransform = new ColorTransform(0.5, 0.5, 0.5, 1, 0, 77, 128, 0);									//protected var _isometricMatrix:Array;						/**	Stage Instances **/			//public var asset_mc:MovieClip;			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function GameLevelDisplayObject()				{					//stop();										//init();				}							/** set/get gameboardReference			  *	---------------------------------------------------------------------- */				public function set gameboardReference( _g:Gameboard ):void { this._gameboardReference = _g;  }				public function get gameboardReference():Gameboard { return this._gameboardReference; }								public function set contentClip( m:MovieClip ):void { _contentClip = m; }				public function get contentClip():MovieClip { return _contentClip; }								public function set x( n:Number ):void { _contentClip.x = n; }				public function get x():Number { return _contentClip.x; }								public function set y( n:Number ):void { _contentClip.y = n; }				public function get y():Number { return _contentClip.y; }							/** set/get positionIn2D			  *	---------------------------------------------------------------------------- */			 	public function set positionIn2D( p:Point ):void { this._positionIn2D = p; }				public function get positionIn2D():Point { return this._positionIn2D; }								public function set altitude( n:Number ):void { _altitude = n; }				public function get altitude():Number { return _altitude; }							/** set/get inIsometricView			  *	---------------------------------------------------------------------------- */			 	public function set inIsometricView( i:Boolean ):void { this._inIsometricView = i; }				public function get inIsometricView():Boolean { return this._inIsometricView; }							/** init			  *	---------------------------------------------------------------------------- */				public function init():void				{					//trace( "GameLevelDisplayObject: init();" );										_debug = false;					_needToBeUpdatedOnEnterFrame = true;										//_isAssetLoaded = false;					//_assetLoader = new CustomLoader();										_inIsometricView = false;					_positionIn2D = new Point(0,0);					_altitude = 0;					/*					var rotationDegreeRadian = -45 * Math.PI/180;					var elevationDegreeRadian = 54.5 * Math.PI/180;					var spinDegreeRadian = -90 * Math.PI/180;					var scale = 0.707214;					var rightX = Math.cos(rotationDegreeRadian) * scale;					var rightY = Math.sin(rotationDegreeRadian) * Math.cos(elevationDegreeRadian) * scale;					var frontX = -Math.sin(rotationDegreeRadian) * scale;					var frontY = Math.cos(rotationDegreeRadian) * Math.cos(elevationDegreeRadian) * scale;					var upX = 0;					var upY = Math.sin(elevationDegreeRadian);										_isometricMatrix = new Array( [rightX, rightY], [frontX, frontY], [upX, upY] );					*/				}							/** pause			  *	---------------------------------------------------------------------------- */				public function pause():void {}							/** unpause			  *	---------------------------------------------------------------------------- */				public function unpause():void {}							/** kill			  *	---------------------------------------------------------------------------- */				public function kill():void				{					//ArrayUtil.removeAll( _isometricMatrix );					//_assetLoader = null;					_needToBeUpdatedOnEnterFrame = false;										_contentClip = null;					_gameboardReference = null;										_positionIn2D = null;				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				public function updateOnEnterFrame():void				{									}							/** getCollisionRect			  *	---------------------------------------------------------------------- *			  *	Returns a rectangle of the intersection between 2 display objects			  *	credit to troygilbert.com			  *	http://troygilbert.com/2009/08/pixel-perfect-collision-detection-revisited/			  *	---------------------------------------------------------------------- 				public function getCollisionRect(target1:DisplayObject, target2:DisplayObject, commonParent:DisplayObjectContainer, pixelPrecise:Boolean = false, tolerance:int = 255):Rectangle				{					// get bounding boxes in common parent's coordinate space					var rect1:Rectangle = target1.getBounds(commonParent);					var rect2:Rectangle = target2.getBounds(commonParent);										// find the intersection of the two bounding boxes					var intersectionRect:Rectangle = rect1.intersection(rect2);										// if not pixel-precise, we're done					if (!pixelPrecise) return intersectionRect;										// size of rect needs to be integer size for bitmap data					intersectionRect.x = Math.floor(intersectionRect.x);					intersectionRect.y = Math.floor(intersectionRect.y);					intersectionRect.width = Math.ceil(intersectionRect.width);					intersectionRect.height = Math.ceil(intersectionRect.height);										// if the rect is empty, we're done					if (intersectionRect.isEmpty()) return intersectionRect;										// calculate the transform for the display object relative to the common parent					var parentXformInvert:Matrix = commonParent.transform.concatenatedMatrix.clone();					parentXformInvert.invert();					var target1Xform:Matrix = target1.transform.concatenatedMatrix.clone();					target1Xform.concat(parentXformInvert);					var target2Xform:Matrix = target2.transform.concatenatedMatrix.clone();					target2Xform.concat(parentXformInvert);										// translate the target into the rect's space					target1Xform.translate(-intersectionRect.x, -intersectionRect.y);					target2Xform.translate(-intersectionRect.x, -intersectionRect.y);										// combine the display objects					var bd:BitmapData = new BitmapData(intersectionRect.width, intersectionRect.height, false);					bd.draw(target1, target1Xform, new ColorTransform(1, 1, 1, 1, 255, -255, -255, tolerance), BlendMode.NORMAL);					bd.draw(target2, target2Xform, new ColorTransform(1, 1, 1, 1, 255, 255, 255, tolerance), BlendMode.DIFFERENCE);										// find overlap					var overlapRect:Rectangle = bd.getColorBoundsRect(0xffffffff, 0xff00ffff);					overlapRect.offset(intersectionRect.x, intersectionRect.y);										bd.dispose();										return overlapRect;				}*/							/** render			  *	---------------------------------------------------------------------------- */				public function render():void				{					if( this._positionIn2D != null )					{						//trace( "this._inIsometricView: "+this._inIsometricView );						//trace( "this._positionIn2D: "+this._positionIn2D );												if( this._inIsometricView )						{							var positionInIsometric:Point = GameLevelUtil.getPositionInIsometric( _positionIn2D, _altitude );							_contentClip.x = positionInIsometric.x;							_contentClip.y = positionInIsometric.y;							//_contentClip.x = Math.round((this._positionIn2D.x * _isometricMatrix[0][0]) + (this._positionIn2D.y * _isometricMatrix[1][0]));							//_contentClip.y = Math.round((this._positionIn2D.x * _isometricMatrix[0][1]) + (this._positionIn2D.y * _isometricMatrix[1][1])) + (_altitude * _isometricMatrix[2][1]);						}						else						{							_contentClip.x = this._positionIn2D.x;							_contentClip.y = this._positionIn2D.y;						}					}					/*					trace( "_positionIn2D: "+_positionIn2D );					trace( "iso position: "+_contentClip.x+","+_contentClip.y );										var tempPositionIn2D:Point = new Point();						tempPositionIn2D.x = ((_contentClip.x * _isometricMatrix[1][1]) - (_contentClip.y * _isometricMatrix[1][0]) + (_altitude * _isometricMatrix[2][1] * _isometricMatrix[1][0])) / ((_isometricMatrix[0][0] * _isometricMatrix[1][1]) - (_isometricMatrix[0][1]*_isometricMatrix[1][0]));						tempPositionIn2D.x = Math.round(tempPositionIn2D.x);						tempPositionIn2D.y = ( _contentClip.y - (tempPositionIn2D.x * _isometricMatrix[0][1]) - (_altitude * _isometricMatrix[2][1])) / _isometricMatrix[1][1];						tempPositionIn2D.y = Math.round(tempPositionIn2D.y);											trace( "tempPositionIn2D: "+tempPositionIn2D );					*/				}							/** loadAsset			  *	---------------------------------------------------------------------------- 				public function loadAsset( assetURL:String ):void				{					asset_mc.visible = false;										if( _isAssetLoaded )					{						_assetLoader.unloadAsset();					}										_assetLoader.addEventListener( "onLoadComplete", handleLoadAssetCompleted, false, 0, true );					_assetLoader.addEventListener( "onLoadProgress", handleLoadAssetProgress, false, 0, true );					_assetLoader.addEventListener( IOErrorEvent.IO_ERROR, handleLoadAssetError, false, 0, true );					_assetLoader.loadAsset( asset_mc, assetURL );				}*/							/** loadAssetFromLibrary			  *	---------------------------------------------------------------------------- 				public function loadAssetFromLibrary( linkageId:String ):void				{					if( _isAssetLoaded )						asset_mc.removeChildAt(0);										//var imageClass = getDefinitionByName(linkageId) as Class;					//var bitmap:Bitmap = new Bitmap( new imageClass() );					var assetClass:Class = getDefinitionByName(linkageId) as Class;					var asset:MovieClip =  new assetClass();										asset_mc.addChild( asset );					//asset_mc.x = -asset_mc.width/2;					//asset_mc.y = -asset_mc.height/2;					asset_mc.visible = true;										_isAssetLoaded = true;					dispatchEvent( new CustomEvent( "onLoadAssetComplete" ) );				}*/							/** removeAsset			  *	---------------------------------------------------------------------------- 				public function removeAsset():void				{					if( _isAssetLoaded )						asset_mc.removeChildAt(0);										_isAssetLoaded = false;				}*/							/** handleLoadImageComplete			  *	---------------------------------------------------------------------------- 				protected function handleLoadAssetCompleted( event:CustomEvent ):void				{					//if( _cb )					//	ConsoleBroadcaster.broadcast( "GameLevelDisplayObject", "handleLoadAssetCompleted();" );										event.currentTarget.removeEventListener( "onLoadComplete", handleLoadAssetCompleted );					event.currentTarget.removeEventListener( "onLoadProgress", handleLoadAssetProgress );					event.currentTarget.removeEventListener( IOErrorEvent.IO_ERROR, handleLoadAssetError );										asset_mc.x = -asset_mc.width/2;					asset_mc.y = -asset_mc.height/2;					asset_mc.visible = true;										_isAssetLoaded = true;										dispatchEvent( new CustomEvent( "onLoadAssetComplete" ) );				}*/							/** handleLoadAssetProgress			  *	---------------------------------------------------------------------------- 				protected function handleLoadAssetProgress( event:CustomEvent ):void				{					//if( _cb )					//	ConsoleBroadcaster.broadcast( "GameLevelDisplayObject", "handleLoadAssetProgress();" );				}*/							/** handleLoadAssetError			  *	---------------------------------------------------------------------------- 				protected function handleLoadAssetError( event:IOErrorEvent ):void				{					//if( _cb )					//	ConsoleBroadcaster.broadcast( "GameLevelDisplayObject", "handleLoadAssetError();" );										event.currentTarget.removeEventListener( "onLoadComplete", handleLoadAssetCompleted );					event.currentTarget.removeEventListener( "onLoadProgress", handleLoadAssetProgress );					event.currentTarget.removeEventListener( IOErrorEvent.IO_ERROR, handleLoadAssetError );				}*/						}			}