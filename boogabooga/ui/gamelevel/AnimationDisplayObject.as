/** AnimationDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Enemy class.  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.display.Sprite;		import flash.events.Event;		import flash.events.EventDispatcher;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.events.MouseEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.events.TimerEvent;		import flash.utils.getDefinitionByName;		import flash.utils.getTimer;				import com.greensock.TweenLite;		import com.avatarlabs.utils.cache.BitmapDataManager;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.timers.CustomTimer;		import com.avatarlabs.utils.UtilFunctions;		import org.osflash.signals.Signal;				import com.boogabooga.data.gamelevel.AnimationObject;		import com.boogabooga.events.BoogaEvent;						public class AnimationDisplayObject extends EventDispatcher		{			protected var _debug:Boolean;			protected var _contentClip:MovieClip;						protected var _contentClipOriginalPosition:Point;						protected var _animationObject:AnimationObject;			protected var _assetWidth:int;			protected var _assetHeight:int;			//protected var _animationObject.tileWidth:int;			//protected var _animationObject.tileHeight:int;			protected var _tilesPerRow:int;			//protected var _animationObject.animationCount:int;			protected var _tileIndex:int;			protected var _tileRect:Rectangle;			protected var _position:Point;			protected var _sourceBD:BitmapData;			protected var _canvasBD:BitmapData;			protected var _canvasBitmap:Bitmap;			//protected var _clearRect:Rectangle;			//protected var _clearBD:BitmapData;			protected var _canvasBitmapOriginalMatrix:Matrix;						protected var _running:Boolean;			protected var _flipped:Boolean;			protected var _looping:Boolean;			protected var _smoothing:Boolean;			protected var _idling:Boolean;			//protected var _animationTimer:CustomTimer;			protected var _reverseAnimation:Boolean;						public var onAnimationEventFired:Signal;			public var onSoundEventFired:Signal;			public var onAnimationEnded:Signal;						/**	Stage Instances **/			public var assetContainer_mc:MovieClip;			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function AnimationDisplayObject()				{					//stop();										//init();				}							/** set/get contentClip 			  *	---------------------------------------------------------------------------- */				public function set contentClip( m:MovieClip ):void				{					_contentClip = m;					_contentClip.gotoAndStop(1);										_contentClipOriginalPosition = new Point( _contentClip.x, _contentClip.y );										assetContainer_mc = _contentClip.assetContainer_mc;					assetContainer_mc.mouseChildren = false;					assetContainer_mc.mouseEnabled = false;										_contentClip.mouseChildren = false;					_contentClip.mouseEnabled = false;				}				public function get contentClip():MovieClip { return _contentClip; }								public function set assetWidth( i:int ):void { _assetWidth = i; }				public function get assetWidth():int { return _assetWidth; }								public function set assetHeight( i:int ):void { _assetHeight = i; }				public function get assetHeight():int { return _assetHeight; }								//public function set tileWidth( i:int ):void { _animationObject.tileWidth = i; }				//public function get tileWidth():int { return _animationObject.tileWidth; }								//public function set tileHeight( i:int ):void { _animationObject.tileHeight = i; }				//public function get tileHeight():int { return _animationObject.tileHeight; }								//public function set animationCount( i:int ):void { _animationObject.animationCount = i; }				//public function get animationCount():int { return _animationObject.animationCount; }								public function set animationObject( a:AnimationObject ):void				{					_animationObject = a;					//_sourceBD = BitmapDataManager.getInstance().getBitmapData( _animationObject.cacheId ).bitmapData;										//trace( "assetContainer_mc.x: "+assetContainer_mc.x );					//trace( "assetContainer_mc.y: "+assetContainer_mc.y );					//trace( "offset.x: "+_animationObject.offset.x );					//trace( "offset.y: "+_animationObject.offset.y );										//assetContainer_mc.x = _animationObject.offset.x;					//assetContainer_mc.y = _animationObject.offset.y;										//trace( "assetContainer_mc.x: "+assetContainer_mc.x );					//trace( "assetContainer_mc.y: "+assetContainer_mc.y );									}				public function get animationObject():AnimationObject { return _animationObject; }								public function get tilesPerRow():int { return _tilesPerRow; }				public function get tileIndex():int { return _tileIndex; }								public function set sourceBD( b:BitmapData ):void { _sourceBD = b; }								public function get running():Boolean { return _running; }				public function get flipped():Boolean { return _flipped; }				public function get looping():Boolean { return _looping; }				public function set smoothing( b:Boolean )				{					_smoothing = b;										if( _canvasBitmap != null )						_canvasBitmap.smoothing = _smoothing;				}								public function set offsetX( n:Number ):void { _contentClip.x = _contentClipOriginalPosition.x + n; }				public function set offsetY( n:Number ):void { _contentClip.y = _contentClipOriginalPosition.y + n; }							/** init			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function init():void				{					_debug = false;										_running = false;										_assetWidth = 0;					_assetHeight = 0;					//_animationObject.tileWidth = 0;					//_animationObject.tileHeight = 0;					_tilesPerRow = 0;					//_animationObject.animationCount = 0;										_tileIndex = 0;										_looping = false;					_smoothing = true;					_idling = false;										_position = new Point( 0, 0 );										assetContainer_mc.visible = false;										onAnimationEventFired = new Signal();					onSoundEventFired = new Signal( int );					onAnimationEnded = new Signal( AnimationDisplayObject );				}							/** pause			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function pause():void				{					/*					if( _animationTimer != null && _animationTimer.isRunning )					{						_animationTimer.pause();					}					*/					/*					if( _running )					{						_contentClip.removeEventListener( Event.ENTER_FRAME, handleAnimationTimerFired );					}					*/				}							/** unpause			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function unpause():void				{					/*					if( _animationTimer != null && _animationTimer.isRunning )					{						_animationTimer.unpause();					}					*/					/*					if( _running )					{						_contentClip.addEventListener( Event.ENTER_FRAME, handleAnimationTimerFired, false, 0, true );					}					*/				}							/** kill			  *	---------------------------------------------------------------------------- *			  *	Removes all things			  *	---------------------------------------------------------------------------- */				public function kill():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "AnimationDisplayObject", "kill();" );					/*					if( _animationTimer != null )					{						_animationTimer.stop();						_animationTimer.removeEventListener( TimerEvent.TIMER, handleAnimationTimerFired );						_animationTimer = null;					}					*/					//_contentClip.removeEventListener( Event.ENTER_FRAME, handleAnimationTimerFired );										assetContainer_mc.cacheAsBitmap = false;					while( assetContainer_mc.numChildren > 0 )						assetContainer_mc.removeChildAt( 0 );					/*					if( _clearBD != null )					{						_clearBD.dispose();						_clearBD = null;					}					*/					if( _canvasBD != null )					{						_canvasBD.dispose();						_canvasBD = null;					}										if( _sourceBD != null ) _sourceBD = null;										_running = false;					_idling = false;					_tileRect = null;					_position = null;					_animationObject = null;					_canvasBitmap = null;										onAnimationEventFired = null;					onSoundEventFired = null;					onAnimationEnded = null;				}							/** initCanvas			  *	---------------------------------------------------------------------------- *			  *	Initializes the canvas.			  *	---------------------------------------------------------------------------- */				public function initCanvas( flipped:Boolean=false ):void				{					_flipped = flipped;										assetContainer_mc.visible = false;					_position = new Point();										while( assetContainer_mc.numChildren > 0 )					{						assetContainer_mc.removeChildAt(0);					}										if( _animationObject.tileWidth > 0 && _animationObject.tileHeight > 0 )					{						_assetWidth = _sourceBD.width;						_assetHeight = _sourceBD.height;												//_clearBD = new BitmapData( _animationObject.tileWidth, _animationObject.tileHeight, true, 0xFFFFFF );						//_clearRect = new Rectangle( 0, 0, _animationObject.tileWidth, _animationObject.tileHeight );												_canvasBD = new BitmapData( _animationObject.tileWidth, _animationObject.tileHeight, true, 0xFF0000 );						_canvasBitmap = new Bitmap( _canvasBD );						_canvasBitmap.smoothing = _smoothing;						_canvasBitmap.cacheAsBitmap = true;						//_canvasBitmap.scrollRect = new Rectangle( 0, 0, _assetWidth, _assetHeight );						//this.scrollRect = new Rectangle( 0, 0, _assetWidth, _assetHeight );						//_canvasBitmap.visible = false;						_tileRect = new Rectangle( 0, 0, _animationObject.tileWidth, _animationObject.tileHeight );												_tilesPerRow = _assetWidth / _animationObject.tileWidth;												//if( _debug ) ConsoleBroadcaster.broadcast( "AnimationDisplayObject", "_tilesPerRow: "+_tilesPerRow );												//var bitmap:Bitmap = new Bitmap( new BitmapData(_animationObject.tileWidth, _animationObject.tileHeight, false, 0xFF0000));						//addChild( bitmap );												assetContainer_mc.addChild( _canvasBitmap );												_canvasBitmapOriginalMatrix = _canvasBitmap.transform.matrix.clone();												flipAnimation( flipped );												//trace( "assetContainer_mc.x: "+assetContainer_mc.x );						//trace( "assetContainer_mc.y: "+assetContainer_mc.y );						/*						if( flipped )						{							var matrix:Matrix = _canvasBitmap.transform.matrix;								matrix.a = -matrix.a;								matrix.tx = matrix.tx+_canvasBitmap.width;							_canvasBitmap.transform.matrix = matrix;														assetContainer_mc.x = -_animationObject.tileWidth/2;							assetContainer_mc.y = -(_animationObject.tileHeight-20);						}						else						{							assetContainer_mc.x = -_animationObject.tileWidth/2;							assetContainer_mc.y = -(_animationObject.tileHeight-20);						}						*/						assetContainer_mc.x = -_animationObject.tileWidth * .5;						assetContainer_mc.y = -(_animationObject.tileHeight-25);												assetContainer_mc.cacheAsBitmap = true;						assetContainer_mc.scrollRect = new Rectangle( 0, 0, _animationObject.tileWidth, _animationObject.tileHeight );					}										//trace( "_canvasBD: "+_canvasBD );					//trace( "_sourceBD: "+_sourceBD );					//trace( "_sourceBD.rect: "+_sourceBD.rect );					//trace( "_position: "+_position );										_canvasBD.copyPixels( _sourceBD, _sourceBD.rect, _position );										assetContainer_mc.visible = true;				}							/** flipAnimation			  *	---------------------------------------------------------------------------- *			  *	Flips the animation sprite.			  *	---------------------------------------------------------------------------- */				public function flipAnimation( flipped:Boolean ):void				{					_flipped = flipped;										if( flipped )					{						var matrix:Matrix = _canvasBitmapOriginalMatrix.clone();							matrix.a = -matrix.a;							matrix.tx = matrix.tx+_canvasBitmap.width;						_canvasBitmap.transform.matrix = matrix;					}					else					{						_canvasBitmap.transform.matrix = _canvasBitmapOriginalMatrix;					}				}							/** startAnimation			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function startAnimation( looping:Boolean=true, startIndex:int=-1, reverseAnimation:Boolean=false ):void				{					stopIdleAnimation();										if( startIndex >= 0 && startIndex < animationObject.animationCount )						_tileIndex = startIndex;										if( startIndex < 0 )						_tileIndex = 0;										if( startIndex >= _animationObject.animationCount )						startIndex = _animationObject.animationCount-1;										_reverseAnimation = reverseAnimation;										//_canvasBD.copyPixels( _clearBD, _tileRect, _position );										_looping = looping;					_running = true;					/*					if( _animationTimer == null )					{						_animationTimer = new CustomTimer( 33 );						_animationTimer.addEventListener( TimerEvent.TIMER, handleAnimationTimerFired, false, 0, true );					}					_animationTimer.start();					*/					//_contentClip.addEventListener( Event.ENTER_FRAME, handleAnimationTimerFired, false, 0, true );										//trace( _sourceBD.rect );										_canvasBD.copyPixels( _sourceBD, _tileRect, _position );					//_canvasBitmap.scrollRect = new Rectangle(0, 0, 128, 128);					//_canvasBitmap.scrollRect = new Rectangle( 0, 0, 600, 600 );					//this.scrollRect = new Rectangle( 0, 0, 128, 128 );										//trace( _canvasBitmap.x );					//trace( _canvasBitmap.y );										assetContainer_mc.visible = true;									}							/** stopAnimation			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- */				public function stopAnimation():void				{					//if( _debug ) ConsoleBroadcaster.broadcast( "AnimationDisplayObject", "stopAnimation();" );					//trace( "stopAnimation();" );										//_tileIndex = 0;					/*					if( _animationTimer != null && _animationTimer.isRunning )						_animationTimer.stop();					*/										//_contentClip.removeEventListener( Event.ENTER_FRAME, handleAnimationTimerFired );										_running = false;				}							/** showAnimation			  *	---------------------------------------------------------------------------- *			  *	Show the animation on the certain index.			  *	---------------------------------------------------------------------------- */				public function showAnimation( index:int ):void				{					if( _animationObject == null )						return;										if( index < 0 || index >= animationObject.animationCount )						return;										_tileIndex = index;										var tileIndexDividedByTilesPerRow:int = int(_tileIndex / _tilesPerRow);					_tileRect.x = (_tileIndex - (_tilesPerRow * tileIndexDividedByTilesPerRow)) * _animationObject.tileWidth;					_tileRect.y = tileIndexDividedByTilesPerRow * _animationObject.tileHeight;					//_tileRect.x = int( _tileIndex % _tilesPerRow ) * _animationObject.tileWidth;					//_tileRect.y = int( _tileIndex / _tilesPerRow ) * _animationObject.tileHeight;										//_canvasBD.copyPixels( _clearBD, _clearRect, _position );					//_canvasBD.fillRect( _canvasBD.rect, 0 );					_canvasBD.copyPixels( _sourceBD, _tileRect, _position );				}							/** showNextAnimation			  *	---------------------------------------------------------------------------- *			  *	Shows the next animation sprite.			  *	---------------------------------------------------------------------------- */				public function showNextAnimation():void				{					//TODO:					//	This logic feels very weird..					//	We should advance the tile index first to show the next frame and then check for animation event or sound event					//		rather than checking it before..					if( _running && _animationObject != null )					{						//trace( "_tileIndex: "+_tileIndex );						//trace( "_animationObject.animationEvent: "+_animationObject.animationEvent );												if( _tileIndex == (_animationObject.animationEvent-1) )						{							//dispatchEvent( new BoogaEvent(BoogaEvent.ON_ANIMATION_EVENT) );							onAnimationEventFired.dispatch();						}												if( _tileIndex == (_animationObject.soundEvent-1) )						{							//trace( "soundDataIds.length: "+_animationObject.soundDataIds.length );							//Only dispatches this event if there are sounds to be played							if( _animationObject.soundDataIds.length > 0 )							{								var randomIndex:int = int( Math.random()*_animationObject.soundDataIds.length );								//dispatchEvent( new BoogaEvent(BoogaEvent.ON_SOUND_EVENT, {soundDataId:_animationObject.soundDataIds[randomIndex]}) );								onSoundEventFired.dispatch( _animationObject.soundDataIds[randomIndex] );							}						}												//trace( "tileIndex: "+_tileIndex );						//trace( "animationCount: "+_animationObject.animationCount );												++_tileIndex;												if( _tileIndex >= _animationObject.animationCount )						{							_tileIndex = 0;														if( _idling )							{								_tileIndex = _animationObject.startIdleFrame;							}							else if( !_looping )							{								//trace( "onAnimationEnds" );								//stopAnimation();								//dispatchEvent( new BoogaEvent(BoogaEvent.ON_ANIMATION_ENDS) );																//return;																if( _animationObject != null && _animationObject.idleFrames > 0 )								{									_running = false;									startIdleAnimation();								}								else								{									stopAnimation();								}																onAnimationEnded.dispatch( this );							}						}												showAnimation( _tileIndex );					}				}								public function startIdleAnimation():void				{					//trace( "startIdleAnimation();" );										if( !_running && _animationObject.idleFrames > 0 )					{						_idling = true;						_tileIndex = _animationObject.startIdleFrame;						showAnimation( _tileIndex );						_running = true;					}									}								public function stopIdleAnimation():void				{					//trace( "stopIdleAnimation();" );										_idling = false;				}							/** handleEnterFrame			  *	---------------------------------------------------------------------------- *			  *	---------------------------------------------------------------------------- 				protected function handleAnimationTimerFired( event:Event ):void				{					//trace( getTimer() );					//trace( "_tileIndex: "+_tileIndex );					//trace( "_animationObject.animationEvent: "+_animationObject.animationEvent );					//trace( "_animationObject.soundEvent: "+_animationObject.soundEvent );										_tileRect.x = int( _tileIndex % _tilesPerRow ) * _animationObject.tileWidth;					_tileRect.y = int( _tileIndex / _tilesPerRow ) * _animationObject.tileHeight;										//_canvasBD.copyPixels( _clearBD, _clearRect, _position );					//_canvasBD.fillRect( _canvasBD.rect, 0 );					_canvasBD.copyPixels( _sourceBD, _tileRect, _position );										//_canvasBitmap.x = -_tileRect.x;					//_canvasBitmap.y = -_tileRect.y;										//trace( "_canvasBitmap.x: "+_canvasBitmap.x );					//trace( "_canvasBitmap.y: "+_canvasBitmap.y );															//dispatchEvent( new CustomEvent("onAnimationTimerFired") );										//TODO:					//	Check why we're using animationEvent-1 ??					if( _tileIndex == (_animationObject.animationEvent-1) )					{						dispatchEvent( new BoogaEvent(BoogaEvent.ON_ANIMATION_EVENT) );					}										if( _tileIndex == (_animationObject.soundEvent-1) )					{						//trace( "soundDataIds.length: "+_animationObject.soundDataIds.length );						//Only dispatches this event if there are sounds to be played						if( _animationObject.soundDataIds.length > 0 )						{							var randomIndex:int = int( Math.random()*_animationObject.soundDataIds.length );							dispatchEvent( new BoogaEvent(BoogaEvent.ON_SOUND_EVENT, {soundDataId:_animationObject.soundDataIds[randomIndex]}) );						}					}										++_tileIndex;										//trace( "tileIndex: "+_tileIndex );					//trace( "animationCount: "+_animationObject.animationCount );										if( _tileIndex >= _animationObject.animationCount )					{						_tileIndex = 0;												if( !_looping )						{							//trace( "onAnimationEnds" );							stopAnimation();							dispatchEvent( new BoogaEvent(BoogaEvent.ON_ANIMATION_ENDS) );							//return;						}					}									}*/						}			}