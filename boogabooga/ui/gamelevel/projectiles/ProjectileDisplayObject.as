/** ProjectileDisplayObject  *	---------------------------------------------------------------------------- *  *	@desc:  *		This is the display object clip that will represent Projectile class.  *	@author:   *		Christian Widodo, [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.gamelevel.projectiles	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.display.MovieClip;		import flash.display.Sprite;		import flash.events.Event;		import flash.events.FullScreenEvent;		import flash.events.IOErrorEvent;		import flash.events.ProgressEvent;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.utils.getDefinitionByName;				import com.greensock.TweenLite;		import com.avatarlabs.utils.cache.*;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.events.CustomEvent;		import com.avatarlabs.utils.loader.CustomLoader;		import com.avatarlabs.utils.UtilFunctions;		import org.osflash.signals.Signal;				//import com.gamelevel.data.*;		import com.boogabooga.data.SettingsIndex;		import com.boogabooga.data.gamelevel.AbstractGameObject;		import com.boogabooga.data.gamelevel.Enemy;		import com.boogabooga.data.gamelevel.Projectile;		import com.boogabooga.data.gamelevel.Weapon;		import com.boogabooga.data.maingame.MainGameDataIndex;		import com.boogabooga.events.GameLevelEvent;		import com.boogabooga.ui.gamelevel.AnimationDisplayObject;		import com.boogabooga.ui.gamelevel.GameLevelDisplayObject;		import com.boogabooga.utils.GameLevelUtil;		import com.boogabooga.ui.gamelevel.GameboardTile;				public class ProjectileDisplayObject extends GameLevelDisplayObject		{			protected var _attackingGameObject:AbstractGameObject;			protected var _projectile:Projectile;						protected var _destinationPointIn2D:Point;			protected var _movementX:Number;			protected var _movementY:Number;			protected var _movementAltitude:Number;			protected var _direction:int;			protected var _oldAnimationDirection:int;						protected var _path:Vector.<GameboardTile>;			protected var _pathLength:int;			protected var _pathIndex:int;			protected var _currentIndexInPath:int;						protected var _moving:Boolean;			protected var _alive:Boolean;			protected var _outOfBoundsDeath:Boolean;						protected var _isPathProjectile:Boolean;			protected var _currentTile:GameboardTile;			protected var _targetTile:GameboardTile;			protected var _targetPoint:Point;			protected var _nextPoint:Point;			protected var _halfwayPoint:Point;			protected var _passedHalfwayPoint:Boolean;			protected var _oldDirection:int;			protected var _overshootX:Boolean;			protected var _overshootY:Boolean;			protected var _currentSpeed:int;			protected var _type:int;						protected var _animationClip:AnimationDisplayObject;						public var onRemovedFromGame:Signal;			//public var onMovedToNextTile:Signal;			public var onMoved:Signal;			public var onPathEnded:Signal;						public static const TYPE_PROJECTILE:int = 0;			public static const TYPE_CATAPULT:int = 1;			public static const TYPE_LASER:int = 2;						/**	Stage Instances **/			public var animation_mc:MovieClip;			public var hitarea_mc:MovieClip;			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function ProjectileDisplayObject()				{					//init();				}								//public function set attackingGameObject( g:GameLevelAttackingDisplayObject ):void { _attackingGameObject = g; }				//public function get attackingGameObject():GameLevelAttackingDisplayObject { return _attackingGameObject; }				public function set attackingGameObject( a:AbstractGameObject ):void				{					if( a is Weapon )						_attackingGameObject = UtilFunctions.clone(a) as Weapon;					else if( a is Enemy )						_attackingGameObject = UtilFunctions.clone(a) as Enemy;										_isPathProjectile = _attackingGameObject.hasProjectileProperty( GameLevelUtil.ATTACK_PROPERTY_PATH_INDEX );				}				public function get attackingGameObject():AbstractGameObject { return _attackingGameObject; }							/** set/get projectile			  *	---------------------------------------------------------------------------- */				public function set projectile( p:Projectile ):void				{					_projectile = p;										/*					var bitmap:Bitmap = new Bitmap( BitmapDataManager.getInstance().getBitmapData("BatTotem_SingleBat").bitmapData );					_animationClip.contentClip.x = -bitmap.width/2;					_animationClip.contentClip.y = -bitmap.height/2;					_animationClip.addChild( bitmap );					*/									}				public function get projectile():Projectile { return _projectile; }								public function set pathIndex( i:int ):void { _pathIndex = i; }				public function get pathIndex():int { return _pathIndex; }							/** set/get path			  *	---------------------------------------------------------------------------- */				public function set path( p:Vector.<GameboardTile> ):void				{					if( p == null )						return;										_path = p;					_pathLength = _path.length;				}				public function get path():Vector.<GameboardTile> { return _path; }							/** set/get currentIndexInPath			  *	---------------------------------------------------------------------------- */				public function set currentIndexInPath( i:int ):void				{					_currentIndexInPath = i;										//trace( "_currentIndexInPath: "+_currentIndexInPath );					//trace( "currentTile: "+_path[_currentIndexInPath] );										if( _currentIndexInPath == 0 )						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], null, false );					else						_direction = GameLevelUtil.directionFromTileAToTileB( _path[_currentIndexInPath], _path[_currentIndexInPath-1] );				}				public function get currentIndexInPath():int { return _currentIndexInPath; }							/** setDestinationPointIn2D			  *	---------------------------------------------------------------------------- */				public function setDestinationPointIn2D( p:Point, altitude:Number=0 ):void				{					_destinationPointIn2D = p;										_movementX = _destinationPointIn2D.x - _positionIn2D.x;					_movementY = _destinationPointIn2D.y - _positionIn2D.y;					_movementAltitude = altitude - _altitude;										if( _movementX == 0 )					{						_movementX = 1;					}										if( _movementY == 0 )					{						_movementY = 1;					}										var ratioX:Number = _movementX * _projectile.speedInversed;						ratioX = ratioX < 0 ? -ratioX : ratioX;					var ratioY:Number = _movementY * _projectile.speedInversed;						ratioY = ratioY < 0 ? -ratioY : ratioY;										_currentSpeed = _projectile.speed;										var ratioInversed:Number;										if( ratioX > ratioY )					{						ratioInversed = 1 / ratioX;						_movementX = _movementX * ratioInversed;						_movementY = _movementY * ratioInversed;						_movementAltitude = _movementAltitude * ratioInversed;					}					else					{						ratioInversed = 1 / ratioY;						_movementX = _movementX * ratioInversed;						_movementY = _movementY * ratioInversed;						_movementAltitude = _movementAltitude * ratioInversed;					}										//trace( "_movementX: "+_movementX );					//trace( "_movementY: "+_movementY );				}							/** set/get contentClip			  *	---------------------------------------------------------------------------- */				override public function set contentClip( m:MovieClip ):void				{					_contentClip = m;					_contentClip.mouseChildren = false;					_contentClip.mouseEnabled = false;										animation_mc = _contentClip.animation_mc;					hitarea_mc = _contentClip.hitarea_mc;										animation_mc.visible = false;										_animationClip = new AnimationDisplayObject();					_animationClip.contentClip = animation_mc;					_animationClip.smoothing = false;					_animationClip.init();										animation_mc.mouseEnabled = false;					hitarea_mc.mouseEnabled = false;										//_animationClip.addEventListener( "onAnimationEvent", handleAnimationEventFired, false, 0, true );									}								public function set direction( i:int ):void { _direction = i; }				public function get direction():int { return _direction; }								public function get alive():Boolean { return _alive; }								public function get type():int { return _type; }							/** init			  *	---------------------------------------------------------------------------- */				override public function init():void				{					//trace( "ProjectileDisplayObject: init();" );										super.init();										_oldAnimationDirection = -1;										_debug = true;										_moving = false;					_alive = false;										_targetPoint = new Point();					_halfwayPoint = new Point();					_currentSpeed = 4;										_overshootX = false;					_overshootY = false;										onRemovedFromGame = new Signal( ProjectileDisplayObject );					//onMovedToNextTile = new Signal( ProjectileDisplayObject, GameboardTile );					onMoved = new Signal( ProjectileDisplayObject );					onPathEnded = new Signal( ProjectileDisplayObject );										_type = TYPE_PROJECTILE;				}							/** pause			  *	---------------------------------------------------------------------------- */				override public function pause():void				{					/*					if( _moving )					{						if( _isPathProjectile )							_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMovingInPath );						else							_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );					}					*/					_animationClip.pause();				}							/** unpause			  *	---------------------------------------------------------------------------- */				override public function unpause():void				{					/*					if( _moving )					{						if( _isPathProjectile )							_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMovingInPath, false, 0, true );						else							_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );					}					*/										_animationClip.unpause();				}							/** kill			  *	---------------------------------------------------------------------------- */				override public function kill():void				{					ConsoleBroadcaster.broadcast( "ProjectileDisplayObject", "kill();" );										_needToBeUpdatedOnEnterFrame = false;										stopMoving();										_animationClip.stopAnimation();										_destinationPointIn2D = null;					_projectile = null;					_attackingGameObject = null;										onRemovedFromGame = null;					onMoved = null;					onPathEnded = null;										super.kill();				}								public function reuse():void				{					_needToBeUpdatedOnEnterFrame = true;					_outOfBoundsDeath = false;				}							/** reset			  *	---------------------------------------------------------------------------- */				public function reset():void				{					_needToBeUpdatedOnEnterFrame = false;					//_positionIn2D = null;										_contentClip.alpha = 1;										stopMoving();										//_destinationPointIn2D = null;					_projectile = null;					_attackingGameObject = null;					_isPathProjectile = false;					_path = null;				}							/** updateOnEnterFrame			  *	---------------------------------------------------------------------------- *			  *	This updates the display object on every enter frame loop.			  *	---------------------------------------------------------------------------- */				override public function updateOnEnterFrame():void				{					if( _needToBeUpdatedOnEnterFrame )					{						//trace( "_moving: "+_moving );						if( _moving )						{							if( _isPathProjectile )								handleEnterFrameMovingInPath( null );							else								handleEnterFrameMoving( null );														//trace( "_contentClip.x: "+_contentClip.x+", y: "+_contentClip.y );						}												//trace( "_animationClip: "+_animationClip );						if( _animationClip != null )							_animationClip.showNextAnimation();												if( _outOfBoundsDeath )						{							_contentClip.alpha -= .2;														if( _contentClip.alpha <= 0 )							{								stopMoving();								//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );								onRemovedFromGame.dispatch( this );							}						}					}				}							/** startMoving			  *	---------------------------------------------------------------------------- */				public function startMoving():void				{					_moving = true;					_alive = true;										//trace( "direction: "+direction );										switch( direction )					{						case GameLevelUtil.DIRECTION_UP:							_animationClip.offsetX = _projectile.upAnimationObject.customPosition.x;							_animationClip.offsetY = _projectile.upAnimationObject.customPosition.y;							_animationClip.animationObject = _projectile.upAnimationObject;							_animationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( _animationClip.animationObject.cacheId ).bitmapData;							_animationClip.initCanvas( false );							break;												case GameLevelUtil.DIRECTION_RIGHT:							_animationClip.offsetX = -_projectile.upAnimationObject.customPosition.x;							_animationClip.offsetY = _projectile.upAnimationObject.customPosition.y;							_animationClip.animationObject = _projectile.upAnimationObject;							_animationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( _animationClip.animationObject.cacheId ).bitmapData;							_animationClip.initCanvas( true );							break;												case GameLevelUtil.DIRECTION_DOWN:							_animationClip.offsetX = _projectile.downAnimationObject.customPosition.x;							_animationClip.offsetY = _projectile.downAnimationObject.customPosition.y;							_animationClip.animationObject = _projectile.downAnimationObject;							_animationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( _animationClip.animationObject.cacheId ).bitmapData;							_animationClip.initCanvas( false );							break;													case GameLevelUtil.DIRECTION_LEFT:							_animationClip.offsetX = -_projectile.downAnimationObject.customPosition.x;							_animationClip.offsetY = _projectile.downAnimationObject.customPosition.y;							_animationClip.animationObject = _projectile.downAnimationObject;							_animationClip.sourceBD = BitmapDataManager.getInstance().getBitmapData( _animationClip.animationObject.cacheId ).bitmapData;							_animationClip.initCanvas( true );							break;					}										_animationClip.contentClip.visible = true;					_animationClip.startAnimation( true, 0 );					//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMovingInPath, false, 0, true );										if( _isPathProjectile )						moveToNextTile();					else						handleEnterFrameMoving( null );						//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMoving, false, 0, true );				}							/** stopMoving			  *	---------------------------------------------------------------------------- */				public function stopMoving():void				{					if( _moving )					{						_moving = false;												_animationClip.stopAnimation();												/*						if( _isPathProjectile )							_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMovingInPath );						else							_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMoving );						*/					}				}							/** die			  *	---------------------------------------------------------------------------- */				public function die():void				{					if( _debug ) ConsoleBroadcaster.broadcast( "ProjectileDisplayObject", "die();" );					//trace( "die();" );										if( _alive )					{						stopMoving();												_alive = false;												//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );						onRemovedFromGame.dispatch( this );					}				}								public function dieFromOutOfBounds():void				{					//trace( "dieFromOutOfBounds();" );										if( _alive )					{						_alive = false;						_outOfBoundsDeath = true;												if( !SettingsIndex.getInstance().getPerformanceItemToggled(SettingsIndex.PERFORMANCE_ITEM_PROJECTILE_FADE) )						{							stopMoving();							//dispatchEvent( new GameLevelEvent(GameLevelEvent.REMOVE_FROM_GAME) );							onRemovedFromGame.dispatch( this );						}					}				}							/** moveToNextTile			  *	---------------------------------------------------------------------------- */				protected function moveToNextTile():void				{					if( _currentIndexInPath >= 0 )					{						_currentTile = _path[_currentIndexInPath];												_moving = true;												var tileBound:Rectangle = _currentTile.getTileBound();												if( _oldDirection != _direction )						{							showAnimation( _oldDirection <= 0 ? _direction : _oldDirection );							_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );							_halfwayPoint.x = _targetPoint.x;							_halfwayPoint.y = _targetPoint.y;						}						else						{							showAnimation( _direction );														if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y + tileBound.height/2;							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.bottom );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y - tileBound.height/2;							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height/2 );								_halfwayPoint.x = _targetPoint.x - tileBound.width/2;								_halfwayPoint.y = _targetPoint.y;							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height/2 );								_halfwayPoint.x = _targetPoint.x + tileBound.width/2;								_halfwayPoint.y = _targetPoint.y;							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );								_halfwayPoint.x = _targetPoint.x;								_halfwayPoint.y = _targetPoint.y;							}						}												//_contentClip.addEventListener( Event.ENTER_FRAME, handleEnterFrameMovingInPath, false, 0, true );						handleEnterFrameMovingInPath( null );						//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING_TO_NEXT_TILE, {tile:_currentTile}) );						//onMovedToNextTile.dispatch( this, _currentTile );					}				}							/** handleenterFrameMoving			  *	---------------------------------------------------------------------------- */				protected function handleEnterFrameMoving( event:Event ):void				{					//trace( "handleEnterFrameMoving();" );					_positionIn2D.x += _movementX;					_positionIn2D.y += _movementY;					_altitude += _movementAltitude;										//trace( "_positionIn2D.x: "+_positionIn2D.x );					//trace( "_positionIn2D.y: "+_positionIn2D.y );										render();										if( !_outOfBoundsDeath )					{						//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING) );						onMoved.dispatch( this );					}										//var position:Point = _contentClip.localToGlobal(new Point(_contentClip.x, _contentClip.y));										//if( position.x < MainGameDataIndex.getInstance().outOfBoundsRectangle.x || position.x > MainGameDataIndex.getInstance().outOfBoundsRectangle.width || position.y < MainGameDataIndex.getInstance().outOfBoundsRectangle.y || position.y > MainGameDataIndex.getInstance().outOfBoundsRectangle.height )					//{						//die();					//}					//else					//{						//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING) );					//}					//trace( "position: "+_contentClip.localToGlobal(new Point(_contentClip.x, _contentClip.y)) );										//trace( "x: "+_contentClip.x );					//trace( "y: "+_contentClip.y );					//trace( "visible: "+_contentClip.visible );										//TODO:					//	If a projectile is out of range, remove it from the game.					//	Probably if x/y < -1000 && x/y > 2000				}							/** handleEnterFrameMovingInPath			  *	---------------------------------------------------------------------------- */				protected function handleEnterFrameMovingInPath( event:Event ):void				{					if( _overshootX || _overshootY )					{						if( _oldDirection == _direction )						{							_overshootX = false;							_overshootY = false;														//_contentClip.removeEventListener( Event.ENTER_FRAME, handleEnterFrameMovingInPath );														if( _currentIndexInPath > 0 )							{								_oldDirection = _direction;								this.currentIndexInPath -= 1;																moveToNextTile();							}							else							{								//dispatchEvent( new GameLevelEvent(GameLevelEvent.PATH_END) );								onPathEnded.dispatch( this );								die();							}						}						else						{							_overshootX = false;							_overshootY = false;														var tileBound:Rectangle = _currentTile.getTileBound();							if( _direction == GameLevelUtil.DIRECTION_UP )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top );							}							else if( _direction == GameLevelUtil.DIRECTION_DOWN )							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.bottom );							}							else if( _direction == GameLevelUtil.DIRECTION_RIGHT )							{								_targetPoint = new Point( tileBound.right, tileBound.top+tileBound.height/2 );							}							else if( _direction == GameLevelUtil.DIRECTION_LEFT )							{								_targetPoint = new Point( tileBound.left, tileBound.top+tileBound.height/2 );							}							else							{								_targetPoint = new Point( tileBound.left+tileBound.width/2, tileBound.top+tileBound.height/2 );							}														_oldDirection = _direction;														showAnimation( _direction );						}					}					else					{						moveToNextPoint();					}				}							/** moveToNextPoint			  *	---------------------------------------------------------------------------- */				protected function moveToNextPoint():void				{					var moveX:Number = _targetPoint.x - _positionIn2D.x;					var moveY:Number = _targetPoint.y - _positionIn2D.y;										var nextMoveX:Number;					var nextMoveY:Number;					var moveXNegative:Boolean;					var moveYNegative:Boolean;										//trace( "position: "+_contentClip.localToGlobal(new Point(_contentClip.x, _contentClip.y)) );										if( moveX != 0 )					{						_overshootX = (moveX < 0 ? -moveX : moveX) < _currentSpeed;												moveXNegative = moveX < 0;						moveX = (moveX < 0 ? -moveX : moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveX;												_positionIn2D.x += moveX;					}										if( moveY != 0 )					{						_overshootY = (moveY < 0 ? -moveY : moveY) < _currentSpeed;												moveYNegative = moveY < 0;												moveY = (moveY < 0 ? -moveY : moveY) > _currentSpeed ? (moveYNegative ? -_currentSpeed : _currentSpeed) : moveY;												_positionIn2D.y += moveY;					}										//trace( "_currentSpeed: "+_currentSpeed );					//trace( "moveX: "+moveX );					//trace( "moveY: "+moveY );					//trace( "_overshootX: "+_overshootX );					//trace( "_overshootY: "+_overshootY );										if( _overshootX )					{						nextMoveX = 0;					}					else					{						nextMoveX = _targetPoint.x - _positionIn2D.x;												moveXNegative = moveX < 0;						nextMoveX = (moveX < 0 ? -moveX : moveX) > _currentSpeed ? (moveXNegative ? -_currentSpeed : _currentSpeed) : moveX;					}										if( _overshootY )					{						nextMoveY = 0;					}					else					{						nextMoveY = _targetPoint.y - _positionIn2D.y;												moveYNegative = moveY < 0;						nextMoveY = (moveY < 0 ? -moveY : moveY) > _currentSpeed ? (moveYNegative ? -_currentSpeed : _currentSpeed) : moveY;					}										if( moveX == 0 && moveY == 0 )					{						_overshootX = true;						_overshootY = true;					}										//trace( "_positionIn2D: "+_positionIn2D );										//dispatchEvent( new GameLevelEvent(GameLevelEvent.MOVING) );					onMoved.dispatch( this );										render();				}							/** showAnimation			  *	---------------------------------------------------------------------------- */				protected function showAnimation( direction:int ):void				{					if( _oldAnimationDirection != direction )					{						_oldAnimationDirection = direction;												switch( direction )						{							case GameLevelUtil.DIRECTION_UP:							case GameLevelUtil.DIRECTION_DOWN:								_animationClip.initCanvas( false );								break;														case GameLevelUtil.DIRECTION_RIGHT:							case GameLevelUtil.DIRECTION_LEFT:								_animationClip.initCanvas( true );								break;						}												_animationClip.startAnimation( true, 0 );					}				}		}			}