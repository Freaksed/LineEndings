/** WeaponSelectionViewMonsterPath  *	---------------------------------------------------------------------------- *  *	@desc:  *		A list for the paths  *	@author:  *		Christian Widodo [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */ 	package com.boogabooga.ui.maingame.weaponselection	{		import flash.display.Bitmap;		import flash.display.MovieClip;		import flash.events.EventDispatcher;		import flash.geom.Point;		import flash.utils.getDefinitionByName;		import flash.utils.getQualifiedClassName;		import flash.utils.Timer;				import com.avatarlabs.utils.VectorUtil;		import com.avatarlabs.utils.console.ConsoleBroadcaster;		import com.avatarlabs.utils.timers.CustomTimer;				import com.boogabooga.data.gamelevel.GameLevel;		import com.boogabooga.data.gamelevel.GameLevelDataIndex;		import com.boogabooga.utils.GameLevelUtil;						public class WeaponSelectionViewMonsterPath extends EventDispatcher		{			protected var _contentClip:MovieClip;						protected var _pathIndexes:Vector.<int>;			protected var _pathTimer:CustomTimer;			//protected var _gameLevel:GameLevel;			protected var _activePathClips:Vector.<Vector.<MovieClip>>;			protected var _monsterPathClips:Vector.<Vector.<MovieClip>>;						/**	Stage Instances **/			public var background_mc:MovieClip;			public var container_mc:MovieClip;			/**	End of Stage Instances **/						/** Constructor			  *	---------------------------------------------------------------------------- */				public function WeaponSelectionViewMonsterPath()				{					//init();				}								public function set contentClip( m:MovieClip ):void				{					_contentClip = m;										background_mc = _contentClip.background_mc;					container_mc = _contentClip.container_mc;				}				public function get contentClip():MovieClip { return _contentClip; }							/** init			  *	---------------------------------------------------------------------------- */				public function init():void				{					_monsterPathClips = new Vector.<Vector.<MovieClip>>;					var arrowClip:MovieClip;										var i:int, j:int;					var position:Point;										//trace( 'container_mc: '+container_mc );					/*					for( i=0; i<GameLevelDataIndex.getInstance().boardMaxRows; ++i )					{						_monsterPathClips[i] = new Vector.<MovieClip>;						for( j=0; j<GameLevelDataIndex.getInstance().boardMaxColumns; ++j )						{							arrowClip = new (getDefinitionByName("WeaponSelection.MonsterPath.Arrow") as Class)();							position = GameLevelUtil.getPositionInIsometric( new Point(12+(j*23), 12+(i*23)) );							arrowClip.x = position.x;							arrowClip.y = position.y;							arrowClip.up_mc.visible = false;							arrowClip.right_mc.visible = false;							arrowClip.down_mc.visible = false;							arrowClip.left_mc.visible = false;							arrowClip.stop();							arrowClip.visible = false;							container_mc.addChild( arrowClip );														_monsterPathClips[i].push( arrowClip );						}					}					*/					_activePathClips = new Vector.<Vector.<MovieClip>>;					_pathIndexes = new Vector.<int>;										_pathTimer = new CustomTimer( 100 );					_pathTimer.onTimerFired.add( handlePathTimerFired );				}							/** initMonstersPaths			  *	---------------------------------------------------------------------------- *			  *	Initializes the monsters paths.			  *	---------------------------------------------------------------------------- */				public function initMonstersPaths( gameLevel:GameLevel ):void				{					//_gameLevel = gameLevel;										reset();										var i:int, j:int;					/*					for( i=0; i<_monsterPathClips.length; ++i )					{						for( j=0; j<_monsterPathClips[i].length; ++j )						{							_monsterPathClips[i][j].up_mc.visible = false;							_monsterPathClips[i][j].right_mc.visible = false;							_monsterPathClips[i][j].down_mc.visible = false;							_monsterPathClips[i][j].left_mc.visible = false;							_monsterPathClips[i][j].visible = false;							_monsterPathClips[i][j].gotoAndStop(1);						}					}					*/					var direction:int;					var newDirection:int;					var definitionName:String;					var position:Point;					var pathClip:MovieClip;										for( i=0; i<gameLevel.paths.length; ++i )					{						//trace( '-----' );						_activePathClips.push( new Vector.<MovieClip> );												for( j=0; j<gameLevel.paths[i].length; ++j )						{							direction = GameLevelUtil.DIRECTION_UP;														if( gameLevel.paths[i][j].r == 0 )							{								direction = GameLevelUtil.DIRECTION_UP;							}							else if( j == 0 )							{								if( gameLevel.paths[i][j].c == GameLevelDataIndex.getInstance().boardMaxColumns-1 && gameLevel.waveZones[0].totalNumberOfEnemies > 0 && gameLevel.waveZones[1].totalNumberOfEnemies == 0 )									direction = GameLevelUtil.DIRECTION_LEFT;								else if( gameLevel.waveZones[1].totalNumberOfEnemies > 0 && gameLevel.waveZones[0].totalNumberOfEnemies == 0 && gameLevel.waveZones[2].totalNumberOfEnemies == 0 )									direction = GameLevelUtil.DIRECTION_UP;								else if( gameLevel.paths[i][j].c == 0 && gameLevel.waveZones[2].totalNumberOfEnemies > 0 && gameLevel.waveZones[1].totalNumberOfEnemies == 0 )									direction = GameLevelUtil.DIRECTION_RIGHT;								else									direction = GameLevelUtil.directionGameLevelPathFromAToB( gameLevel.paths[i][j] );							}							else							{								direction = GameLevelUtil.directionGameLevelPathFromAToB( gameLevel.paths[i][j], gameLevel.paths[i][j-1] );								//newDirection = GameLevelUtil.directionGameLevelPathFromAToB( gameLevel.paths[i]							}														if( j != gameLevel.paths[i].length-1 )								newDirection = GameLevelUtil.directionGameLevelPathFromAToB( gameLevel.paths[i][j+1], gameLevel.paths[i][j] );														//trace( 'path.r: '+gameLevel.paths[i][j].r+', c: '+gameLevel.paths[i][j].c );							//trace( 'direction: '+direction );							//trace( 'newDirection: '+newDirection );														if( direction == newDirection )							{								if( direction == 0 || direction == 2 )								{									definitionName = 'WeaponSelection.MonsterPath.piece1';								}								else								{									definitionName = 'WeaponSelection.MonsterPath.piece2';								}							}							else							{								if( (direction == 2 && newDirection == 1) || (direction == 3 && newDirection == 0) )									definitionName = 'WeaponSelection.MonsterPath.corner1';								else if( (direction == 3 && newDirection == 2) || (direction == 0 && newDirection == 1) )									definitionName = 'WeaponSelection.MonsterPath.corner2';								else if( (direction == 0 && newDirection == 3) || (direction == 1 && newDirection == 2) )									definitionName = 'WeaponSelection.MonsterPath.corner3';								else									definitionName = 'WeaponSelection.MonsterPath.corner4';															}														pathClip = new (getDefinitionByName(definitionName) as Class)();							position = GameLevelUtil.getPositionInIsometric( new Point(12+(gameLevel.paths[i][j].c*23), 12+(gameLevel.paths[i][j].r*23)), 0, false );							pathClip.x = position.x;							pathClip.y = position.y;							pathClip.stop();							//pathClip.visible = false;							container_mc.addChild( pathClip );														_activePathClips[i].push( pathClip );														/*							switch( direction )							{								case GameLevelUtil.DIRECTION_UP:									//_monsterPathClips[gameLevel.paths[i][j].r][gameLevel.paths[i][j].c].up_mc.visible = true;									break;																case GameLevelUtil.DIRECTION_RIGHT:									//_monsterPathClips[gameLevel.paths[i][j].r][gameLevel.paths[i][j].c].right_mc.visible = true;									break;																case GameLevelUtil.DIRECTION_DOWN:									//_monsterPathClips[gameLevel.paths[i][j].r][gameLevel.paths[i][j].c].down_mc.visible = true;									break;																case GameLevelUtil.DIRECTION_LEFT:									//_monsterPathClips[gameLevel.paths[i][j].r][gameLevel.paths[i][j].c].left_mc.visible = true;									break;							}							*/							//_monsterPathClips[gameLevel.paths[i][j].r][gameLevel.paths[i][j].c].visible = true;							//_activePathClips[i].push( _monsterPathClips[gameLevel.paths[i][j].r][gameLevel.paths[i][j].c] );						}												_pathIndexes.push( 0 );					}										_pathTimer.start();				}							/** reset			  *	---------------------------------------------------------------------------- *			  *	Resets the weapon selection view.			  *	---------------------------------------------------------------------------- */				public function reset():void				{					_pathTimer.stop();										VectorUtil.removeAll( _pathIndexes );										var i:int, j:int;										for( i=0; i<_activePathClips.length; ++i )					{						for( j=0; j<_activePathClips[i].length; ++j )						{							//_activePathClips[i][j].visible = false;							_activePathClips[i][j].gotoAndStop(1);							container_mc.removeChild( _activePathClips[i][j] );						}						VectorUtil.removeAll( _activePathClips[i] );					}										VectorUtil.removeAll( _activePathClips );				}								protected function handlePathTimerFired( timer:CustomTimer ):void				{					var i:int, j:int;					for( i=0; i<_activePathClips.length; ++i )					{						/*						for( j=0; j<_activePathClips[i].length; ++j )						{													}						*/												_activePathClips[i][ _pathIndexes[i] ].play();												++_pathIndexes[i];												if( _pathIndexes[i] >= _activePathClips[i].length )							_pathIndexes[i] = 0;					}				}						}	}