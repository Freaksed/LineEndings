/** UIHorizontalScroller *	---------------------------------------------------------------------------- * *	@dev:	James Safechuck [james@avatarlabs.com] *	@desc:	General purpose Horizontal Scroller. Scrolls content  *	when user moves their mouse left to right within a user set active area *	example: *	scroller_mc.createMask( 0, 0, 200, 20 ); *	scroller_mc.setActiveArea( 75 ); *	scroller_mc.setScrollSpeed( 5 ); *	scroller_mc.setActive(true); *	---------------------------------------------------------------------------- */ 	package com.avatarlabs.utils.userinterface	{		import flash.display.MovieClip;		import flash.display.Sprite;		import flash.events.MouseEvent;		import flash.events.Event;		import flash.errors.IllegalOperationError;				public class UIHorizontalScroller extends MovieClip		{			private static const LEFT:String = "left";			private static const RIGHT:String = "right";						private var contentContainer:Sprite;			private var contentMask:Sprite;						private var active:Boolean;						private var displayChildren:Array;						private var spacing:uint = 5;			private var per:Number = 0;			private var scrollSpeed:Number = 2;						private var currentDirection:String;						private var bounds:Sprite;						private var activeArea:Object;					/*	Constructor		 *	------------------------------------------------------------ */			public function UIHorizontalScroller()			{				displayChildren = new Array();				contentContainer = new Sprite();				contentMask = new Sprite();				activeArea = new Object();								currentDirection = "";								addChild( contentContainer );				addChild( contentMask );							}					/*	createMask		 *	sets dimentions of two sprites. one used for mask and the 		 *	other is used for mouse per		 *	------------------------------------------------------------ */			public function createMask( x:Number, y:Number, width, height ):void			{				contentMask.graphics.beginFill(0xFFCC00);				contentMask.graphics.lineStyle(0, 0x0000CC, 1);				contentMask.graphics.drawRect( x, y, width, height );				contentMask.graphics.endFill();								bounds = new Sprite();				bounds.graphics.beginFill(0xFFCC00, 0);				bounds.graphics.lineStyle(0, 0, 0);				bounds.graphics.drawRect( x, y, width, height );				bounds.graphics.endFill();				bounds.mouseChildren = false;								addChild( bounds );				swapChildren( bounds, contentContainer );								contentContainer.mask = contentMask;			}					/*	setActiveArea		 *	this will set the active area for the scroll		 * 	if user makes this number bigger than half the bounds area		 *	it defaults to half.		 *	------------------------------------------------------------ */			public function setActiveArea( w:int ):void			{				trace( "setActiveArea("+w+")");								if( !bounds )				{					throw new IllegalOperationError("ERROR MUST USE createMask() FUNCTION BEFORE YOU CALL setActiveArea()");				}								if( w > (bounds.width / 2) )					w = ( bounds.width/2);								activeArea.startX1 = 0;				activeArea.endX1 = w;								activeArea.endX2 = bounds.width;				activeArea.startX2 = bounds.width - w;			}					/*	setActiveArea		 *	sets the direction and per depending on where the mouse is		 *	------------------------------------------------------------ */			protected function setPer( event:MouseEvent ):void			{				//trace( "MouseEvent.localX "+event.localX );								var mouse_x = event.localX;								if( (mouse_x >= activeArea.startX1) && ( mouse_x <= activeArea.endX1 ) )				{					//trace( "is in activeArea 1");					var offset:Number = activeArea.endX1 - mouse_x;					per = Math.abs(offset / activeArea.endX1);					//trace( per );					currentDirection = UIHorizontalScroller.RIGHT;									}else if( (mouse_x <= activeArea.endX2) && ( mouse_x >= activeArea.startX2 ) )				{					var currentActiveArea:Number = activeArea.endX2 - activeArea.startX2;					per = Math.abs( (activeArea.startX2 - mouse_x) / currentActiveArea );					//trace( per );					currentDirection = UIHorizontalScroller.LEFT;					//trace( "is in activeArea 2");				}else				{					per = 0;					currentDirection = "";				}			}					/*	scrollContent		 *	scrols the content using the direction and per		 *	------------------------------------------------------------ */			private function scrollContent( event:Event ):void			{				switch ( currentDirection )				{					case UIHorizontalScroller.LEFT:						if(canMoveFoward())							contentContainer.x -= Math.round(per * scrollSpeed);					break;					case UIHorizontalScroller.RIGHT:						if( canMoveBackward() )							contentContainer.x += Math.round(per * scrollSpeed);					break;					case "":					break;				}			}					/*	canMoveFoward		 *	------------------------------------------------------------ */			protected function canMoveFoward():Boolean			{				var condition = (contentContainer.x + contentContainer.width) > (contentMask.x + contentMask.width );								if( condition  )				{					return true;				}else				{					return false;				}			}					/*	canMoveBackward		 *	------------------------------------------------------------ */			protected function canMoveBackward():Boolean			{				var condition = (contentContainer.x <= activeArea.startX1);								if( condition )				{					return true;				}else				{					return false;				}			}					/*	setActive		 *	turn this off and on to start and stop scrolling		 *	------------------------------------------------------------ */			public function setActive( a:Boolean ):void			{				active = a;								if( active )				{					bounds.addEventListener( Event.ENTER_FRAME, scrollContent );					bounds.addEventListener( MouseEvent.MOUSE_MOVE, setPer );				}else				{					bounds.removeEventListener( Event.ENTER_FRAME, scrollContent );					bounds.removeEventListener( MouseEvent.MOUSE_MOVE, setPer );				}			}					/*	getters/setters		 *	------------------------------------------------------------ */			public function getActive():Boolean			{				return active;			}						public function setScrollSpeed( s:Number ):void			{				scrollSpeed = s;			}						public function getScrollSpeed():Number 			{				return scrollSpeed;			}						public function setSpacing( s:Number ):void			{				spacing = s;			}					/*	addDisplayChild		 *	------------------------------------------------------------ */			public function addDisplayChild( child:Sprite ):void			{				//trace( "addDisplayChild("+child+")");								contentContainer.addChild( child );				displayChildren.push( child );								child.x = (child.width + spacing) * (displayChildren.length -1);			}		}	}