/** CustomTimer  *	---------------------------------------------------------------------------- *  *	Christian W [christian dot avatarlabs dot com]  *	---------------------------------------------------------------------------- *  *	This CustomTimer Class extends flash.utils.Timer  *	We're extending it so we can pause the timer and unpause it and let it run  *	on the remaining time  *	WARNING !!!!  *	Have not tested rigorously yet, but it looks to be working fine.  *	---------------------------------------------------------------------------- */ 	package com.avatarlabs.utils.timers	{		import flash.events.TimerEvent;		import flash.utils.Timer;		import flash.utils.getTimer;				import com.avatarlabs.utils.console.ConsoleBroadcaster;		import org.osflash.signals.Signal;				public class CustomTimer extends Timer		{			protected var _isRunning:Boolean;			protected var _isPaused:Boolean;			protected var _startingTime:Number;			protected var _remainingTime:Number;						protected var _wasPaused:Boolean;			protected var _originalDelay:Number;			protected var _multipliedDelay:Number;			protected var _multiplier:Number;						public var onTimerFired:Signal;			public var onTimerCompleted:Signal;						/** Constructor			  *	---------------------------------------------------------------------------- */				public function CustomTimer( delay:Number, repeatCount:int=0 )				{					_originalDelay = delay;					_multipliedDelay = _originalDelay;										super( delay, repeatCount );										init();				}								public function get isRunning():Boolean { return this._isRunning; }				public function get isPaused():Boolean { return this._isPaused; }								public function get startingTime():Number { return this._startingTime; }				public function get remainingTime():Number { return this._remainingTime; }							/** set multiplier			  *	---------------------------------------------------------------------------- *			  *	This multiplier is used to slow the timer down or to make it faster.			  *	_multiplier = 1 is the normal speed.			  *	---------------------------------------------------------------------------- */				public function set multiplier( n:Number ):void				{					_multiplier = n;										//_originalDelay = _multiplier * delay;					_multipliedDelay = _multiplier * _originalDelay;										//TODO:					//	This multiplier still behaves a bit funky.					//	If timer starts at 0s and delay is 2000, and multiplier is set to 2 (slower) when timer is on 1500,					//		it should only run for 1000 more before it dispatches TIMER event at 2500, but					//		it will dispatch TIMER event at 4000.					//		Any subsequent TIMER events are dispatched at the right time though.					//	Same issue when we have a delay of 2000, and multiplier is set to .5 (faster) when timer is on 1500,					//		it should only run for 250 more before it dispatches TIMER event at 1750,					//		but it will dispatch TIMER event at 1510 because it thinks that it's surpassed the delay					//		Any subsequent TIMER events are dispatched at the right time though.										if( _isRunning )					{						pause();						unpause();					}					else					{						delay = _multipliedDelay;					}				}							/** init			  *	---------------------------------------------------------------------------- */				public function init():void				{					_isRunning = false;					_isPaused = false;					_startingTime = -1;					_remainingTime = -1;					_multiplier = 1;										onTimerFired = new Signal( CustomTimer );					onTimerCompleted = new Signal( CustomTimer );				}								public function kill():void				{					onTimerFired = null;					onTimerCompleted = null;				}							/** start			  *	---------------------------------------------------------------------------- *			  *	extends super.start() so we can assign values			  *	---------------------------------------------------------------------------- */				override public function start():void				{					addEventListener( TimerEvent.TIMER, handleTimerFired );					addEventListener( TimerEvent.TIMER_COMPLETE, handleTimerCompleted );										super.start();										_isRunning = true;					_isPaused = false;					_startingTime = getTimer();				}							/** stop			  *	---------------------------------------------------------------------------- *			  *	extends super.stop() so we can reset values			  *	---------------------------------------------------------------------------- */				override public function stop():void				{					//trace( 'stop();' );										removeEventListener( TimerEvent.TIMER, handleTimerFired );										if( this.repeatCount != this.currentCount )						removeEventListener( TimerEvent.TIMER_COMPLETE, handleTimerCompleted );										super.stop();					//trace('calling stop');										_isRunning = false;					_isPaused = false;					_startingTime = -1;					_remainingTime = -1;				}							/** pause			  *	---------------------------------------------------------------------------- *			  *	When it pauses the timer, it records the remaining time so when this timer			  *	is unpaused, it can just run for the remaining time			  *	---------------------------------------------------------------------------- */				public function pause():void				{					//trace( _isRunning );										if( !_isPaused )					{												//trace('pausing');						//this.stop();						super.stop();												_remainingTime = _multipliedDelay - (getTimer() - _startingTime);																	if(_remainingTime < 0) { 							_remainingTime = 0; 							//trace('below zero ' + _isRunning );						}												//trace('_remainingTime: ' + _remainingTime + ' _startingTime:  ' + _startingTime );												//_isRunning = false;						_isPaused = true;												//trace( "_remainingTime: "+_remainingTime );					}/*else						trace('already paused');*/				}							/** unpause			  *	---------------------------------------------------------------------------- *			  *	It starts the timer again, and run it for the remaining time only			  *	---------------------------------------------------------------------------- */				public function unpause():void				{															//trace(this + ' isRunning: ' + _isRunning + ' isPaused: ' + _isPaused + ' _remainingTime: ' + _remainingTime )					if( _isRunning && _isPaused && _remainingTime >= 0 )					{						_wasPaused = true;						delay = _remainingTime;						//trace( "delay: "+delay );						start();												//trace( "unpaused!" );					}/*else						trace('cant unapuse');*/														}							/** handleTimerFired			  *	---------------------------------------------------------------------------- *			  *	This will reset the startingTimer for each interval			  *	This also checks if the timer was resumed before. If it was, it resets the			  *	delay on the timer to the original delay value			  *	The only drawback of this is the fact that it will delay the timer for a little			  *	bit ( about 40ms ) since it has to stop it and start it again			  *	---------------------------------------------------------------------------- */				private function handleTimerFired( event:TimerEvent ):void				{					//trace( "handleTimerFired();" );										_startingTime = getTimer();										if( _wasPaused )					{						//trace('was paused - gonna call stop');						stop();												delay = _multipliedDelay;						_wasPaused = false;												start();					}										onTimerFired.dispatch( this );				}							/** handleTimerCompleted			  *	---------------------------------------------------------------------------- */				private function handleTimerCompleted( event:TimerEvent ):void				{					//trace( 'handleTimerCompleted();' );					removeEventListener( TimerEvent.TIMER, handleTimerFired );					removeEventListener( TimerEvent.TIMER_COMPLETE, handleTimerCompleted );										_isRunning = false;					_startingTime = -1;					_remainingTime = -1;										onTimerCompleted.dispatch( this );				}		}			}