/**	UtilFunctions  *	---------------------------------------------------------------------------- *  *	@desc:  *		Util functions for various things  *	@author:  *		Christian Widodo [christian@avatarlabs.com]  *	---------------------------------------------------------------------------- */	package com.avatarlabs.utils	{		import flash.display.Bitmap;		import flash.display.BitmapData;		import flash.display.BlendMode;		import flash.display.DisplayObject;		import flash.display.DisplayObjectContainer;		import flash.geom.ColorTransform;		import flash.geom.Matrix;		import flash.geom.Point;		import flash.geom.Rectangle;		import flash.utils.describeType;		import flash.utils.getDefinitionByName;		import flash.utils.getQualifiedClassName;				public class UtilFunctions		{						/** Clone Objects			  *	---------------------------------------------------------------------- *			  *	You have to type cast the returned object.			  *	If you are cloning a class and you have custom classes in its property,			  *	make sure that you are cloning those custom classes individually.			  *	---------------------------------------------------------------------- */				public static function newSibling(sourceObj:Object):* {					if(sourceObj) {											var objSibling:*;						try {							var classOfSourceObj:Class = getDefinitionByName(getQualifiedClassName(sourceObj)) as Class;							objSibling = new classOfSourceObj();						}						catch(e:Object) {}												return objSibling;					}					return null;				}								public static function clone(source:Object):Object {										var clone:Object;					if(source) {						clone = newSibling(source);												if(clone) {							copyData(source, clone);						}					}										return clone;				}								public static function copyData(source:Object, destination:Object):void {										//copies data from commonly named properties and getter/setter pairs					if((source) && (destination)) {												try {							var sourceInfo:XML = describeType(source);							var prop:XML;														for each(prop in sourceInfo.variable) {																if(destination.hasOwnProperty(prop.@name)) {									destination[prop.@name] = source[prop.@name];								}															}														for each(prop in sourceInfo.accessor) {								if(prop.@access == "readwrite") {									if(destination.hasOwnProperty(prop.@name)) {										destination[prop.@name] = source[prop.@name];									}																}							}						}						catch (err:Object) {						;						}					}				}							/** localToLocal			  *	---------------------------------------------------------------------- *			  *	Returns the position of fromDisplayObject1 in toDisplayObject2 x,y			  *	---------------------------------------------------------------------- */				public static function localToLocal( fromDisplayObject1:DisplayObject, toDisplayObject2:DisplayObject, point:Point=null ):Point				{					if( point == null )						point = new Point( fromDisplayObject1.x, fromDisplayObject1.y );					var fromGlobalPosition:Point = fromDisplayObject1.parent.localToGlobal( point );					var toLocalPosition:Point = toDisplayObject2.globalToLocal(fromGlobalPosition);										return toLocalPosition;				}							/** getCollisionRect			  *	---------------------------------------------------------------------- *			  *	Returns a rectangle of the intersection between 2 display objects			  *	credit to troygilbert.com			  *	http://troygilbert.com/2009/08/pixel-perfect-collision-detection-revisited/			  *	---------------------------------------------------------------------- */				public static function getCollisionRect(target1:DisplayObject, target2:DisplayObject, commonParent:DisplayObjectContainer, pixelPrecise:Boolean = false, tolerance:int = 255):Rectangle				{					// get bounding boxes in common parent's coordinate space					var rect1:Rectangle = target1.getBounds(commonParent);					var rect2:Rectangle = target2.getBounds(commonParent);										// find the intersection of the two bounding boxes					var intersectionRect:Rectangle = rect1.intersection(rect2);										// if not pixel-precise, we're done					if (!pixelPrecise) return intersectionRect;										// size of rect needs to be integer size for bitmap data					intersectionRect.x = int(intersectionRect.x);					intersectionRect.y = int(intersectionRect.y);					intersectionRect.width = Math.ceil(intersectionRect.width);					intersectionRect.height = Math.ceil(intersectionRect.height);										// if the rect is empty, we're done					if (intersectionRect.isEmpty()) return intersectionRect;										// calculate the transform for the display object relative to the common parent					var parentXformInvert:Matrix = commonParent.transform.concatenatedMatrix.clone();					parentXformInvert.invert();					var target1Xform:Matrix = target1.transform.concatenatedMatrix.clone();					target1Xform.concat(parentXformInvert);					var target2Xform:Matrix = target2.transform.concatenatedMatrix.clone();					target2Xform.concat(parentXformInvert);										// translate the target into the rect's space					target1Xform.translate(-intersectionRect.x, -intersectionRect.y);					target2Xform.translate(-intersectionRect.x, -intersectionRect.y);										// combine the display objects					var bd:BitmapData = new BitmapData(intersectionRect.width, intersectionRect.height, false);					bd.draw(target1, target1Xform, new ColorTransform(1, 1, 1, 1, 255, -255, -255, tolerance), BlendMode.NORMAL);					bd.draw(target2, target2Xform, new ColorTransform(1, 1, 1, 1, 255, 255, 255, tolerance), BlendMode.DIFFERENCE);										// find overlap					var overlapRect:Rectangle = bd.getColorBoundsRect(0xffffffff, 0xff00ffff);					overlapRect.offset(intersectionRect.x, intersectionRect.y);										bd.dispose();										return overlapRect;				}						}	}		